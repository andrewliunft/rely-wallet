"use strict";
(() => {
    var v3 = Object.create;
    var Xa = Object.defineProperty;
    var w3 = Object.getOwnPropertyDescriptor;
    var _3 = Object.getOwnPropertyNames;
    var E3 = Object.getPrototypeOf,
        S3 = Object.prototype.hasOwnProperty;
    var nd = (r => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(r, {
        get: (e, t) => (typeof require < "u" ? require : e)[t]
    }) : r)(function(r) {
        if (typeof require < "u") return require.apply(this, arguments);
        throw new Error('Dynamic require of "' + r + '" is not supported')
    });
    var on = (r, e) => () => (r && (e = r(r = 0)), e);
    var Ue = (r, e) => () => (e || r((e = {
            exports: {}
        }).exports, e), e.exports),
        ct = (r, e) => {
            for (var t in e) Xa(r, t, {
                get: e[t],
                enumerable: !0
            })
        },
        id = (r, e, t, n) => {
            if (e && typeof e == "object" || typeof e == "function")
                for (let i of _3(e)) !S3.call(r, i) && i !== t && Xa(r, i, {
                    get: () => e[i],
                    enumerable: !(n = w3(e, i)) || n.enumerable
                });
            return r
        };
    var jt = (r, e, t) => (t = r != null ? v3(E3(r)) : {}, id(e || !r || !r.__esModule ? Xa(t, "default", {
            value: r,
            enumerable: !0
        }) : t, r)),
        od = r => id(Xa({}, "__esModule", {
            value: !0
        }), r);
    var ah = (r, e, t) => {
        if (!e.has(r)) throw TypeError("Cannot " + t)
    };
    var sr = (r, e, t) => (ah(r, e, "read from private field"), t ? t.call(r) : e.get(r)),
        Fn = (r, e, t) => {
            if (e.has(r)) throw TypeError("Cannot add the same private member more than once");
            e instanceof WeakSet ? e.add(r) : e.set(r, t)
        },
        Mn = (r, e, t, n) => (ah(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t);
    var fh = (r, e, t) => (ah(r, e, "access private method"), t);
    var xr = (r, e, t) => new Promise((n, i) => {
            var o = g => {
                    try {
                        y(t.next(g))
                    } catch (E) {
                        i(E)
                    }
                },
                a = g => {
                    try {
                        y(t.throw(g))
                    } catch (E) {
                        i(E)
                    }
                },
                y = g => g.done ? n(g.value) : Promise.resolve(g.value).then(o, a);
            y((t = t.apply(r, e)).next())
        }),
        uh = (r, e, t) => (e = r[Symbol.asyncIterator], t = (n, i) => (i = r[n]) && (e[n] = o => new Promise((a, y, g) => (o = i.call(r, o), g = o.done, Promise.resolve(o.value).then(E => a({
            value: E,
            done: g
        }), y)))), e ? e.call(r) : (r = r[Symbol.iterator](), e = {}, t("next"), t("return"), e));
    var ff = Ue(() => {});
    var Sd = Ue((Ed, bh) => {
        (function(r, e) {
            "use strict";

            function t(l, s) {
                if (!l) throw new Error(s || "Assertion failed")
            }

            function n(l, s) {
                l.super_ = s;
                var f = function() {};
                f.prototype = s.prototype, l.prototype = new f, l.prototype.constructor = l
            }

            function i(l, s, f) {
                if (i.isBN(l)) return l;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, l !== null && ((s === "le" || s === "be") && (f = s, s = 10), this._init(l || 0, s || 10, f || "be"))
            }
            typeof r == "object" ? r.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
            var o;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = ff().Buffer
            } catch {}
            i.isBN = function(s) {
                return s instanceof i ? !0 : s !== null && typeof s == "object" && s.constructor.wordSize === i.wordSize && Array.isArray(s.words)
            }, i.max = function(s, f) {
                return s.cmp(f) > 0 ? s : f
            }, i.min = function(s, f) {
                return s.cmp(f) < 0 ? s : f
            }, i.prototype._init = function(s, f, h) {
                if (typeof s == "number") return this._initNumber(s, f, h);
                if (typeof s == "object") return this._initArray(s, f, h);
                f === "hex" && (f = 16), t(f === (f | 0) && f >= 2 && f <= 36), s = s.toString().replace(/\s+/g, "");
                var p = 0;
                s[0] === "-" && (p++, this.negative = 1), p < s.length && (f === 16 ? this._parseHex(s, p, h) : (this._parseBase(s, f, p), h === "le" && this._initArray(this.toArray(), f, h)))
            }, i.prototype._initNumber = function(s, f, h) {
                s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [s & 67108863, s / 67108864 & 67108863], this.length = 2) : (t(s < 9007199254740992), this.words = [s & 67108863, s / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), f, h)
            }, i.prototype._initArray = function(s, f, h) {
                if (t(typeof s.length == "number"), s.length <= 0) return this.words = [0], this.length = 1, this;
                this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);
                for (var p = 0; p < this.length; p++) this.words[p] = 0;
                var d, c, x = 0;
                if (h === "be")
                    for (p = s.length - 1, d = 0; p >= 0; p -= 3) c = s[p] | s[p - 1] << 8 | s[p - 2] << 16, this.words[d] |= c << x & 67108863, this.words[d + 1] = c >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, d++);
                else if (h === "le")
                    for (p = 0, d = 0; p < s.length; p += 3) c = s[p] | s[p + 1] << 8 | s[p + 2] << 16, this.words[d] |= c << x & 67108863, this.words[d + 1] = c >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, d++);
                return this._strip()
            };

            function a(l, s) {
                var f = l.charCodeAt(s);
                if (f >= 48 && f <= 57) return f - 48;
                if (f >= 65 && f <= 70) return f - 55;
                if (f >= 97 && f <= 102) return f - 87;
                t(!1, "Invalid character in " + l)
            }

            function y(l, s, f) {
                var h = a(l, f);
                return f - 1 >= s && (h |= a(l, f - 1) << 4), h
            }
            i.prototype._parseHex = function(s, f, h) {
                this.length = Math.ceil((s.length - f) / 6), this.words = new Array(this.length);
                for (var p = 0; p < this.length; p++) this.words[p] = 0;
                var d = 0,
                    c = 0,
                    x;
                if (h === "be")
                    for (p = s.length - 1; p >= f; p -= 2) x = y(s, f, p) << d, this.words[c] |= x & 67108863, d >= 18 ? (d -= 18, c += 1, this.words[c] |= x >>> 26) : d += 8;
                else {
                    var v = s.length - f;
                    for (p = v % 2 === 0 ? f + 1 : f; p < s.length; p += 2) x = y(s, f, p) << d, this.words[c] |= x & 67108863, d >= 18 ? (d -= 18, c += 1, this.words[c] |= x >>> 26) : d += 8
                }
                this._strip()
            };

            function g(l, s, f, h) {
                for (var p = 0, d = 0, c = Math.min(l.length, f), x = s; x < c; x++) {
                    var v = l.charCodeAt(x) - 48;
                    p *= h, v >= 49 ? d = v - 49 + 10 : v >= 17 ? d = v - 17 + 10 : d = v, t(v >= 0 && d < h, "Invalid character"), p += d
                }
                return p
            }
            i.prototype._parseBase = function(s, f, h) {
                this.words = [0], this.length = 1;
                for (var p = 0, d = 1; d <= 67108863; d *= f) p++;
                p--, d = d / f | 0;
                for (var c = s.length - h, x = c % p, v = Math.min(c, c - x) + h, u = 0, _ = h; _ < v; _ += p) u = g(s, _, _ + p, f), this.imuln(d), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
                if (x !== 0) {
                    var F = 1;
                    for (u = g(s, _, s.length, f), _ = 0; _ < x; _++) F *= f;
                    this.imuln(F), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u)
                }
                this._strip()
            }, i.prototype.copy = function(s) {
                s.words = new Array(this.length);
                for (var f = 0; f < this.length; f++) s.words[f] = this.words[f];
                s.length = this.length, s.negative = this.negative, s.red = this.red
            };

            function E(l, s) {
                l.words = s.words, l.length = s.length, l.negative = s.negative, l.red = s.red
            }
            if (i.prototype._move = function(s) {
                    E(s, this)
                }, i.prototype.clone = function() {
                    var s = new i(null);
                    return this.copy(s), s
                }, i.prototype._expand = function(s) {
                    for (; this.length < s;) this.words[this.length++] = 0;
                    return this
                }, i.prototype._strip = function() {
                    for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
                    return this._normSign()
                }, i.prototype._normSign = function() {
                    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
                }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
                i.prototype[Symbol.for("nodejs.util.inspect.custom")] = A
            } catch {
                i.prototype.inspect = A
            } else i.prototype.inspect = A;

            function A() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            var I = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                q = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                L = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            i.prototype.toString = function(s, f) {
                s = s || 10, f = f | 0 || 1;
                var h;
                if (s === 16 || s === "hex") {
                    h = "";
                    for (var p = 0, d = 0, c = 0; c < this.length; c++) {
                        var x = this.words[c],
                            v = ((x << p | d) & 16777215).toString(16);
                        d = x >>> 24 - p & 16777215, p += 2, p >= 26 && (p -= 26, c--), d !== 0 || c !== this.length - 1 ? h = I[6 - v.length] + v + h : h = v + h
                    }
                    for (d !== 0 && (h = d.toString(16) + h); h.length % f !== 0;) h = "0" + h;
                    return this.negative !== 0 && (h = "-" + h), h
                }
                if (s === (s | 0) && s >= 2 && s <= 36) {
                    var u = q[s],
                        _ = L[s];
                    h = "";
                    var F = this.clone();
                    for (F.negative = 0; !F.isZero();) {
                        var S = F.modrn(_).toString(s);
                        F = F.idivn(_), F.isZero() ? h = S + h : h = I[u - S.length] + S + h
                    }
                    for (this.isZero() && (h = "0" + h); h.length % f !== 0;) h = "0" + h;
                    return this.negative !== 0 && (h = "-" + h), h
                }
                t(!1, "Base should be between 2 and 36")
            }, i.prototype.toNumber = function() {
                var s = this.words[0];
                return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && t(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s : s
            }, i.prototype.toJSON = function() {
                return this.toString(16, 2)
            }, o && (i.prototype.toBuffer = function(s, f) {
                return this.toArrayLike(o, s, f)
            }), i.prototype.toArray = function(s, f) {
                return this.toArrayLike(Array, s, f)
            };
            var O = function(s, f) {
                return s.allocUnsafe ? s.allocUnsafe(f) : new s(f)
            };
            i.prototype.toArrayLike = function(s, f, h) {
                this._strip();
                var p = this.byteLength(),
                    d = h || Math.max(1, p);
                t(p <= d, "byte array longer than desired length"), t(d > 0, "Requested array length <= 0");
                var c = O(s, d),
                    x = f === "le" ? "LE" : "BE";
                return this["_toArrayLike" + x](c, p), c
            }, i.prototype._toArrayLikeLE = function(s, f) {
                for (var h = 0, p = 0, d = 0, c = 0; d < this.length; d++) {
                    var x = this.words[d] << c | p;
                    s[h++] = x & 255, h < s.length && (s[h++] = x >> 8 & 255), h < s.length && (s[h++] = x >> 16 & 255), c === 6 ? (h < s.length && (s[h++] = x >> 24 & 255), p = 0, c = 0) : (p = x >>> 24, c += 2)
                }
                if (h < s.length)
                    for (s[h++] = p; h < s.length;) s[h++] = 0
            }, i.prototype._toArrayLikeBE = function(s, f) {
                for (var h = s.length - 1, p = 0, d = 0, c = 0; d < this.length; d++) {
                    var x = this.words[d] << c | p;
                    s[h--] = x & 255, h >= 0 && (s[h--] = x >> 8 & 255), h >= 0 && (s[h--] = x >> 16 & 255), c === 6 ? (h >= 0 && (s[h--] = x >> 24 & 255), p = 0, c = 0) : (p = x >>> 24, c += 2)
                }
                if (h >= 0)
                    for (s[h--] = p; h >= 0;) s[h--] = 0
            }, Math.clz32 ? i.prototype._countBits = function(s) {
                return 32 - Math.clz32(s)
            } : i.prototype._countBits = function(s) {
                var f = s,
                    h = 0;
                return f >= 4096 && (h += 13, f >>>= 13), f >= 64 && (h += 7, f >>>= 7), f >= 8 && (h += 4, f >>>= 4), f >= 2 && (h += 2, f >>>= 2), h + f
            }, i.prototype._zeroBits = function(s) {
                if (s === 0) return 26;
                var f = s,
                    h = 0;
                return (f & 8191) === 0 && (h += 13, f >>>= 13), (f & 127) === 0 && (h += 7, f >>>= 7), (f & 15) === 0 && (h += 4, f >>>= 4), (f & 3) === 0 && (h += 2, f >>>= 2), (f & 1) === 0 && h++, h
            }, i.prototype.bitLength = function() {
                var s = this.words[this.length - 1],
                    f = this._countBits(s);
                return (this.length - 1) * 26 + f
            };

            function Z(l) {
                for (var s = new Array(l.bitLength()), f = 0; f < s.length; f++) {
                    var h = f / 26 | 0,
                        p = f % 26;
                    s[f] = l.words[h] >>> p & 1
                }
                return s
            }
            i.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for (var s = 0, f = 0; f < this.length; f++) {
                    var h = this._zeroBits(this.words[f]);
                    if (s += h, h !== 26) break
                }
                return s
            }, i.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }, i.prototype.toTwos = function(s) {
                return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone()
            }, i.prototype.fromTwos = function(s) {
                return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone()
            }, i.prototype.isNeg = function() {
                return this.negative !== 0
            }, i.prototype.neg = function() {
                return this.clone().ineg()
            }, i.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this
            }, i.prototype.iuor = function(s) {
                for (; this.length < s.length;) this.words[this.length++] = 0;
                for (var f = 0; f < s.length; f++) this.words[f] = this.words[f] | s.words[f];
                return this._strip()
            }, i.prototype.ior = function(s) {
                return t((this.negative | s.negative) === 0), this.iuor(s)
            }, i.prototype.or = function(s) {
                return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this)
            }, i.prototype.uor = function(s) {
                return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this)
            }, i.prototype.iuand = function(s) {
                var f;
                this.length > s.length ? f = s : f = this;
                for (var h = 0; h < f.length; h++) this.words[h] = this.words[h] & s.words[h];
                return this.length = f.length, this._strip()
            }, i.prototype.iand = function(s) {
                return t((this.negative | s.negative) === 0), this.iuand(s)
            }, i.prototype.and = function(s) {
                return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this)
            }, i.prototype.uand = function(s) {
                return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this)
            }, i.prototype.iuxor = function(s) {
                var f, h;
                this.length > s.length ? (f = this, h = s) : (f = s, h = this);
                for (var p = 0; p < h.length; p++) this.words[p] = f.words[p] ^ h.words[p];
                if (this !== f)
                    for (; p < f.length; p++) this.words[p] = f.words[p];
                return this.length = f.length, this._strip()
            }, i.prototype.ixor = function(s) {
                return t((this.negative | s.negative) === 0), this.iuxor(s)
            }, i.prototype.xor = function(s) {
                return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this)
            }, i.prototype.uxor = function(s) {
                return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this)
            }, i.prototype.inotn = function(s) {
                t(typeof s == "number" && s >= 0);
                var f = Math.ceil(s / 26) | 0,
                    h = s % 26;
                this._expand(f), h > 0 && f--;
                for (var p = 0; p < f; p++) this.words[p] = ~this.words[p] & 67108863;
                return h > 0 && (this.words[p] = ~this.words[p] & 67108863 >> 26 - h), this._strip()
            }, i.prototype.notn = function(s) {
                return this.clone().inotn(s)
            }, i.prototype.setn = function(s, f) {
                t(typeof s == "number" && s >= 0);
                var h = s / 26 | 0,
                    p = s % 26;
                return this._expand(h + 1), f ? this.words[h] = this.words[h] | 1 << p : this.words[h] = this.words[h] & ~(1 << p), this._strip()
            }, i.prototype.iadd = function(s) {
                var f;
                if (this.negative !== 0 && s.negative === 0) return this.negative = 0, f = this.isub(s), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && s.negative !== 0) return s.negative = 0, f = this.isub(s), s.negative = 1, f._normSign();
                var h, p;
                this.length > s.length ? (h = this, p = s) : (h = s, p = this);
                for (var d = 0, c = 0; c < p.length; c++) f = (h.words[c] | 0) + (p.words[c] | 0) + d, this.words[c] = f & 67108863, d = f >>> 26;
                for (; d !== 0 && c < h.length; c++) f = (h.words[c] | 0) + d, this.words[c] = f & 67108863, d = f >>> 26;
                if (this.length = h.length, d !== 0) this.words[this.length] = d, this.length++;
                else if (h !== this)
                    for (; c < h.length; c++) this.words[c] = h.words[c];
                return this
            }, i.prototype.add = function(s) {
                var f;
                return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, f = this.sub(s), s.negative ^= 1, f) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, f = s.sub(this), this.negative = 1, f) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this)
            }, i.prototype.isub = function(s) {
                if (s.negative !== 0) {
                    s.negative = 0;
                    var f = this.iadd(s);
                    return s.negative = 1, f._normSign()
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();
                var h = this.cmp(s);
                if (h === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var p, d;
                h > 0 ? (p = this, d = s) : (p = s, d = this);
                for (var c = 0, x = 0; x < d.length; x++) f = (p.words[x] | 0) - (d.words[x] | 0) + c, c = f >> 26, this.words[x] = f & 67108863;
                for (; c !== 0 && x < p.length; x++) f = (p.words[x] | 0) + c, c = f >> 26, this.words[x] = f & 67108863;
                if (c === 0 && x < p.length && p !== this)
                    for (; x < p.length; x++) this.words[x] = p.words[x];
                return this.length = Math.max(this.length, x), p !== this && (this.negative = 1), this._strip()
            }, i.prototype.sub = function(s) {
                return this.clone().isub(s)
            };

            function ge(l, s, f) {
                f.negative = s.negative ^ l.negative;
                var h = l.length + s.length | 0;
                f.length = h, h = h - 1 | 0;
                var p = l.words[0] | 0,
                    d = s.words[0] | 0,
                    c = p * d,
                    x = c & 67108863,
                    v = c / 67108864 | 0;
                f.words[0] = x;
                for (var u = 1; u < h; u++) {
                    for (var _ = v >>> 26, F = v & 67108863, S = Math.min(u, s.length - 1), z = Math.max(0, u - l.length + 1); z <= S; z++) {
                        var C = u - z | 0;
                        p = l.words[C] | 0, d = s.words[z] | 0, c = p * d + F, _ += c / 67108864 | 0, F = c & 67108863
                    }
                    f.words[u] = F | 0, v = _ | 0
                }
                return v !== 0 ? f.words[u] = v | 0 : f.length--, f._strip()
            }
            var ce = function(s, f, h) {
                var p = s.words,
                    d = f.words,
                    c = h.words,
                    x = 0,
                    v, u, _, F = p[0] | 0,
                    S = F & 8191,
                    z = F >>> 13,
                    C = p[1] | 0,
                    D = C & 8191,
                    Y = C >>> 13,
                    Re = p[2] | 0,
                    ee = Re & 8191,
                    re = Re >>> 13,
                    Zt = p[3] | 0,
                    me = Zt & 8191,
                    Ee = Zt >>> 13,
                    $r = p[4] | 0,
                    Qe = $r & 8191,
                    Le = $r >>> 13,
                    Ar = p[5] | 0,
                    et = Ar & 8191,
                    je = Ar >>> 13,
                    Ur = p[6] | 0,
                    De = Ur & 8191,
                    We = Ur >>> 13,
                    Ir = p[7] | 0,
                    He = Ir & 8191,
                    Ve = Ir >>> 13,
                    jr = p[8] | 0,
                    it = jr & 8191,
                    Ge = jr >>> 13,
                    Nr = p[9] | 0,
                    Ke = Nr & 8191,
                    Fe = Nr >>> 13,
                    vr = d[0] | 0,
                    Ce = vr & 8191,
                    $e = vr >>> 13,
                    _r = d[1] | 0,
                    Oe = _r & 8191,
                    Ze = _r >>> 13,
                    Wr = d[2] | 0,
                    ot = Wr & 8191,
                    st = Wr >>> 13,
                    dr = d[3] | 0,
                    ze = dr & 8191,
                    Ne = dr >>> 13,
                    qr = d[4] | 0,
                    Ye = qr & 8191,
                    tt = qr >>> 13,
                    nn = d[5] | 0,
                    Be = nn & 8191,
                    rt = nn >>> 13,
                    M = d[6] | 0,
                    k = M & 8191,
                    R = M >>> 13,
                    b = d[7] | 0,
                    P = b & 8191,
                    U = b >>> 13,
                    j = d[8] | 0,
                    K = j & 8191,
                    W = j >>> 13,
                    Pe = d[9] | 0,
                    ne = Pe & 8191,
                    Me = Pe >>> 13;
                h.negative = s.negative ^ f.negative, h.length = 19, v = Math.imul(S, Ce), u = Math.imul(S, $e), u = u + Math.imul(z, Ce) | 0, _ = Math.imul(z, $e);
                var Ae = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, v = Math.imul(D, Ce), u = Math.imul(D, $e), u = u + Math.imul(Y, Ce) | 0, _ = Math.imul(Y, $e), v = v + Math.imul(S, Oe) | 0, u = u + Math.imul(S, Ze) | 0, u = u + Math.imul(z, Oe) | 0, _ = _ + Math.imul(z, Ze) | 0;
                var ut = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, v = Math.imul(ee, Ce), u = Math.imul(ee, $e), u = u + Math.imul(re, Ce) | 0, _ = Math.imul(re, $e), v = v + Math.imul(D, Oe) | 0, u = u + Math.imul(D, Ze) | 0, u = u + Math.imul(Y, Oe) | 0, _ = _ + Math.imul(Y, Ze) | 0, v = v + Math.imul(S, ot) | 0, u = u + Math.imul(S, st) | 0, u = u + Math.imul(z, ot) | 0, _ = _ + Math.imul(z, st) | 0;
                var ht = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, v = Math.imul(me, Ce), u = Math.imul(me, $e), u = u + Math.imul(Ee, Ce) | 0, _ = Math.imul(Ee, $e), v = v + Math.imul(ee, Oe) | 0, u = u + Math.imul(ee, Ze) | 0, u = u + Math.imul(re, Oe) | 0, _ = _ + Math.imul(re, Ze) | 0, v = v + Math.imul(D, ot) | 0, u = u + Math.imul(D, st) | 0, u = u + Math.imul(Y, ot) | 0, _ = _ + Math.imul(Y, st) | 0, v = v + Math.imul(S, ze) | 0, u = u + Math.imul(S, Ne) | 0, u = u + Math.imul(z, ze) | 0, _ = _ + Math.imul(z, Ne) | 0;
                var pt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, v = Math.imul(Qe, Ce), u = Math.imul(Qe, $e), u = u + Math.imul(Le, Ce) | 0, _ = Math.imul(Le, $e), v = v + Math.imul(me, Oe) | 0, u = u + Math.imul(me, Ze) | 0, u = u + Math.imul(Ee, Oe) | 0, _ = _ + Math.imul(Ee, Ze) | 0, v = v + Math.imul(ee, ot) | 0, u = u + Math.imul(ee, st) | 0, u = u + Math.imul(re, ot) | 0, _ = _ + Math.imul(re, st) | 0, v = v + Math.imul(D, ze) | 0, u = u + Math.imul(D, Ne) | 0, u = u + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, Ne) | 0, v = v + Math.imul(S, Ye) | 0, u = u + Math.imul(S, tt) | 0, u = u + Math.imul(z, Ye) | 0, _ = _ + Math.imul(z, tt) | 0;
                var dt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, v = Math.imul(et, Ce), u = Math.imul(et, $e), u = u + Math.imul(je, Ce) | 0, _ = Math.imul(je, $e), v = v + Math.imul(Qe, Oe) | 0, u = u + Math.imul(Qe, Ze) | 0, u = u + Math.imul(Le, Oe) | 0, _ = _ + Math.imul(Le, Ze) | 0, v = v + Math.imul(me, ot) | 0, u = u + Math.imul(me, st) | 0, u = u + Math.imul(Ee, ot) | 0, _ = _ + Math.imul(Ee, st) | 0, v = v + Math.imul(ee, ze) | 0, u = u + Math.imul(ee, Ne) | 0, u = u + Math.imul(re, ze) | 0, _ = _ + Math.imul(re, Ne) | 0, v = v + Math.imul(D, Ye) | 0, u = u + Math.imul(D, tt) | 0, u = u + Math.imul(Y, Ye) | 0, _ = _ + Math.imul(Y, tt) | 0, v = v + Math.imul(S, Be) | 0, u = u + Math.imul(S, rt) | 0, u = u + Math.imul(z, Be) | 0, _ = _ + Math.imul(z, rt) | 0;
                var yt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, v = Math.imul(De, Ce), u = Math.imul(De, $e), u = u + Math.imul(We, Ce) | 0, _ = Math.imul(We, $e), v = v + Math.imul(et, Oe) | 0, u = u + Math.imul(et, Ze) | 0, u = u + Math.imul(je, Oe) | 0, _ = _ + Math.imul(je, Ze) | 0, v = v + Math.imul(Qe, ot) | 0, u = u + Math.imul(Qe, st) | 0, u = u + Math.imul(Le, ot) | 0, _ = _ + Math.imul(Le, st) | 0, v = v + Math.imul(me, ze) | 0, u = u + Math.imul(me, Ne) | 0, u = u + Math.imul(Ee, ze) | 0, _ = _ + Math.imul(Ee, Ne) | 0, v = v + Math.imul(ee, Ye) | 0, u = u + Math.imul(ee, tt) | 0, u = u + Math.imul(re, Ye) | 0, _ = _ + Math.imul(re, tt) | 0, v = v + Math.imul(D, Be) | 0, u = u + Math.imul(D, rt) | 0, u = u + Math.imul(Y, Be) | 0, _ = _ + Math.imul(Y, rt) | 0, v = v + Math.imul(S, k) | 0, u = u + Math.imul(S, R) | 0, u = u + Math.imul(z, k) | 0, _ = _ + Math.imul(z, R) | 0;
                var bt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, v = Math.imul(He, Ce), u = Math.imul(He, $e), u = u + Math.imul(Ve, Ce) | 0, _ = Math.imul(Ve, $e), v = v + Math.imul(De, Oe) | 0, u = u + Math.imul(De, Ze) | 0, u = u + Math.imul(We, Oe) | 0, _ = _ + Math.imul(We, Ze) | 0, v = v + Math.imul(et, ot) | 0, u = u + Math.imul(et, st) | 0, u = u + Math.imul(je, ot) | 0, _ = _ + Math.imul(je, st) | 0, v = v + Math.imul(Qe, ze) | 0, u = u + Math.imul(Qe, Ne) | 0, u = u + Math.imul(Le, ze) | 0, _ = _ + Math.imul(Le, Ne) | 0, v = v + Math.imul(me, Ye) | 0, u = u + Math.imul(me, tt) | 0, u = u + Math.imul(Ee, Ye) | 0, _ = _ + Math.imul(Ee, tt) | 0, v = v + Math.imul(ee, Be) | 0, u = u + Math.imul(ee, rt) | 0, u = u + Math.imul(re, Be) | 0, _ = _ + Math.imul(re, rt) | 0, v = v + Math.imul(D, k) | 0, u = u + Math.imul(D, R) | 0, u = u + Math.imul(Y, k) | 0, _ = _ + Math.imul(Y, R) | 0, v = v + Math.imul(S, P) | 0, u = u + Math.imul(S, U) | 0, u = u + Math.imul(z, P) | 0, _ = _ + Math.imul(z, U) | 0;
                var mt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, v = Math.imul(it, Ce), u = Math.imul(it, $e), u = u + Math.imul(Ge, Ce) | 0, _ = Math.imul(Ge, $e), v = v + Math.imul(He, Oe) | 0, u = u + Math.imul(He, Ze) | 0, u = u + Math.imul(Ve, Oe) | 0, _ = _ + Math.imul(Ve, Ze) | 0, v = v + Math.imul(De, ot) | 0, u = u + Math.imul(De, st) | 0, u = u + Math.imul(We, ot) | 0, _ = _ + Math.imul(We, st) | 0, v = v + Math.imul(et, ze) | 0, u = u + Math.imul(et, Ne) | 0, u = u + Math.imul(je, ze) | 0, _ = _ + Math.imul(je, Ne) | 0, v = v + Math.imul(Qe, Ye) | 0, u = u + Math.imul(Qe, tt) | 0, u = u + Math.imul(Le, Ye) | 0, _ = _ + Math.imul(Le, tt) | 0, v = v + Math.imul(me, Be) | 0, u = u + Math.imul(me, rt) | 0, u = u + Math.imul(Ee, Be) | 0, _ = _ + Math.imul(Ee, rt) | 0, v = v + Math.imul(ee, k) | 0, u = u + Math.imul(ee, R) | 0, u = u + Math.imul(re, k) | 0, _ = _ + Math.imul(re, R) | 0, v = v + Math.imul(D, P) | 0, u = u + Math.imul(D, U) | 0, u = u + Math.imul(Y, P) | 0, _ = _ + Math.imul(Y, U) | 0, v = v + Math.imul(S, K) | 0, u = u + Math.imul(S, W) | 0, u = u + Math.imul(z, K) | 0, _ = _ + Math.imul(z, W) | 0;
                var ke = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, v = Math.imul(Ke, Ce), u = Math.imul(Ke, $e), u = u + Math.imul(Fe, Ce) | 0, _ = Math.imul(Fe, $e), v = v + Math.imul(it, Oe) | 0, u = u + Math.imul(it, Ze) | 0, u = u + Math.imul(Ge, Oe) | 0, _ = _ + Math.imul(Ge, Ze) | 0, v = v + Math.imul(He, ot) | 0, u = u + Math.imul(He, st) | 0, u = u + Math.imul(Ve, ot) | 0, _ = _ + Math.imul(Ve, st) | 0, v = v + Math.imul(De, ze) | 0, u = u + Math.imul(De, Ne) | 0, u = u + Math.imul(We, ze) | 0, _ = _ + Math.imul(We, Ne) | 0, v = v + Math.imul(et, Ye) | 0, u = u + Math.imul(et, tt) | 0, u = u + Math.imul(je, Ye) | 0, _ = _ + Math.imul(je, tt) | 0, v = v + Math.imul(Qe, Be) | 0, u = u + Math.imul(Qe, rt) | 0, u = u + Math.imul(Le, Be) | 0, _ = _ + Math.imul(Le, rt) | 0, v = v + Math.imul(me, k) | 0, u = u + Math.imul(me, R) | 0, u = u + Math.imul(Ee, k) | 0, _ = _ + Math.imul(Ee, R) | 0, v = v + Math.imul(ee, P) | 0, u = u + Math.imul(ee, U) | 0, u = u + Math.imul(re, P) | 0, _ = _ + Math.imul(re, U) | 0, v = v + Math.imul(D, K) | 0, u = u + Math.imul(D, W) | 0, u = u + Math.imul(Y, K) | 0, _ = _ + Math.imul(Y, W) | 0, v = v + Math.imul(S, ne) | 0, u = u + Math.imul(S, Me) | 0, u = u + Math.imul(z, ne) | 0, _ = _ + Math.imul(z, Me) | 0;
                var at = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, v = Math.imul(Ke, Oe), u = Math.imul(Ke, Ze), u = u + Math.imul(Fe, Oe) | 0, _ = Math.imul(Fe, Ze), v = v + Math.imul(it, ot) | 0, u = u + Math.imul(it, st) | 0, u = u + Math.imul(Ge, ot) | 0, _ = _ + Math.imul(Ge, st) | 0, v = v + Math.imul(He, ze) | 0, u = u + Math.imul(He, Ne) | 0, u = u + Math.imul(Ve, ze) | 0, _ = _ + Math.imul(Ve, Ne) | 0, v = v + Math.imul(De, Ye) | 0, u = u + Math.imul(De, tt) | 0, u = u + Math.imul(We, Ye) | 0, _ = _ + Math.imul(We, tt) | 0, v = v + Math.imul(et, Be) | 0, u = u + Math.imul(et, rt) | 0, u = u + Math.imul(je, Be) | 0, _ = _ + Math.imul(je, rt) | 0, v = v + Math.imul(Qe, k) | 0, u = u + Math.imul(Qe, R) | 0, u = u + Math.imul(Le, k) | 0, _ = _ + Math.imul(Le, R) | 0, v = v + Math.imul(me, P) | 0, u = u + Math.imul(me, U) | 0, u = u + Math.imul(Ee, P) | 0, _ = _ + Math.imul(Ee, U) | 0, v = v + Math.imul(ee, K) | 0, u = u + Math.imul(ee, W) | 0, u = u + Math.imul(re, K) | 0, _ = _ + Math.imul(re, W) | 0, v = v + Math.imul(D, ne) | 0, u = u + Math.imul(D, Me) | 0, u = u + Math.imul(Y, ne) | 0, _ = _ + Math.imul(Y, Me) | 0;
                var Ie = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, v = Math.imul(Ke, ot), u = Math.imul(Ke, st), u = u + Math.imul(Fe, ot) | 0, _ = Math.imul(Fe, st), v = v + Math.imul(it, ze) | 0, u = u + Math.imul(it, Ne) | 0, u = u + Math.imul(Ge, ze) | 0, _ = _ + Math.imul(Ge, Ne) | 0, v = v + Math.imul(He, Ye) | 0, u = u + Math.imul(He, tt) | 0, u = u + Math.imul(Ve, Ye) | 0, _ = _ + Math.imul(Ve, tt) | 0, v = v + Math.imul(De, Be) | 0, u = u + Math.imul(De, rt) | 0, u = u + Math.imul(We, Be) | 0, _ = _ + Math.imul(We, rt) | 0, v = v + Math.imul(et, k) | 0, u = u + Math.imul(et, R) | 0, u = u + Math.imul(je, k) | 0, _ = _ + Math.imul(je, R) | 0, v = v + Math.imul(Qe, P) | 0, u = u + Math.imul(Qe, U) | 0, u = u + Math.imul(Le, P) | 0, _ = _ + Math.imul(Le, U) | 0, v = v + Math.imul(me, K) | 0, u = u + Math.imul(me, W) | 0, u = u + Math.imul(Ee, K) | 0, _ = _ + Math.imul(Ee, W) | 0, v = v + Math.imul(ee, ne) | 0, u = u + Math.imul(ee, Me) | 0, u = u + Math.imul(re, ne) | 0, _ = _ + Math.imul(re, Me) | 0;
                var Te = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, v = Math.imul(Ke, ze), u = Math.imul(Ke, Ne), u = u + Math.imul(Fe, ze) | 0, _ = Math.imul(Fe, Ne), v = v + Math.imul(it, Ye) | 0, u = u + Math.imul(it, tt) | 0, u = u + Math.imul(Ge, Ye) | 0, _ = _ + Math.imul(Ge, tt) | 0, v = v + Math.imul(He, Be) | 0, u = u + Math.imul(He, rt) | 0, u = u + Math.imul(Ve, Be) | 0, _ = _ + Math.imul(Ve, rt) | 0, v = v + Math.imul(De, k) | 0, u = u + Math.imul(De, R) | 0, u = u + Math.imul(We, k) | 0, _ = _ + Math.imul(We, R) | 0, v = v + Math.imul(et, P) | 0, u = u + Math.imul(et, U) | 0, u = u + Math.imul(je, P) | 0, _ = _ + Math.imul(je, U) | 0, v = v + Math.imul(Qe, K) | 0, u = u + Math.imul(Qe, W) | 0, u = u + Math.imul(Le, K) | 0, _ = _ + Math.imul(Le, W) | 0, v = v + Math.imul(me, ne) | 0, u = u + Math.imul(me, Me) | 0, u = u + Math.imul(Ee, ne) | 0, _ = _ + Math.imul(Ee, Me) | 0;
                var qe = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, v = Math.imul(Ke, Ye), u = Math.imul(Ke, tt), u = u + Math.imul(Fe, Ye) | 0, _ = Math.imul(Fe, tt), v = v + Math.imul(it, Be) | 0, u = u + Math.imul(it, rt) | 0, u = u + Math.imul(Ge, Be) | 0, _ = _ + Math.imul(Ge, rt) | 0, v = v + Math.imul(He, k) | 0, u = u + Math.imul(He, R) | 0, u = u + Math.imul(Ve, k) | 0, _ = _ + Math.imul(Ve, R) | 0, v = v + Math.imul(De, P) | 0, u = u + Math.imul(De, U) | 0, u = u + Math.imul(We, P) | 0, _ = _ + Math.imul(We, U) | 0, v = v + Math.imul(et, K) | 0, u = u + Math.imul(et, W) | 0, u = u + Math.imul(je, K) | 0, _ = _ + Math.imul(je, W) | 0, v = v + Math.imul(Qe, ne) | 0, u = u + Math.imul(Qe, Me) | 0, u = u + Math.imul(Le, ne) | 0, _ = _ + Math.imul(Le, Me) | 0;
                var Se = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, v = Math.imul(Ke, Be), u = Math.imul(Ke, rt), u = u + Math.imul(Fe, Be) | 0, _ = Math.imul(Fe, rt), v = v + Math.imul(it, k) | 0, u = u + Math.imul(it, R) | 0, u = u + Math.imul(Ge, k) | 0, _ = _ + Math.imul(Ge, R) | 0, v = v + Math.imul(He, P) | 0, u = u + Math.imul(He, U) | 0, u = u + Math.imul(Ve, P) | 0, _ = _ + Math.imul(Ve, U) | 0, v = v + Math.imul(De, K) | 0, u = u + Math.imul(De, W) | 0, u = u + Math.imul(We, K) | 0, _ = _ + Math.imul(We, W) | 0, v = v + Math.imul(et, ne) | 0, u = u + Math.imul(et, Me) | 0, u = u + Math.imul(je, ne) | 0, _ = _ + Math.imul(je, Me) | 0;
                var H = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (H >>> 26) | 0, H &= 67108863, v = Math.imul(Ke, k), u = Math.imul(Ke, R), u = u + Math.imul(Fe, k) | 0, _ = Math.imul(Fe, R), v = v + Math.imul(it, P) | 0, u = u + Math.imul(it, U) | 0, u = u + Math.imul(Ge, P) | 0, _ = _ + Math.imul(Ge, U) | 0, v = v + Math.imul(He, K) | 0, u = u + Math.imul(He, W) | 0, u = u + Math.imul(Ve, K) | 0, _ = _ + Math.imul(Ve, W) | 0, v = v + Math.imul(De, ne) | 0, u = u + Math.imul(De, Me) | 0, u = u + Math.imul(We, ne) | 0, _ = _ + Math.imul(We, Me) | 0;
                var V = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (V >>> 26) | 0, V &= 67108863, v = Math.imul(Ke, P), u = Math.imul(Ke, U), u = u + Math.imul(Fe, P) | 0, _ = Math.imul(Fe, U), v = v + Math.imul(it, K) | 0, u = u + Math.imul(it, W) | 0, u = u + Math.imul(Ge, K) | 0, _ = _ + Math.imul(Ge, W) | 0, v = v + Math.imul(He, ne) | 0, u = u + Math.imul(He, Me) | 0, u = u + Math.imul(Ve, ne) | 0, _ = _ + Math.imul(Ve, Me) | 0;
                var ye = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, v = Math.imul(Ke, K), u = Math.imul(Ke, W), u = u + Math.imul(Fe, K) | 0, _ = Math.imul(Fe, W), v = v + Math.imul(it, ne) | 0, u = u + Math.imul(it, Me) | 0, u = u + Math.imul(Ge, ne) | 0, _ = _ + Math.imul(Ge, Me) | 0;
                var oe = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (oe >>> 26) | 0, oe &= 67108863, v = Math.imul(Ke, ne), u = Math.imul(Ke, Me), u = u + Math.imul(Fe, ne) | 0, _ = Math.imul(Fe, Me);
                var se = (x + v | 0) + ((u & 8191) << 13) | 0;
                return x = (_ + (u >>> 13) | 0) + (se >>> 26) | 0, se &= 67108863, c[0] = Ae, c[1] = ut, c[2] = ht, c[3] = pt, c[4] = dt, c[5] = yt, c[6] = bt, c[7] = mt, c[8] = ke, c[9] = at, c[10] = Ie, c[11] = Te, c[12] = qe, c[13] = Se, c[14] = H, c[15] = V, c[16] = ye, c[17] = oe, c[18] = se, x !== 0 && (c[19] = x, h.length++), h
            };
            Math.imul || (ce = ge);

            function Xe(l, s, f) {
                f.negative = s.negative ^ l.negative, f.length = l.length + s.length;
                for (var h = 0, p = 0, d = 0; d < f.length - 1; d++) {
                    var c = p;
                    p = 0;
                    for (var x = h & 67108863, v = Math.min(d, s.length - 1), u = Math.max(0, d - l.length + 1); u <= v; u++) {
                        var _ = d - u,
                            F = l.words[_] | 0,
                            S = s.words[u] | 0,
                            z = F * S,
                            C = z & 67108863;
                        c = c + (z / 67108864 | 0) | 0, C = C + x | 0, x = C & 67108863, c = c + (C >>> 26) | 0, p += c >>> 26, c &= 67108863
                    }
                    f.words[d] = x, h = c, c = p
                }
                return h !== 0 ? f.words[d] = h : f.length--, f._strip()
            }

            function xe(l, s, f) {
                return Xe(l, s, f)
            }
            i.prototype.mulTo = function(s, f) {
                var h, p = this.length + s.length;
                return this.length === 10 && s.length === 10 ? h = ce(this, s, f) : p < 63 ? h = ge(this, s, f) : p < 1024 ? h = Xe(this, s, f) : h = xe(this, s, f), h
            };

            function ie(l, s) {
                this.x = l, this.y = s
            }
            ie.prototype.makeRBT = function(s) {
                for (var f = new Array(s), h = i.prototype._countBits(s) - 1, p = 0; p < s; p++) f[p] = this.revBin(p, h, s);
                return f
            }, ie.prototype.revBin = function(s, f, h) {
                if (s === 0 || s === h - 1) return s;
                for (var p = 0, d = 0; d < f; d++) p |= (s & 1) << f - d - 1, s >>= 1;
                return p
            }, ie.prototype.permute = function(s, f, h, p, d, c) {
                for (var x = 0; x < c; x++) p[x] = f[s[x]], d[x] = h[s[x]]
            }, ie.prototype.transform = function(s, f, h, p, d, c) {
                this.permute(c, s, f, h, p, d);
                for (var x = 1; x < d; x <<= 1)
                    for (var v = x << 1, u = Math.cos(2 * Math.PI / v), _ = Math.sin(2 * Math.PI / v), F = 0; F < d; F += v)
                        for (var S = u, z = _, C = 0; C < x; C++) {
                            var D = h[F + C],
                                Y = p[F + C],
                                Re = h[F + C + x],
                                ee = p[F + C + x],
                                re = S * Re - z * ee;
                            ee = S * ee + z * Re, Re = re, h[F + C] = D + Re, p[F + C] = Y + ee, h[F + C + x] = D - Re, p[F + C + x] = Y - ee, C !== v && (re = u * S - _ * z, z = u * z + _ * S, S = re)
                        }
            }, ie.prototype.guessLen13b = function(s, f) {
                var h = Math.max(f, s) | 1,
                    p = h & 1,
                    d = 0;
                for (h = h / 2 | 0; h; h = h >>> 1) d++;
                return 1 << d + 1 + p
            }, ie.prototype.conjugate = function(s, f, h) {
                if (!(h <= 1))
                    for (var p = 0; p < h / 2; p++) {
                        var d = s[p];
                        s[p] = s[h - p - 1], s[h - p - 1] = d, d = f[p], f[p] = -f[h - p - 1], f[h - p - 1] = -d
                    }
            }, ie.prototype.normalize13b = function(s, f) {
                for (var h = 0, p = 0; p < f / 2; p++) {
                    var d = Math.round(s[2 * p + 1] / f) * 8192 + Math.round(s[2 * p] / f) + h;
                    s[p] = d & 67108863, d < 67108864 ? h = 0 : h = d / 67108864 | 0
                }
                return s
            }, ie.prototype.convert13b = function(s, f, h, p) {
                for (var d = 0, c = 0; c < f; c++) d = d + (s[c] | 0), h[2 * c] = d & 8191, d = d >>> 13, h[2 * c + 1] = d & 8191, d = d >>> 13;
                for (c = 2 * f; c < p; ++c) h[c] = 0;
                t(d === 0), t((d & -8192) === 0)
            }, ie.prototype.stub = function(s) {
                for (var f = new Array(s), h = 0; h < s; h++) f[h] = 0;
                return f
            }, ie.prototype.mulp = function(s, f, h) {
                var p = 2 * this.guessLen13b(s.length, f.length),
                    d = this.makeRBT(p),
                    c = this.stub(p),
                    x = new Array(p),
                    v = new Array(p),
                    u = new Array(p),
                    _ = new Array(p),
                    F = new Array(p),
                    S = new Array(p),
                    z = h.words;
                z.length = p, this.convert13b(s.words, s.length, x, p), this.convert13b(f.words, f.length, _, p), this.transform(x, c, v, u, p, d), this.transform(_, c, F, S, p, d);
                for (var C = 0; C < p; C++) {
                    var D = v[C] * F[C] - u[C] * S[C];
                    u[C] = v[C] * S[C] + u[C] * F[C], v[C] = D
                }
                return this.conjugate(v, u, p), this.transform(v, u, z, c, p, d), this.conjugate(z, c, p), this.normalize13b(z, p), h.negative = s.negative ^ f.negative, h.length = s.length + f.length, h._strip()
            }, i.prototype.mul = function(s) {
                var f = new i(null);
                return f.words = new Array(this.length + s.length), this.mulTo(s, f)
            }, i.prototype.mulf = function(s) {
                var f = new i(null);
                return f.words = new Array(this.length + s.length), xe(this, s, f)
            }, i.prototype.imul = function(s) {
                return this.clone().mulTo(s, this)
            }, i.prototype.imuln = function(s) {
                var f = s < 0;
                f && (s = -s), t(typeof s == "number"), t(s < 67108864);
                for (var h = 0, p = 0; p < this.length; p++) {
                    var d = (this.words[p] | 0) * s,
                        c = (d & 67108863) + (h & 67108863);
                    h >>= 26, h += d / 67108864 | 0, h += c >>> 26, this.words[p] = c & 67108863
                }
                return h !== 0 && (this.words[p] = h, this.length++), f ? this.ineg() : this
            }, i.prototype.muln = function(s) {
                return this.clone().imuln(s)
            }, i.prototype.sqr = function() {
                return this.mul(this)
            }, i.prototype.isqr = function() {
                return this.imul(this.clone())
            }, i.prototype.pow = function(s) {
                var f = Z(s);
                if (f.length === 0) return new i(1);
                for (var h = this, p = 0; p < f.length && f[p] === 0; p++, h = h.sqr());
                if (++p < f.length)
                    for (var d = h.sqr(); p < f.length; p++, d = d.sqr()) f[p] !== 0 && (h = h.mul(d));
                return h
            }, i.prototype.iushln = function(s) {
                t(typeof s == "number" && s >= 0);
                var f = s % 26,
                    h = (s - f) / 26,
                    p = 67108863 >>> 26 - f << 26 - f,
                    d;
                if (f !== 0) {
                    var c = 0;
                    for (d = 0; d < this.length; d++) {
                        var x = this.words[d] & p,
                            v = (this.words[d] | 0) - x << f;
                        this.words[d] = v | c, c = x >>> 26 - f
                    }
                    c && (this.words[d] = c, this.length++)
                }
                if (h !== 0) {
                    for (d = this.length - 1; d >= 0; d--) this.words[d + h] = this.words[d];
                    for (d = 0; d < h; d++) this.words[d] = 0;
                    this.length += h
                }
                return this._strip()
            }, i.prototype.ishln = function(s) {
                return t(this.negative === 0), this.iushln(s)
            }, i.prototype.iushrn = function(s, f, h) {
                t(typeof s == "number" && s >= 0);
                var p;
                f ? p = (f - f % 26) / 26 : p = 0;
                var d = s % 26,
                    c = Math.min((s - d) / 26, this.length),
                    x = 67108863 ^ 67108863 >>> d << d,
                    v = h;
                if (p -= c, p = Math.max(0, p), v) {
                    for (var u = 0; u < c; u++) v.words[u] = this.words[u];
                    v.length = c
                }
                if (c !== 0)
                    if (this.length > c)
                        for (this.length -= c, u = 0; u < this.length; u++) this.words[u] = this.words[u + c];
                    else this.words[0] = 0, this.length = 1;
                var _ = 0;
                for (u = this.length - 1; u >= 0 && (_ !== 0 || u >= p); u--) {
                    var F = this.words[u] | 0;
                    this.words[u] = _ << 26 - d | F >>> d, _ = F & x
                }
                return v && _ !== 0 && (v.words[v.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
            }, i.prototype.ishrn = function(s, f, h) {
                return t(this.negative === 0), this.iushrn(s, f, h)
            }, i.prototype.shln = function(s) {
                return this.clone().ishln(s)
            }, i.prototype.ushln = function(s) {
                return this.clone().iushln(s)
            }, i.prototype.shrn = function(s) {
                return this.clone().ishrn(s)
            }, i.prototype.ushrn = function(s) {
                return this.clone().iushrn(s)
            }, i.prototype.testn = function(s) {
                t(typeof s == "number" && s >= 0);
                var f = s % 26,
                    h = (s - f) / 26,
                    p = 1 << f;
                if (this.length <= h) return !1;
                var d = this.words[h];
                return !!(d & p)
            }, i.prototype.imaskn = function(s) {
                t(typeof s == "number" && s >= 0);
                var f = s % 26,
                    h = (s - f) / 26;
                if (t(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h) return this;
                if (f !== 0 && h++, this.length = Math.min(h, this.length), f !== 0) {
                    var p = 67108863 ^ 67108863 >>> f << f;
                    this.words[this.length - 1] &= p
                }
                return this._strip()
            }, i.prototype.maskn = function(s) {
                return this.clone().imaskn(s)
            }, i.prototype.iaddn = function(s) {
                return t(typeof s == "number"), t(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s)
            }, i.prototype._iaddn = function(s) {
                this.words[0] += s;
                for (var f = 0; f < this.length && this.words[f] >= 67108864; f++) this.words[f] -= 67108864, f === this.length - 1 ? this.words[f + 1] = 1 : this.words[f + 1]++;
                return this.length = Math.max(this.length, f + 1), this
            }, i.prototype.isubn = function(s) {
                if (t(typeof s == "number"), t(s < 67108864), s < 0) return this.iaddn(-s);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(s), this.negative = 1, this;
                if (this.words[0] -= s, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else
                    for (var f = 0; f < this.length && this.words[f] < 0; f++) this.words[f] += 67108864, this.words[f + 1] -= 1;
                return this._strip()
            }, i.prototype.addn = function(s) {
                return this.clone().iaddn(s)
            }, i.prototype.subn = function(s) {
                return this.clone().isubn(s)
            }, i.prototype.iabs = function() {
                return this.negative = 0, this
            }, i.prototype.abs = function() {
                return this.clone().iabs()
            }, i.prototype._ishlnsubmul = function(s, f, h) {
                var p = s.length + h,
                    d;
                this._expand(p);
                var c, x = 0;
                for (d = 0; d < s.length; d++) {
                    c = (this.words[d + h] | 0) + x;
                    var v = (s.words[d] | 0) * f;
                    c -= v & 67108863, x = (c >> 26) - (v / 67108864 | 0), this.words[d + h] = c & 67108863
                }
                for (; d < this.length - h; d++) c = (this.words[d + h] | 0) + x, x = c >> 26, this.words[d + h] = c & 67108863;
                if (x === 0) return this._strip();
                for (t(x === -1), x = 0, d = 0; d < this.length; d++) c = -(this.words[d] | 0) + x, x = c >> 26, this.words[d] = c & 67108863;
                return this.negative = 1, this._strip()
            }, i.prototype._wordDiv = function(s, f) {
                var h = this.length - s.length,
                    p = this.clone(),
                    d = s,
                    c = d.words[d.length - 1] | 0,
                    x = this._countBits(c);
                h = 26 - x, h !== 0 && (d = d.ushln(h), p.iushln(h), c = d.words[d.length - 1] | 0);
                var v = p.length - d.length,
                    u;
                if (f !== "mod") {
                    u = new i(null), u.length = v + 1, u.words = new Array(u.length);
                    for (var _ = 0; _ < u.length; _++) u.words[_] = 0
                }
                var F = p.clone()._ishlnsubmul(d, 1, v);
                F.negative === 0 && (p = F, u && (u.words[v] = 1));
                for (var S = v - 1; S >= 0; S--) {
                    var z = (p.words[d.length + S] | 0) * 67108864 + (p.words[d.length + S - 1] | 0);
                    for (z = Math.min(z / c | 0, 67108863), p._ishlnsubmul(d, z, S); p.negative !== 0;) z--, p.negative = 0, p._ishlnsubmul(d, 1, S), p.isZero() || (p.negative ^= 1);
                    u && (u.words[S] = z)
                }
                return u && u._strip(), p._strip(), f !== "div" && h !== 0 && p.iushrn(h), {
                    div: u || null,
                    mod: p
                }
            }, i.prototype.divmod = function(s, f, h) {
                if (t(!s.isZero()), this.isZero()) return {
                    div: new i(0),
                    mod: new i(0)
                };
                var p, d, c;
                return this.negative !== 0 && s.negative === 0 ? (c = this.neg().divmod(s, f), f !== "mod" && (p = c.div.neg()), f !== "div" && (d = c.mod.neg(), h && d.negative !== 0 && d.iadd(s)), {
                    div: p,
                    mod: d
                }) : this.negative === 0 && s.negative !== 0 ? (c = this.divmod(s.neg(), f), f !== "mod" && (p = c.div.neg()), {
                    div: p,
                    mod: c.mod
                }) : (this.negative & s.negative) !== 0 ? (c = this.neg().divmod(s.neg(), f), f !== "div" && (d = c.mod.neg(), h && d.negative !== 0 && d.isub(s)), {
                    div: c.div,
                    mod: d
                }) : s.length > this.length || this.cmp(s) < 0 ? {
                    div: new i(0),
                    mod: this
                } : s.length === 1 ? f === "div" ? {
                    div: this.divn(s.words[0]),
                    mod: null
                } : f === "mod" ? {
                    div: null,
                    mod: new i(this.modrn(s.words[0]))
                } : {
                    div: this.divn(s.words[0]),
                    mod: new i(this.modrn(s.words[0]))
                } : this._wordDiv(s, f)
            }, i.prototype.div = function(s) {
                return this.divmod(s, "div", !1).div
            }, i.prototype.mod = function(s) {
                return this.divmod(s, "mod", !1).mod
            }, i.prototype.umod = function(s) {
                return this.divmod(s, "mod", !0).mod
            }, i.prototype.divRound = function(s) {
                var f = this.divmod(s);
                if (f.mod.isZero()) return f.div;
                var h = f.div.negative !== 0 ? f.mod.isub(s) : f.mod,
                    p = s.ushrn(1),
                    d = s.andln(1),
                    c = h.cmp(p);
                return c < 0 || d === 1 && c === 0 ? f.div : f.div.negative !== 0 ? f.div.isubn(1) : f.div.iaddn(1)
            }, i.prototype.modrn = function(s) {
                var f = s < 0;
                f && (s = -s), t(s <= 67108863);
                for (var h = (1 << 26) % s, p = 0, d = this.length - 1; d >= 0; d--) p = (h * p + (this.words[d] | 0)) % s;
                return f ? -p : p
            }, i.prototype.modn = function(s) {
                return this.modrn(s)
            }, i.prototype.idivn = function(s) {
                var f = s < 0;
                f && (s = -s), t(s <= 67108863);
                for (var h = 0, p = this.length - 1; p >= 0; p--) {
                    var d = (this.words[p] | 0) + h * 67108864;
                    this.words[p] = d / s | 0, h = d % s
                }
                return this._strip(), f ? this.ineg() : this
            }, i.prototype.divn = function(s) {
                return this.clone().idivn(s)
            }, i.prototype.egcd = function(s) {
                t(s.negative === 0), t(!s.isZero());
                var f = this,
                    h = s.clone();
                f.negative !== 0 ? f = f.umod(s) : f = f.clone();
                for (var p = new i(1), d = new i(0), c = new i(0), x = new i(1), v = 0; f.isEven() && h.isEven();) f.iushrn(1), h.iushrn(1), ++v;
                for (var u = h.clone(), _ = f.clone(); !f.isZero();) {
                    for (var F = 0, S = 1;
                        (f.words[0] & S) === 0 && F < 26; ++F, S <<= 1);
                    if (F > 0)
                        for (f.iushrn(F); F-- > 0;)(p.isOdd() || d.isOdd()) && (p.iadd(u), d.isub(_)), p.iushrn(1), d.iushrn(1);
                    for (var z = 0, C = 1;
                        (h.words[0] & C) === 0 && z < 26; ++z, C <<= 1);
                    if (z > 0)
                        for (h.iushrn(z); z-- > 0;)(c.isOdd() || x.isOdd()) && (c.iadd(u), x.isub(_)), c.iushrn(1), x.iushrn(1);
                    f.cmp(h) >= 0 ? (f.isub(h), p.isub(c), d.isub(x)) : (h.isub(f), c.isub(p), x.isub(d))
                }
                return {
                    a: c,
                    b: x,
                    gcd: h.iushln(v)
                }
            }, i.prototype._invmp = function(s) {
                t(s.negative === 0), t(!s.isZero());
                var f = this,
                    h = s.clone();
                f.negative !== 0 ? f = f.umod(s) : f = f.clone();
                for (var p = new i(1), d = new i(0), c = h.clone(); f.cmpn(1) > 0 && h.cmpn(1) > 0;) {
                    for (var x = 0, v = 1;
                        (f.words[0] & v) === 0 && x < 26; ++x, v <<= 1);
                    if (x > 0)
                        for (f.iushrn(x); x-- > 0;) p.isOdd() && p.iadd(c), p.iushrn(1);
                    for (var u = 0, _ = 1;
                        (h.words[0] & _) === 0 && u < 26; ++u, _ <<= 1);
                    if (u > 0)
                        for (h.iushrn(u); u-- > 0;) d.isOdd() && d.iadd(c), d.iushrn(1);
                    f.cmp(h) >= 0 ? (f.isub(h), p.isub(d)) : (h.isub(f), d.isub(p))
                }
                var F;
                return f.cmpn(1) === 0 ? F = p : F = d, F.cmpn(0) < 0 && F.iadd(s), F
            }, i.prototype.gcd = function(s) {
                if (this.isZero()) return s.abs();
                if (s.isZero()) return this.abs();
                var f = this.clone(),
                    h = s.clone();
                f.negative = 0, h.negative = 0;
                for (var p = 0; f.isEven() && h.isEven(); p++) f.iushrn(1), h.iushrn(1);
                do {
                    for (; f.isEven();) f.iushrn(1);
                    for (; h.isEven();) h.iushrn(1);
                    var d = f.cmp(h);
                    if (d < 0) {
                        var c = f;
                        f = h, h = c
                    } else if (d === 0 || h.cmpn(1) === 0) break;
                    f.isub(h)
                } while (!0);
                return h.iushln(p)
            }, i.prototype.invm = function(s) {
                return this.egcd(s).a.umod(s)
            }, i.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }, i.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }, i.prototype.andln = function(s) {
                return this.words[0] & s
            }, i.prototype.bincn = function(s) {
                t(typeof s == "number");
                var f = s % 26,
                    h = (s - f) / 26,
                    p = 1 << f;
                if (this.length <= h) return this._expand(h + 1), this.words[h] |= p, this;
                for (var d = p, c = h; d !== 0 && c < this.length; c++) {
                    var x = this.words[c] | 0;
                    x += d, d = x >>> 26, x &= 67108863, this.words[c] = x
                }
                return d !== 0 && (this.words[c] = d, this.length++), this
            }, i.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }, i.prototype.cmpn = function(s) {
                var f = s < 0;
                if (this.negative !== 0 && !f) return -1;
                if (this.negative === 0 && f) return 1;
                this._strip();
                var h;
                if (this.length > 1) h = 1;
                else {
                    f && (s = -s), t(s <= 67108863, "Number is too big");
                    var p = this.words[0] | 0;
                    h = p === s ? 0 : p < s ? -1 : 1
                }
                return this.negative !== 0 ? -h | 0 : h
            }, i.prototype.cmp = function(s) {
                if (this.negative !== 0 && s.negative === 0) return -1;
                if (this.negative === 0 && s.negative !== 0) return 1;
                var f = this.ucmp(s);
                return this.negative !== 0 ? -f | 0 : f
            }, i.prototype.ucmp = function(s) {
                if (this.length > s.length) return 1;
                if (this.length < s.length) return -1;
                for (var f = 0, h = this.length - 1; h >= 0; h--) {
                    var p = this.words[h] | 0,
                        d = s.words[h] | 0;
                    if (p !== d) {
                        p < d ? f = -1 : p > d && (f = 1);
                        break
                    }
                }
                return f
            }, i.prototype.gtn = function(s) {
                return this.cmpn(s) === 1
            }, i.prototype.gt = function(s) {
                return this.cmp(s) === 1
            }, i.prototype.gten = function(s) {
                return this.cmpn(s) >= 0
            }, i.prototype.gte = function(s) {
                return this.cmp(s) >= 0
            }, i.prototype.ltn = function(s) {
                return this.cmpn(s) === -1
            }, i.prototype.lt = function(s) {
                return this.cmp(s) === -1
            }, i.prototype.lten = function(s) {
                return this.cmpn(s) <= 0
            }, i.prototype.lte = function(s) {
                return this.cmp(s) <= 0
            }, i.prototype.eqn = function(s) {
                return this.cmpn(s) === 0
            }, i.prototype.eq = function(s) {
                return this.cmp(s) === 0
            }, i.red = function(s) {
                return new m(s)
            }, i.prototype.toRed = function(s) {
                return t(!this.red, "Already a number in reduction context"), t(this.negative === 0, "red works only with positives"), s.convertTo(this)._forceRed(s)
            }, i.prototype.fromRed = function() {
                return t(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }, i.prototype._forceRed = function(s) {
                return this.red = s, this
            }, i.prototype.forceRed = function(s) {
                return t(!this.red, "Already a number in reduction context"), this._forceRed(s)
            }, i.prototype.redAdd = function(s) {
                return t(this.red, "redAdd works only with red numbers"), this.red.add(this, s)
            }, i.prototype.redIAdd = function(s) {
                return t(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s)
            }, i.prototype.redSub = function(s) {
                return t(this.red, "redSub works only with red numbers"), this.red.sub(this, s)
            }, i.prototype.redISub = function(s) {
                return t(this.red, "redISub works only with red numbers"), this.red.isub(this, s)
            }, i.prototype.redShl = function(s) {
                return t(this.red, "redShl works only with red numbers"), this.red.shl(this, s)
            }, i.prototype.redMul = function(s) {
                return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.mul(this, s)
            }, i.prototype.redIMul = function(s) {
                return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.imul(this, s)
            }, i.prototype.redSqr = function() {
                return t(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }, i.prototype.redISqr = function() {
                return t(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }, i.prototype.redSqrt = function() {
                return t(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }, i.prototype.redInvm = function() {
                return t(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }, i.prototype.redNeg = function() {
                return t(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }, i.prototype.redPow = function(s) {
                return t(this.red && !s.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s)
            };
            var ae = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };

            function be(l, s) {
                this.name = l, this.p = new i(s, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
            }
            be.prototype._tmp = function() {
                var s = new i(null);
                return s.words = new Array(Math.ceil(this.n / 13)), s
            }, be.prototype.ireduce = function(s) {
                var f = s,
                    h;
                do this.split(f, this.tmp), f = this.imulK(f), f = f.iadd(this.tmp), h = f.bitLength(); while (h > this.n);
                var p = h < this.n ? -1 : f.ucmp(this.p);
                return p === 0 ? (f.words[0] = 0, f.length = 1) : p > 0 ? f.isub(this.p) : f.strip !== void 0 ? f.strip() : f._strip(), f
            }, be.prototype.split = function(s, f) {
                s.iushrn(this.n, 0, f)
            }, be.prototype.imulK = function(s) {
                return s.imul(this.k)
            };

            function we() {
                be.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            n(we, be), we.prototype.split = function(s, f) {
                for (var h = 4194303, p = Math.min(s.length, 9), d = 0; d < p; d++) f.words[d] = s.words[d];
                if (f.length = p, s.length <= 9) {
                    s.words[0] = 0, s.length = 1;
                    return
                }
                var c = s.words[9];
                for (f.words[f.length++] = c & h, d = 10; d < s.length; d++) {
                    var x = s.words[d] | 0;
                    s.words[d - 10] = (x & h) << 4 | c >>> 22, c = x
                }
                c >>>= 22, s.words[d - 10] = c, c === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9
            }, we.prototype.imulK = function(s) {
                s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;
                for (var f = 0, h = 0; h < s.length; h++) {
                    var p = s.words[h] | 0;
                    f += p * 977, s.words[h] = f & 67108863, f = p * 64 + (f / 67108864 | 0)
                }
                return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s
            };

            function he() {
                be.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            n(he, be);

            function gt() {
                be.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            n(gt, be);

            function T() {
                be.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            n(T, be), T.prototype.imulK = function(s) {
                for (var f = 0, h = 0; h < s.length; h++) {
                    var p = (s.words[h] | 0) * 19 + f,
                        d = p & 67108863;
                    p >>>= 26, s.words[h] = d, f = p
                }
                return f !== 0 && (s.words[s.length++] = f), s
            }, i._prime = function(s) {
                if (ae[s]) return ae[s];
                var f;
                if (s === "k256") f = new we;
                else if (s === "p224") f = new he;
                else if (s === "p192") f = new gt;
                else if (s === "p25519") f = new T;
                else throw new Error("Unknown prime " + s);
                return ae[s] = f, f
            };

            function m(l) {
                if (typeof l == "string") {
                    var s = i._prime(l);
                    this.m = s.p, this.prime = s
                } else t(l.gtn(1), "modulus must be greater than 1"), this.m = l, this.prime = null
            }
            m.prototype._verify1 = function(s) {
                t(s.negative === 0, "red works only with positives"), t(s.red, "red works only with red numbers")
            }, m.prototype._verify2 = function(s, f) {
                t((s.negative | f.negative) === 0, "red works only with positives"), t(s.red && s.red === f.red, "red works only with red numbers")
            }, m.prototype.imod = function(s) {
                return this.prime ? this.prime.ireduce(s)._forceRed(this) : (E(s, s.umod(this.m)._forceRed(this)), s)
            }, m.prototype.neg = function(s) {
                return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this)
            }, m.prototype.add = function(s, f) {
                this._verify2(s, f);
                var h = s.add(f);
                return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this)
            }, m.prototype.iadd = function(s, f) {
                this._verify2(s, f);
                var h = s.iadd(f);
                return h.cmp(this.m) >= 0 && h.isub(this.m), h
            }, m.prototype.sub = function(s, f) {
                this._verify2(s, f);
                var h = s.sub(f);
                return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this)
            }, m.prototype.isub = function(s, f) {
                this._verify2(s, f);
                var h = s.isub(f);
                return h.cmpn(0) < 0 && h.iadd(this.m), h
            }, m.prototype.shl = function(s, f) {
                return this._verify1(s), this.imod(s.ushln(f))
            }, m.prototype.imul = function(s, f) {
                return this._verify2(s, f), this.imod(s.imul(f))
            }, m.prototype.mul = function(s, f) {
                return this._verify2(s, f), this.imod(s.mul(f))
            }, m.prototype.isqr = function(s) {
                return this.imul(s, s.clone())
            }, m.prototype.sqr = function(s) {
                return this.mul(s, s)
            }, m.prototype.sqrt = function(s) {
                if (s.isZero()) return s.clone();
                var f = this.m.andln(3);
                if (t(f % 2 === 1), f === 3) {
                    var h = this.m.add(new i(1)).iushrn(2);
                    return this.pow(s, h)
                }
                for (var p = this.m.subn(1), d = 0; !p.isZero() && p.andln(1) === 0;) d++, p.iushrn(1);
                t(!p.isZero());
                var c = new i(1).toRed(this),
                    x = c.redNeg(),
                    v = this.m.subn(1).iushrn(1),
                    u = this.m.bitLength();
                for (u = new i(2 * u * u).toRed(this); this.pow(u, v).cmp(x) !== 0;) u.redIAdd(x);
                for (var _ = this.pow(u, p), F = this.pow(s, p.addn(1).iushrn(1)), S = this.pow(s, p), z = d; S.cmp(c) !== 0;) {
                    for (var C = S, D = 0; C.cmp(c) !== 0; D++) C = C.redSqr();
                    t(D < z);
                    var Y = this.pow(_, new i(1).iushln(z - D - 1));
                    F = F.redMul(Y), _ = Y.redSqr(), S = S.redMul(_), z = D
                }
                return F
            }, m.prototype.invm = function(s) {
                var f = s._invmp(this.m);
                return f.negative !== 0 ? (f.negative = 0, this.imod(f).redNeg()) : this.imod(f)
            }, m.prototype.pow = function(s, f) {
                if (f.isZero()) return new i(1).toRed(this);
                if (f.cmpn(1) === 0) return s.clone();
                var h = 4,
                    p = new Array(1 << h);
                p[0] = new i(1).toRed(this), p[1] = s;
                for (var d = 2; d < p.length; d++) p[d] = this.mul(p[d - 1], s);
                var c = p[0],
                    x = 0,
                    v = 0,
                    u = f.bitLength() % 26;
                for (u === 0 && (u = 26), d = f.length - 1; d >= 0; d--) {
                    for (var _ = f.words[d], F = u - 1; F >= 0; F--) {
                        var S = _ >> F & 1;
                        if (c !== p[0] && (c = this.sqr(c)), S === 0 && x === 0) {
                            v = 0;
                            continue
                        }
                        x <<= 1, x |= S, v++, !(v !== h && (d !== 0 || F !== 0)) && (c = this.mul(c, p[x]), v = 0, x = 0)
                    }
                    u = 26
                }
                return c
            }, m.prototype.convertTo = function(s) {
                var f = s.umod(this.m);
                return f === s ? f.clone() : f
            }, m.prototype.convertFrom = function(s) {
                var f = s.clone();
                return f.red = null, f
            }, i.mont = function(s) {
                return new w(s)
            };

            function w(l) {
                m.call(this, l), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
            }
            n(w, m), w.prototype.convertTo = function(s) {
                return this.imod(s.ushln(this.shift))
            }, w.prototype.convertFrom = function(s) {
                var f = this.imod(s.mul(this.rinv));
                return f.red = null, f
            }, w.prototype.imul = function(s, f) {
                if (s.isZero() || f.isZero()) return s.words[0] = 0, s.length = 1, s;
                var h = s.imul(f),
                    p = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    d = h.isub(p).iushrn(this.shift),
                    c = d;
                return d.cmp(this.m) >= 0 ? c = d.isub(this.m) : d.cmpn(0) < 0 && (c = d.iadd(this.m)), c._forceRed(this)
            }, w.prototype.mul = function(s, f) {
                if (s.isZero() || f.isZero()) return new i(0)._forceRed(this);
                var h = s.mul(f),
                    p = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    d = h.isub(p).iushrn(this.shift),
                    c = d;
                return d.cmp(this.m) >= 0 ? c = d.isub(this.m) : d.cmpn(0) < 0 && (c = d.iadd(this.m)), c._forceRed(this)
            }, w.prototype.invm = function(s) {
                var f = this.imod(s._invmp(this.m).mul(this.r2));
                return f._forceRed(this)
            }
        })(typeof bh > "u" || bh, Ed)
    });
    var vh = Ue((LA, uf) => {
        (function() {
            "use strict";
            var r = "input is invalid type",
                e = "finalize already called",
                t = typeof window == "object",
                n = t ? window : {};
            n.JS_SHA3_NO_WINDOW && (t = !1);
            var i = !t && typeof self == "object",
                o = !n.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
            o ? n = global : i && (n = self);
            var a = !n.JS_SHA3_NO_COMMON_JS && typeof uf == "object" && uf.exports,
                y = typeof define == "function" && define.amd,
                g = !n.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u",
                E = "0123456789abcdef".split(""),
                A = [31, 7936, 2031616, 520093696],
                I = [4, 1024, 262144, 67108864],
                q = [1, 256, 65536, 16777216],
                L = [6, 1536, 393216, 100663296],
                O = [0, 8, 16, 24],
                Z = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
                ge = [224, 256, 384, 512],
                ce = [128, 256],
                Xe = ["hex", "buffer", "arrayBuffer", "array", "digest"],
                xe = {
                    128: 168,
                    256: 136
                };
            (n.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(S) {
                return Object.prototype.toString.call(S) === "[object Array]"
            }), g && (n.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(S) {
                return typeof S == "object" && S.buffer && S.buffer.constructor === ArrayBuffer
            });
            for (var ie = function(S, z, C) {
                    return function(D) {
                        return new u(S, z, S).update(D)[C]()
                    }
                }, ae = function(S, z, C) {
                    return function(D, Y) {
                        return new u(S, z, Y).update(D)[C]()
                    }
                }, be = function(S, z, C) {
                    return function(D, Y, Re, ee) {
                        return s["cshake" + S].update(D, Y, Re, ee)[C]()
                    }
                }, we = function(S, z, C) {
                    return function(D, Y, Re, ee) {
                        return s["kmac" + S].update(D, Y, Re, ee)[C]()
                    }
                }, he = function(S, z, C, D) {
                    for (var Y = 0; Y < Xe.length; ++Y) {
                        var Re = Xe[Y];
                        S[Re] = z(C, D, Re)
                    }
                    return S
                }, gt = function(S, z) {
                    var C = ie(S, z, "hex");
                    return C.create = function() {
                        return new u(S, z, S)
                    }, C.update = function(D) {
                        return C.create().update(D)
                    }, he(C, ie, S, z)
                }, T = function(S, z) {
                    var C = ae(S, z, "hex");
                    return C.create = function(D) {
                        return new u(S, z, D)
                    }, C.update = function(D, Y) {
                        return C.create(Y).update(D)
                    }, he(C, ae, S, z)
                }, m = function(S, z) {
                    var C = xe[S],
                        D = be(S, z, "hex");
                    return D.create = function(Y, Re, ee) {
                        return !Re && !ee ? s["shake" + S].create(Y) : new u(S, z, Y).bytepad([Re, ee], C)
                    }, D.update = function(Y, Re, ee, re) {
                        return D.create(Re, ee, re).update(Y)
                    }, he(D, be, S, z)
                }, w = function(S, z) {
                    var C = xe[S],
                        D = we(S, z, "hex");
                    return D.create = function(Y, Re, ee) {
                        return new _(S, z, Re).bytepad(["KMAC", ee], C).bytepad([Y], C)
                    }, D.update = function(Y, Re, ee, re) {
                        return D.create(Y, ee, re).update(Re)
                    }, he(D, we, S, z)
                }, l = [{
                    name: "keccak",
                    padding: q,
                    bits: ge,
                    createMethod: gt
                }, {
                    name: "sha3",
                    padding: L,
                    bits: ge,
                    createMethod: gt
                }, {
                    name: "shake",
                    padding: A,
                    bits: ce,
                    createMethod: T
                }, {
                    name: "cshake",
                    padding: I,
                    bits: ce,
                    createMethod: m
                }, {
                    name: "kmac",
                    padding: I,
                    bits: ce,
                    createMethod: w
                }], s = {}, f = [], h = 0; h < l.length; ++h)
                for (var p = l[h], d = p.bits, c = 0; c < d.length; ++c) {
                    var x = p.name + "_" + d[c];
                    if (f.push(x), s[x] = p.createMethod(d[c], p.padding), p.name !== "sha3") {
                        var v = p.name + d[c];
                        f.push(v), s[v] = s[x]
                    }
                }

            function u(S, z, C) {
                this.blocks = [], this.s = [], this.padding = z, this.outputBits = C, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (S << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = C >> 5, this.extraBytes = (C & 31) >> 3;
                for (var D = 0; D < 50; ++D) this.s[D] = 0
            }
            u.prototype.update = function(S) {
                if (this.finalized) throw new Error(e);
                var z, C = typeof S;
                if (C !== "string") {
                    if (C === "object") {
                        if (S === null) throw new Error(r);
                        if (g && S.constructor === ArrayBuffer) S = new Uint8Array(S);
                        else if (!Array.isArray(S) && (!g || !ArrayBuffer.isView(S))) throw new Error(r)
                    } else throw new Error(r);
                    z = !0
                }
                for (var D = this.blocks, Y = this.byteCount, Re = S.length, ee = this.blockCount, re = 0, Zt = this.s, me, Ee; re < Re;) {
                    if (this.reset)
                        for (this.reset = !1, D[0] = this.block, me = 1; me < ee + 1; ++me) D[me] = 0;
                    if (z)
                        for (me = this.start; re < Re && me < Y; ++re) D[me >> 2] |= S[re] << O[me++ & 3];
                    else
                        for (me = this.start; re < Re && me < Y; ++re) Ee = S.charCodeAt(re), Ee < 128 ? D[me >> 2] |= Ee << O[me++ & 3] : Ee < 2048 ? (D[me >> 2] |= (192 | Ee >> 6) << O[me++ & 3], D[me >> 2] |= (128 | Ee & 63) << O[me++ & 3]) : Ee < 55296 || Ee >= 57344 ? (D[me >> 2] |= (224 | Ee >> 12) << O[me++ & 3], D[me >> 2] |= (128 | Ee >> 6 & 63) << O[me++ & 3], D[me >> 2] |= (128 | Ee & 63) << O[me++ & 3]) : (Ee = 65536 + ((Ee & 1023) << 10 | S.charCodeAt(++re) & 1023), D[me >> 2] |= (240 | Ee >> 18) << O[me++ & 3], D[me >> 2] |= (128 | Ee >> 12 & 63) << O[me++ & 3], D[me >> 2] |= (128 | Ee >> 6 & 63) << O[me++ & 3], D[me >> 2] |= (128 | Ee & 63) << O[me++ & 3]);
                    if (this.lastByteIndex = me, me >= Y) {
                        for (this.start = me - Y, this.block = D[ee], me = 0; me < ee; ++me) Zt[me] ^= D[me];
                        F(Zt), this.reset = !0
                    } else this.start = me
                }
                return this
            }, u.prototype.encode = function(S, z) {
                var C = S & 255,
                    D = 1,
                    Y = [C];
                for (S = S >> 8, C = S & 255; C > 0;) Y.unshift(C), S = S >> 8, C = S & 255, ++D;
                return z ? Y.push(D) : Y.unshift(D), this.update(Y), Y.length
            }, u.prototype.encodeString = function(S) {
                var z, C = typeof S;
                if (C !== "string") {
                    if (C === "object") {
                        if (S === null) throw new Error(r);
                        if (g && S.constructor === ArrayBuffer) S = new Uint8Array(S);
                        else if (!Array.isArray(S) && (!g || !ArrayBuffer.isView(S))) throw new Error(r)
                    } else throw new Error(r);
                    z = !0
                }
                var D = 0,
                    Y = S.length;
                if (z) D = Y;
                else
                    for (var Re = 0; Re < S.length; ++Re) {
                        var ee = S.charCodeAt(Re);
                        ee < 128 ? D += 1 : ee < 2048 ? D += 2 : ee < 55296 || ee >= 57344 ? D += 3 : (ee = 65536 + ((ee & 1023) << 10 | S.charCodeAt(++Re) & 1023), D += 4)
                    }
                return D += this.encode(D * 8), this.update(S), D
            }, u.prototype.bytepad = function(S, z) {
                for (var C = this.encode(z), D = 0; D < S.length; ++D) C += this.encodeString(S[D]);
                var Y = z - C % z,
                    Re = [];
                return Re.length = Y, this.update(Re), this
            }, u.prototype.finalize = function() {
                if (!this.finalized) {
                    this.finalized = !0;
                    var S = this.blocks,
                        z = this.lastByteIndex,
                        C = this.blockCount,
                        D = this.s;
                    if (S[z >> 2] |= this.padding[z & 3], this.lastByteIndex === this.byteCount)
                        for (S[0] = S[C], z = 1; z < C + 1; ++z) S[z] = 0;
                    for (S[C - 1] |= 2147483648, z = 0; z < C; ++z) D[z] ^= S[z];
                    F(D)
                }
            }, u.prototype.toString = u.prototype.hex = function() {
                this.finalize();
                for (var S = this.blockCount, z = this.s, C = this.outputBlocks, D = this.extraBytes, Y = 0, Re = 0, ee = "", re; Re < C;) {
                    for (Y = 0; Y < S && Re < C; ++Y, ++Re) re = z[Y], ee += E[re >> 4 & 15] + E[re & 15] + E[re >> 12 & 15] + E[re >> 8 & 15] + E[re >> 20 & 15] + E[re >> 16 & 15] + E[re >> 28 & 15] + E[re >> 24 & 15];
                    Re % S === 0 && (F(z), Y = 0)
                }
                return D && (re = z[Y], ee += E[re >> 4 & 15] + E[re & 15], D > 1 && (ee += E[re >> 12 & 15] + E[re >> 8 & 15]), D > 2 && (ee += E[re >> 20 & 15] + E[re >> 16 & 15])), ee
            }, u.prototype.arrayBuffer = function() {
                this.finalize();
                var S = this.blockCount,
                    z = this.s,
                    C = this.outputBlocks,
                    D = this.extraBytes,
                    Y = 0,
                    Re = 0,
                    ee = this.outputBits >> 3,
                    re;
                D ? re = new ArrayBuffer(C + 1 << 2) : re = new ArrayBuffer(ee);
                for (var Zt = new Uint32Array(re); Re < C;) {
                    for (Y = 0; Y < S && Re < C; ++Y, ++Re) Zt[Re] = z[Y];
                    Re % S === 0 && F(z)
                }
                return D && (Zt[Y] = z[Y], re = re.slice(0, ee)), re
            }, u.prototype.buffer = u.prototype.arrayBuffer, u.prototype.digest = u.prototype.array = function() {
                this.finalize();
                for (var S = this.blockCount, z = this.s, C = this.outputBlocks, D = this.extraBytes, Y = 0, Re = 0, ee = [], re, Zt; Re < C;) {
                    for (Y = 0; Y < S && Re < C; ++Y, ++Re) re = Re << 2, Zt = z[Y], ee[re] = Zt & 255, ee[re + 1] = Zt >> 8 & 255, ee[re + 2] = Zt >> 16 & 255, ee[re + 3] = Zt >> 24 & 255;
                    Re % S === 0 && F(z)
                }
                return D && (re = Re << 2, Zt = z[Y], ee[re] = Zt & 255, D > 1 && (ee[re + 1] = Zt >> 8 & 255), D > 2 && (ee[re + 2] = Zt >> 16 & 255)), ee
            };

            function _(S, z, C) {
                u.call(this, S, z, C)
            }
            _.prototype = new u, _.prototype.finalize = function() {
                return this.encode(this.outputBits, !0), u.prototype.finalize.call(this)
            };
            var F = function(S) {
                var z, C, D, Y, Re, ee, re, Zt, me, Ee, $r, Qe, Le, Ar, et, je, Ur, De, We, Ir, He, Ve, jr, it, Ge, Nr, Ke, Fe, vr, Ce, $e, _r, Oe, Ze, Wr, ot, st, dr, ze, Ne, qr, Ye, tt, nn, Be, rt, M, k, R, b, P, U, j, K, W, Pe, ne, Me, Ae, ut, ht, pt, dt;
                for (D = 0; D < 48; D += 2) Y = S[0] ^ S[10] ^ S[20] ^ S[30] ^ S[40], Re = S[1] ^ S[11] ^ S[21] ^ S[31] ^ S[41], ee = S[2] ^ S[12] ^ S[22] ^ S[32] ^ S[42], re = S[3] ^ S[13] ^ S[23] ^ S[33] ^ S[43], Zt = S[4] ^ S[14] ^ S[24] ^ S[34] ^ S[44], me = S[5] ^ S[15] ^ S[25] ^ S[35] ^ S[45], Ee = S[6] ^ S[16] ^ S[26] ^ S[36] ^ S[46], $r = S[7] ^ S[17] ^ S[27] ^ S[37] ^ S[47], Qe = S[8] ^ S[18] ^ S[28] ^ S[38] ^ S[48], Le = S[9] ^ S[19] ^ S[29] ^ S[39] ^ S[49], z = Qe ^ (ee << 1 | re >>> 31), C = Le ^ (re << 1 | ee >>> 31), S[0] ^= z, S[1] ^= C, S[10] ^= z, S[11] ^= C, S[20] ^= z, S[21] ^= C, S[30] ^= z, S[31] ^= C, S[40] ^= z, S[41] ^= C, z = Y ^ (Zt << 1 | me >>> 31), C = Re ^ (me << 1 | Zt >>> 31), S[2] ^= z, S[3] ^= C, S[12] ^= z, S[13] ^= C, S[22] ^= z, S[23] ^= C, S[32] ^= z, S[33] ^= C, S[42] ^= z, S[43] ^= C, z = ee ^ (Ee << 1 | $r >>> 31), C = re ^ ($r << 1 | Ee >>> 31), S[4] ^= z, S[5] ^= C, S[14] ^= z, S[15] ^= C, S[24] ^= z, S[25] ^= C, S[34] ^= z, S[35] ^= C, S[44] ^= z, S[45] ^= C, z = Zt ^ (Qe << 1 | Le >>> 31), C = me ^ (Le << 1 | Qe >>> 31), S[6] ^= z, S[7] ^= C, S[16] ^= z, S[17] ^= C, S[26] ^= z, S[27] ^= C, S[36] ^= z, S[37] ^= C, S[46] ^= z, S[47] ^= C, z = Ee ^ (Y << 1 | Re >>> 31), C = $r ^ (Re << 1 | Y >>> 31), S[8] ^= z, S[9] ^= C, S[18] ^= z, S[19] ^= C, S[28] ^= z, S[29] ^= C, S[38] ^= z, S[39] ^= C, S[48] ^= z, S[49] ^= C, Ar = S[0], et = S[1], rt = S[11] << 4 | S[10] >>> 28, M = S[10] << 4 | S[11] >>> 28, Fe = S[20] << 3 | S[21] >>> 29, vr = S[21] << 3 | S[20] >>> 29, ut = S[31] << 9 | S[30] >>> 23, ht = S[30] << 9 | S[31] >>> 23, Ye = S[40] << 18 | S[41] >>> 14, tt = S[41] << 18 | S[40] >>> 14, Ze = S[2] << 1 | S[3] >>> 31, Wr = S[3] << 1 | S[2] >>> 31, je = S[13] << 12 | S[12] >>> 20, Ur = S[12] << 12 | S[13] >>> 20, k = S[22] << 10 | S[23] >>> 22, R = S[23] << 10 | S[22] >>> 22, Ce = S[33] << 13 | S[32] >>> 19, $e = S[32] << 13 | S[33] >>> 19, pt = S[42] << 2 | S[43] >>> 30, dt = S[43] << 2 | S[42] >>> 30, K = S[5] << 30 | S[4] >>> 2, W = S[4] << 30 | S[5] >>> 2, ot = S[14] << 6 | S[15] >>> 26, st = S[15] << 6 | S[14] >>> 26, De = S[25] << 11 | S[24] >>> 21, We = S[24] << 11 | S[25] >>> 21, b = S[34] << 15 | S[35] >>> 17, P = S[35] << 15 | S[34] >>> 17, _r = S[45] << 29 | S[44] >>> 3, Oe = S[44] << 29 | S[45] >>> 3, it = S[6] << 28 | S[7] >>> 4, Ge = S[7] << 28 | S[6] >>> 4, Pe = S[17] << 23 | S[16] >>> 9, ne = S[16] << 23 | S[17] >>> 9, dr = S[26] << 25 | S[27] >>> 7, ze = S[27] << 25 | S[26] >>> 7, Ir = S[36] << 21 | S[37] >>> 11, He = S[37] << 21 | S[36] >>> 11, U = S[47] << 24 | S[46] >>> 8, j = S[46] << 24 | S[47] >>> 8, nn = S[8] << 27 | S[9] >>> 5, Be = S[9] << 27 | S[8] >>> 5, Nr = S[18] << 20 | S[19] >>> 12, Ke = S[19] << 20 | S[18] >>> 12, Me = S[29] << 7 | S[28] >>> 25, Ae = S[28] << 7 | S[29] >>> 25, Ne = S[38] << 8 | S[39] >>> 24, qr = S[39] << 8 | S[38] >>> 24, Ve = S[48] << 14 | S[49] >>> 18, jr = S[49] << 14 | S[48] >>> 18, S[0] = Ar ^ ~je & De, S[1] = et ^ ~Ur & We, S[10] = it ^ ~Nr & Fe, S[11] = Ge ^ ~Ke & vr, S[20] = Ze ^ ~ot & dr, S[21] = Wr ^ ~st & ze, S[30] = nn ^ ~rt & k, S[31] = Be ^ ~M & R, S[40] = K ^ ~Pe & Me, S[41] = W ^ ~ne & Ae, S[2] = je ^ ~De & Ir, S[3] = Ur ^ ~We & He, S[12] = Nr ^ ~Fe & Ce, S[13] = Ke ^ ~vr & $e, S[22] = ot ^ ~dr & Ne, S[23] = st ^ ~ze & qr, S[32] = rt ^ ~k & b, S[33] = M ^ ~R & P, S[42] = Pe ^ ~Me & ut, S[43] = ne ^ ~Ae & ht, S[4] = De ^ ~Ir & Ve, S[5] = We ^ ~He & jr, S[14] = Fe ^ ~Ce & _r, S[15] = vr ^ ~$e & Oe, S[24] = dr ^ ~Ne & Ye, S[25] = ze ^ ~qr & tt, S[34] = k ^ ~b & U, S[35] = R ^ ~P & j, S[44] = Me ^ ~ut & pt, S[45] = Ae ^ ~ht & dt, S[6] = Ir ^ ~Ve & Ar, S[7] = He ^ ~jr & et, S[16] = Ce ^ ~_r & it, S[17] = $e ^ ~Oe & Ge, S[26] = Ne ^ ~Ye & Ze, S[27] = qr ^ ~tt & Wr, S[36] = b ^ ~U & nn, S[37] = P ^ ~j & Be, S[46] = ut ^ ~pt & K, S[47] = ht ^ ~dt & W, S[8] = Ve ^ ~Ar & je, S[9] = jr ^ ~et & Ur, S[18] = _r ^ ~it & Nr, S[19] = Oe ^ ~Ge & Ke, S[28] = Ye ^ ~Ze & ot, S[29] = tt ^ ~Wr & st, S[38] = U ^ ~nn & rt, S[39] = j ^ ~Be & M, S[48] = pt ^ ~K & Pe, S[49] = dt ^ ~W & ne, S[0] ^= Z[D], S[1] ^= Z[D + 1]
            };
            if (a) uf.exports = s;
            else {
                for (h = 0; h < f.length; ++h) n[f[h]] = s[f[h]];
                y && define(function() {
                    return s
                })
            }
        })()
    });
    var ca = Ue(cf => {
        "use strict";
        cf.byteLength = S6;
        cf.toByteArray = A6;
        cf.fromByteArray = R6;
        var ri = [],
            Pn = [],
            E6 = typeof Uint8Array < "u" ? Uint8Array : Array,
            _h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (ko = 0, Ld = _h.length; ko < Ld; ++ko) ri[ko] = _h[ko], Pn[_h.charCodeAt(ko)] = ko;
        var ko, Ld;
        Pn["-".charCodeAt(0)] = 62;
        Pn["_".charCodeAt(0)] = 63;

        function zd(r) {
            var e = r.length;
            if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
            var t = r.indexOf("=");
            t === -1 && (t = e);
            var n = t === e ? 0 : 4 - t % 4;
            return [t, n]
        }

        function S6(r) {
            var e = zd(r),
                t = e[0],
                n = e[1];
            return (t + n) * 3 / 4 - n
        }

        function M6(r, e, t) {
            return (e + t) * 3 / 4 - t
        }

        function A6(r) {
            var e, t = zd(r),
                n = t[0],
                i = t[1],
                o = new E6(M6(r, n, i)),
                a = 0,
                y = i > 0 ? n - 4 : n,
                g;
            for (g = 0; g < y; g += 4) e = Pn[r.charCodeAt(g)] << 18 | Pn[r.charCodeAt(g + 1)] << 12 | Pn[r.charCodeAt(g + 2)] << 6 | Pn[r.charCodeAt(g + 3)], o[a++] = e >> 16 & 255, o[a++] = e >> 8 & 255, o[a++] = e & 255;
            return i === 2 && (e = Pn[r.charCodeAt(g)] << 2 | Pn[r.charCodeAt(g + 1)] >> 4, o[a++] = e & 255), i === 1 && (e = Pn[r.charCodeAt(g)] << 10 | Pn[r.charCodeAt(g + 1)] << 4 | Pn[r.charCodeAt(g + 2)] >> 2, o[a++] = e >> 8 & 255, o[a++] = e & 255), o
        }

        function I6(r) {
            return ri[r >> 18 & 63] + ri[r >> 12 & 63] + ri[r >> 6 & 63] + ri[r & 63]
        }

        function B6(r, e, t) {
            for (var n, i = [], o = e; o < t; o += 3) n = (r[o] << 16 & 16711680) + (r[o + 1] << 8 & 65280) + (r[o + 2] & 255), i.push(I6(n));
            return i.join("")
        }

        function R6(r) {
            for (var e, t = r.length, n = t % 3, i = [], o = 16383, a = 0, y = t - n; a < y; a += o) i.push(B6(r, a, a + o > y ? y : a + o));
            return n === 1 ? (e = r[t - 1], i.push(ri[e >> 2] + ri[e << 4 & 63] + "==")) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], i.push(ri[e >> 10] + ri[e >> 4 & 63] + ri[e << 2 & 63] + "=")), i.join("")
        }
    });
    var ha = Ue(Eh => {
        Eh.read = function(r, e, t, n, i) {
            var o, a, y = i * 8 - n - 1,
                g = (1 << y) - 1,
                E = g >> 1,
                A = -7,
                I = t ? i - 1 : 0,
                q = t ? -1 : 1,
                L = r[e + I];
            for (I += q, o = L & (1 << -A) - 1, L >>= -A, A += y; A > 0; o = o * 256 + r[e + I], I += q, A -= 8);
            for (a = o & (1 << -A) - 1, o >>= -A, A += n; A > 0; a = a * 256 + r[e + I], I += q, A -= 8);
            if (o === 0) o = 1 - E;
            else {
                if (o === g) return a ? NaN : (L ? -1 : 1) * (1 / 0);
                a = a + Math.pow(2, n), o = o - E
            }
            return (L ? -1 : 1) * a * Math.pow(2, o - n)
        };
        Eh.write = function(r, e, t, n, i, o) {
            var a, y, g, E = o * 8 - i - 1,
                A = (1 << E) - 1,
                I = A >> 1,
                q = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                L = n ? 0 : o - 1,
                O = n ? 1 : -1,
                Z = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y = isNaN(e) ? 1 : 0, a = A) : (a = Math.floor(Math.log(e) / Math.LN2), e * (g = Math.pow(2, -a)) < 1 && (a--, g *= 2), a + I >= 1 ? e += q / g : e += q * Math.pow(2, 1 - I), e * g >= 2 && (a++, g /= 2), a + I >= A ? (y = 0, a = A) : a + I >= 1 ? (y = (e * g - 1) * Math.pow(2, i), a = a + I) : (y = e * Math.pow(2, I - 1) * Math.pow(2, i), a = 0)); i >= 8; r[t + L] = y & 255, L += O, y /= 256, i -= 8);
            for (a = a << i | y, E += i; E > 0; r[t + L] = a & 255, L += O, a /= 256, E -= 8);
            r[t + L - O] |= Z * 128
        }
    });
    var ps = Ue(ds => {
        "use strict";
        var Sh = ca(),
            ls = ha(),
            Ud = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        ds.Buffer = fe;
        ds.SlowBuffer = U6;
        ds.INSPECT_MAX_BYTES = 50;
        var hf = 2147483647;
        ds.kMaxLength = hf;
        fe.TYPED_ARRAY_SUPPORT = k6();
        !fe.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

        function k6() {
            try {
                var r = new Uint8Array(1),
                    e = {
                        foo: function() {
                            return 42
                        }
                    };
                return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42
            } catch {
                return !1
            }
        }
        Object.defineProperty(fe.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (!!fe.isBuffer(this)) return this.buffer
            }
        });
        Object.defineProperty(fe.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (!!fe.isBuffer(this)) return this.byteOffset
            }
        });

        function Pi(r) {
            if (r > hf) throw new RangeError('The value "' + r + '" is invalid for option "size"');
            var e = new Uint8Array(r);
            return Object.setPrototypeOf(e, fe.prototype), e
        }

        function fe(r, e, t) {
            if (typeof r == "number") {
                if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
                return Bh(r)
            }
            return Fd(r, e, t)
        }
        fe.poolSize = 8192;

        function Fd(r, e, t) {
            if (typeof r == "string") return T6(r, e);
            if (ArrayBuffer.isView(r)) return L6(r);
            if (r == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
            if (ni(r, ArrayBuffer) || r && ni(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ni(r, SharedArrayBuffer) || r && ni(r.buffer, SharedArrayBuffer))) return Ah(r, e, t);
            if (typeof r == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
            var n = r.valueOf && r.valueOf();
            if (n != null && n !== r) return fe.from(n, e, t);
            var i = z6(r);
            if (i) return i;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function") return fe.from(r[Symbol.toPrimitive]("string"), e, t);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r)
        }
        fe.from = function(r, e, t) {
            return Fd(r, e, t)
        };
        Object.setPrototypeOf(fe.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(fe, Uint8Array);

        function Cd(r) {
            if (typeof r != "number") throw new TypeError('"size" argument must be of type number');
            if (r < 0) throw new RangeError('The value "' + r + '" is invalid for option "size"')
        }

        function P6(r, e, t) {
            return Cd(r), r <= 0 ? Pi(r) : e !== void 0 ? typeof t == "string" ? Pi(r).fill(e, t) : Pi(r).fill(e) : Pi(r)
        }
        fe.alloc = function(r, e, t) {
            return P6(r, e, t)
        };

        function Bh(r) {
            return Cd(r), Pi(r < 0 ? 0 : Rh(r) | 0)
        }
        fe.allocUnsafe = function(r) {
            return Bh(r)
        };
        fe.allocUnsafeSlow = function(r) {
            return Bh(r)
        };

        function T6(r, e) {
            if ((typeof e != "string" || e === "") && (e = "utf8"), !fe.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            var t = Od(r, e) | 0,
                n = Pi(t),
                i = n.write(r, e);
            return i !== t && (n = n.slice(0, i)), n
        }

        function Mh(r) {
            for (var e = r.length < 0 ? 0 : Rh(r.length) | 0, t = Pi(e), n = 0; n < e; n += 1) t[n] = r[n] & 255;
            return t
        }

        function L6(r) {
            if (ni(r, Uint8Array)) {
                var e = new Uint8Array(r);
                return Ah(e.buffer, e.byteOffset, e.byteLength)
            }
            return Mh(r)
        }

        function Ah(r, e, t) {
            if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
            if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
            var n;
            return e === void 0 && t === void 0 ? n = new Uint8Array(r) : t === void 0 ? n = new Uint8Array(r, e) : n = new Uint8Array(r, e, t), Object.setPrototypeOf(n, fe.prototype), n
        }

        function z6(r) {
            if (fe.isBuffer(r)) {
                var e = Rh(r.length) | 0,
                    t = Pi(e);
                return t.length === 0 || r.copy(t, 0, 0, e), t
            }
            if (r.length !== void 0) return typeof r.length != "number" || kh(r.length) ? Pi(0) : Mh(r);
            if (r.type === "Buffer" && Array.isArray(r.data)) return Mh(r.data)
        }

        function Rh(r) {
            if (r >= hf) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + hf.toString(16) + " bytes");
            return r | 0
        }

        function U6(r) {
            return +r != r && (r = 0), fe.alloc(+r)
        }
        fe.isBuffer = function(e) {
            return e != null && e._isBuffer === !0 && e !== fe.prototype
        };
        fe.compare = function(e, t) {
            if (ni(e, Uint8Array) && (e = fe.from(e, e.offset, e.byteLength)), ni(t, Uint8Array) && (t = fe.from(t, t.offset, t.byteLength)), !fe.isBuffer(e) || !fe.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (e === t) return 0;
            for (var n = e.length, i = t.length, o = 0, a = Math.min(n, i); o < a; ++o)
                if (e[o] !== t[o]) {
                    n = e[o], i = t[o];
                    break
                } return n < i ? -1 : i < n ? 1 : 0
        };
        fe.isEncoding = function(e) {
            switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
            }
        };
        fe.concat = function(e, t) {
            if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (e.length === 0) return fe.alloc(0);
            var n;
            if (t === void 0)
                for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
            var i = fe.allocUnsafe(t),
                o = 0;
            for (n = 0; n < e.length; ++n) {
                var a = e[n];
                if (ni(a, Uint8Array)) o + a.length > i.length ? fe.from(a).copy(i, o) : Uint8Array.prototype.set.call(i, a, o);
                else if (fe.isBuffer(a)) a.copy(i, o);
                else throw new TypeError('"list" argument must be an Array of Buffers');
                o += a.length
            }
            return i
        };

        function Od(r, e) {
            if (fe.isBuffer(r)) return r.length;
            if (ArrayBuffer.isView(r) || ni(r, ArrayBuffer)) return r.byteLength;
            if (typeof r != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r);
            var t = r.length,
                n = arguments.length > 2 && arguments[2] === !0;
            if (!n && t === 0) return 0;
            for (var i = !1;;) switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                    return t;
                case "utf8":
                case "utf-8":
                    return Ih(r).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return t * 2;
                case "hex":
                    return t >>> 1;
                case "base64":
                    return Hd(r).length;
                default:
                    if (i) return n ? -1 : Ih(r).length;
                    e = ("" + e).toLowerCase(), i = !0
            }
        }
        fe.byteLength = Od;

        function N6(r, e, t) {
            var n = !1;
            if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e)) return "";
            for (r || (r = "utf8");;) switch (r) {
                case "hex":
                    return H6(this, e, t);
                case "utf8":
                case "utf-8":
                    return Kd(this, e, t);
                case "ascii":
                    return j6(this, e, t);
                case "latin1":
                case "binary":
                    return W6(this, e, t);
                case "base64":
                    return K6(this, e, t);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return V6(this, e, t);
                default:
                    if (n) throw new TypeError("Unknown encoding: " + r);
                    r = (r + "").toLowerCase(), n = !0
            }
        }
        fe.prototype._isBuffer = !0;

        function Po(r, e, t) {
            var n = r[e];
            r[e] = r[t], r[t] = n
        }
        fe.prototype.swap16 = function() {
            var e = this.length;
            if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var t = 0; t < e; t += 2) Po(this, t, t + 1);
            return this
        };
        fe.prototype.swap32 = function() {
            var e = this.length;
            if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var t = 0; t < e; t += 4) Po(this, t, t + 3), Po(this, t + 1, t + 2);
            return this
        };
        fe.prototype.swap64 = function() {
            var e = this.length;
            if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var t = 0; t < e; t += 8) Po(this, t, t + 7), Po(this, t + 1, t + 6), Po(this, t + 2, t + 5), Po(this, t + 3, t + 4);
            return this
        };
        fe.prototype.toString = function() {
            var e = this.length;
            return e === 0 ? "" : arguments.length === 0 ? Kd(this, 0, e) : N6.apply(this, arguments)
        };
        fe.prototype.toLocaleString = fe.prototype.toString;
        fe.prototype.equals = function(e) {
            if (!fe.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
            return this === e ? !0 : fe.compare(this, e) === 0
        };
        fe.prototype.inspect = function() {
            var e = "",
                t = ds.INSPECT_MAX_BYTES;
            return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">"
        };
        Ud && (fe.prototype[Ud] = fe.prototype.inspect);
        fe.prototype.compare = function(e, t, n, i, o) {
            if (ni(e, Uint8Array) && (e = fe.from(e, e.offset, e.byteLength)), !fe.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
            if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), o === void 0 && (o = this.length), t < 0 || n > e.length || i < 0 || o > this.length) throw new RangeError("out of range index");
            if (i >= o && t >= n) return 0;
            if (i >= o) return -1;
            if (t >= n) return 1;
            if (t >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === e) return 0;
            for (var a = o - i, y = n - t, g = Math.min(a, y), E = this.slice(i, o), A = e.slice(t, n), I = 0; I < g; ++I)
                if (E[I] !== A[I]) {
                    a = E[I], y = A[I];
                    break
                } return a < y ? -1 : y < a ? 1 : 0
        };

        function Dd(r, e, t, n, i) {
            if (r.length === 0) return -1;
            if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, kh(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
                if (i) return -1;
                t = r.length - 1
            } else if (t < 0)
                if (i) t = 0;
                else return -1;
            if (typeof e == "string" && (e = fe.from(e, n)), fe.isBuffer(e)) return e.length === 0 ? -1 : Nd(r, e, t, n, i);
            if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : Nd(r, [e], t, n, i);
            throw new TypeError("val must be string, number or Buffer")
        }

        function Nd(r, e, t, n, i) {
            var o = 1,
                a = r.length,
                y = e.length;
            if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
                if (r.length < 2 || e.length < 2) return -1;
                o = 2, a /= 2, y /= 2, t /= 2
            }

            function g(L, O) {
                return o === 1 ? L[O] : L.readUInt16BE(O * o)
            }
            var E;
            if (i) {
                var A = -1;
                for (E = t; E < a; E++)
                    if (g(r, E) === g(e, A === -1 ? 0 : E - A)) {
                        if (A === -1 && (A = E), E - A + 1 === y) return A * o
                    } else A !== -1 && (E -= E - A), A = -1
            } else
                for (t + y > a && (t = a - y), E = t; E >= 0; E--) {
                    for (var I = !0, q = 0; q < y; q++)
                        if (g(r, E + q) !== g(e, q)) {
                            I = !1;
                            break
                        } if (I) return E
                }
            return -1
        }
        fe.prototype.includes = function(e, t, n) {
            return this.indexOf(e, t, n) !== -1
        };
        fe.prototype.indexOf = function(e, t, n) {
            return Dd(this, e, t, n, !0)
        };
        fe.prototype.lastIndexOf = function(e, t, n) {
            return Dd(this, e, t, n, !1)
        };

        function q6(r, e, t, n) {
            t = Number(t) || 0;
            var i = r.length - t;
            n ? (n = Number(n), n > i && (n = i)) : n = i;
            var o = e.length;
            n > o / 2 && (n = o / 2);
            for (var a = 0; a < n; ++a) {
                var y = parseInt(e.substr(a * 2, 2), 16);
                if (kh(y)) return a;
                r[t + a] = y
            }
            return a
        }

        function F6(r, e, t, n) {
            return lf(Ih(e, r.length - t), r, t, n)
        }

        function C6(r, e, t, n) {
            return lf(Y6(e), r, t, n)
        }

        function O6(r, e, t, n) {
            return lf(Hd(e), r, t, n)
        }

        function D6(r, e, t, n) {
            return lf(J6(e, r.length - t), r, t, n)
        }
        fe.prototype.write = function(e, t, n, i) {
            if (t === void 0) i = "utf8", n = this.length, t = 0;
            else if (n === void 0 && typeof t == "string") i = t, n = this.length, t = 0;
            else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
            else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            var o = this.length - t;
            if ((n === void 0 || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            i || (i = "utf8");
            for (var a = !1;;) switch (i) {
                case "hex":
                    return q6(this, e, t, n);
                case "utf8":
                case "utf-8":
                    return F6(this, e, t, n);
                case "ascii":
                case "latin1":
                case "binary":
                    return C6(this, e, t, n);
                case "base64":
                    return O6(this, e, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return D6(this, e, t, n);
                default:
                    if (a) throw new TypeError("Unknown encoding: " + i);
                    i = ("" + i).toLowerCase(), a = !0
            }
        };
        fe.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        };

        function K6(r, e, t) {
            return e === 0 && t === r.length ? Sh.fromByteArray(r) : Sh.fromByteArray(r.slice(e, t))
        }

        function Kd(r, e, t) {
            t = Math.min(r.length, t);
            for (var n = [], i = e; i < t;) {
                var o = r[i],
                    a = null,
                    y = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
                if (i + y <= t) {
                    var g, E, A, I;
                    switch (y) {
                        case 1:
                            o < 128 && (a = o);
                            break;
                        case 2:
                            g = r[i + 1], (g & 192) === 128 && (I = (o & 31) << 6 | g & 63, I > 127 && (a = I));
                            break;
                        case 3:
                            g = r[i + 1], E = r[i + 2], (g & 192) === 128 && (E & 192) === 128 && (I = (o & 15) << 12 | (g & 63) << 6 | E & 63, I > 2047 && (I < 55296 || I > 57343) && (a = I));
                            break;
                        case 4:
                            g = r[i + 1], E = r[i + 2], A = r[i + 3], (g & 192) === 128 && (E & 192) === 128 && (A & 192) === 128 && (I = (o & 15) << 18 | (g & 63) << 12 | (E & 63) << 6 | A & 63, I > 65535 && I < 1114112 && (a = I))
                    }
                }
                a === null ? (a = 65533, y = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), n.push(a), i += y
            }
            return $6(n)
        }
        var qd = 4096;

        function $6(r) {
            var e = r.length;
            if (e <= qd) return String.fromCharCode.apply(String, r);
            for (var t = "", n = 0; n < e;) t += String.fromCharCode.apply(String, r.slice(n, n += qd));
            return t
        }

        function j6(r, e, t) {
            var n = "";
            t = Math.min(r.length, t);
            for (var i = e; i < t; ++i) n += String.fromCharCode(r[i] & 127);
            return n
        }

        function W6(r, e, t) {
            var n = "";
            t = Math.min(r.length, t);
            for (var i = e; i < t; ++i) n += String.fromCharCode(r[i]);
            return n
        }

        function H6(r, e, t) {
            var n = r.length;
            (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
            for (var i = "", o = e; o < t; ++o) i += X6[r[o]];
            return i
        }

        function V6(r, e, t) {
            for (var n = r.slice(e, t), i = "", o = 0; o < n.length - 1; o += 2) i += String.fromCharCode(n[o] + n[o + 1] * 256);
            return i
        }
        fe.prototype.slice = function(e, t) {
            var n = this.length;
            e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
            var i = this.subarray(e, t);
            return Object.setPrototypeOf(i, fe.prototype), i
        };

        function Br(r, e, t) {
            if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
            if (r + e > t) throw new RangeError("Trying to access beyond buffer length")
        }
        fe.prototype.readUintLE = fe.prototype.readUIntLE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || Br(e, t, this.length);
            for (var i = this[e], o = 1, a = 0; ++a < t && (o *= 256);) i += this[e + a] * o;
            return i
        };
        fe.prototype.readUintBE = fe.prototype.readUIntBE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || Br(e, t, this.length);
            for (var i = this[e + --t], o = 1; t > 0 && (o *= 256);) i += this[e + --t] * o;
            return i
        };
        fe.prototype.readUint8 = fe.prototype.readUInt8 = function(e, t) {
            return e = e >>> 0, t || Br(e, 1, this.length), this[e]
        };
        fe.prototype.readUint16LE = fe.prototype.readUInt16LE = function(e, t) {
            return e = e >>> 0, t || Br(e, 2, this.length), this[e] | this[e + 1] << 8
        };
        fe.prototype.readUint16BE = fe.prototype.readUInt16BE = function(e, t) {
            return e = e >>> 0, t || Br(e, 2, this.length), this[e] << 8 | this[e + 1]
        };
        fe.prototype.readUint32LE = fe.prototype.readUInt32LE = function(e, t) {
            return e = e >>> 0, t || Br(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216
        };
        fe.prototype.readUint32BE = fe.prototype.readUInt32BE = function(e, t) {
            return e = e >>> 0, t || Br(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
        };
        fe.prototype.readIntLE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || Br(e, t, this.length);
            for (var i = this[e], o = 1, a = 0; ++a < t && (o *= 256);) i += this[e + a] * o;
            return o *= 128, i >= o && (i -= Math.pow(2, 8 * t)), i
        };
        fe.prototype.readIntBE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || Br(e, t, this.length);
            for (var i = t, o = 1, a = this[e + --i]; i > 0 && (o *= 256);) a += this[e + --i] * o;
            return o *= 128, a >= o && (a -= Math.pow(2, 8 * t)), a
        };
        fe.prototype.readInt8 = function(e, t) {
            return e = e >>> 0, t || Br(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
        };
        fe.prototype.readInt16LE = function(e, t) {
            e = e >>> 0, t || Br(e, 2, this.length);
            var n = this[e] | this[e + 1] << 8;
            return n & 32768 ? n | 4294901760 : n
        };
        fe.prototype.readInt16BE = function(e, t) {
            e = e >>> 0, t || Br(e, 2, this.length);
            var n = this[e + 1] | this[e] << 8;
            return n & 32768 ? n | 4294901760 : n
        };
        fe.prototype.readInt32LE = function(e, t) {
            return e = e >>> 0, t || Br(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
        };
        fe.prototype.readInt32BE = function(e, t) {
            return e = e >>> 0, t || Br(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
        };
        fe.prototype.readFloatLE = function(e, t) {
            return e = e >>> 0, t || Br(e, 4, this.length), ls.read(this, e, !0, 23, 4)
        };
        fe.prototype.readFloatBE = function(e, t) {
            return e = e >>> 0, t || Br(e, 4, this.length), ls.read(this, e, !1, 23, 4)
        };
        fe.prototype.readDoubleLE = function(e, t) {
            return e = e >>> 0, t || Br(e, 8, this.length), ls.read(this, e, !0, 52, 8)
        };
        fe.prototype.readDoubleBE = function(e, t) {
            return e = e >>> 0, t || Br(e, 8, this.length), ls.read(this, e, !1, 52, 8)
        };

        function hn(r, e, t, n, i, o) {
            if (!fe.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > i || e < o) throw new RangeError('"value" argument is out of bounds');
            if (t + n > r.length) throw new RangeError("Index out of range")
        }
        fe.prototype.writeUintLE = fe.prototype.writeUIntLE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
                var o = Math.pow(2, 8 * n) - 1;
                hn(this, e, t, n, o, 0)
            }
            var a = 1,
                y = 0;
            for (this[t] = e & 255; ++y < n && (a *= 256);) this[t + y] = e / a & 255;
            return t + n
        };
        fe.prototype.writeUintBE = fe.prototype.writeUIntBE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
                var o = Math.pow(2, 8 * n) - 1;
                hn(this, e, t, n, o, 0)
            }
            var a = n - 1,
                y = 1;
            for (this[t + a] = e & 255; --a >= 0 && (y *= 256);) this[t + a] = e / y & 255;
            return t + n
        };
        fe.prototype.writeUint8 = fe.prototype.writeUInt8 = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1
        };
        fe.prototype.writeUint16LE = fe.prototype.writeUInt16LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
        };
        fe.prototype.writeUint16BE = fe.prototype.writeUInt16BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
        };
        fe.prototype.writeUint32LE = fe.prototype.writeUInt32LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4
        };
        fe.prototype.writeUint32BE = fe.prototype.writeUInt32BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
        };
        fe.prototype.writeIntLE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, !i) {
                var o = Math.pow(2, 8 * n - 1);
                hn(this, e, t, n, o - 1, -o)
            }
            var a = 0,
                y = 1,
                g = 0;
            for (this[t] = e & 255; ++a < n && (y *= 256);) e < 0 && g === 0 && this[t + a - 1] !== 0 && (g = 1), this[t + a] = (e / y >> 0) - g & 255;
            return t + n
        };
        fe.prototype.writeIntBE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, !i) {
                var o = Math.pow(2, 8 * n - 1);
                hn(this, e, t, n, o - 1, -o)
            }
            var a = n - 1,
                y = 1,
                g = 0;
            for (this[t + a] = e & 255; --a >= 0 && (y *= 256);) e < 0 && g === 0 && this[t + a + 1] !== 0 && (g = 1), this[t + a] = (e / y >> 0) - g & 255;
            return t + n
        };
        fe.prototype.writeInt8 = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1
        };
        fe.prototype.writeInt16LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
        };
        fe.prototype.writeInt16BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
        };
        fe.prototype.writeInt32LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
        };
        fe.prototype.writeInt32BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || hn(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
        };

        function $d(r, e, t, n, i, o) {
            if (t + n > r.length) throw new RangeError("Index out of range");
            if (t < 0) throw new RangeError("Index out of range")
        }

        function jd(r, e, t, n, i) {
            return e = +e, t = t >>> 0, i || $d(r, e, t, 4, 34028234663852886e22, -34028234663852886e22), ls.write(r, e, t, n, 23, 4), t + 4
        }
        fe.prototype.writeFloatLE = function(e, t, n) {
            return jd(this, e, t, !0, n)
        };
        fe.prototype.writeFloatBE = function(e, t, n) {
            return jd(this, e, t, !1, n)
        };

        function Wd(r, e, t, n, i) {
            return e = +e, t = t >>> 0, i || $d(r, e, t, 8, 17976931348623157e292, -17976931348623157e292), ls.write(r, e, t, n, 52, 8), t + 8
        }
        fe.prototype.writeDoubleLE = function(e, t, n) {
            return Wd(this, e, t, !0, n)
        };
        fe.prototype.writeDoubleBE = function(e, t, n) {
            return Wd(this, e, t, !1, n)
        };
        fe.prototype.copy = function(e, t, n, i) {
            if (!fe.isBuffer(e)) throw new TypeError("argument should be a Buffer");
            if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0) return 0;
            if (t < 0) throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
            if (i < 0) throw new RangeError("sourceEnd out of bounds");
            i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
            var o = i - n;
            return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, i) : Uint8Array.prototype.set.call(e, this.subarray(n, i), t), o
        };
        fe.prototype.fill = function(e, t, n, i) {
            if (typeof e == "string") {
                if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string") throw new TypeError("encoding must be a string");
                if (typeof i == "string" && !fe.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                if (e.length === 1) {
                    var o = e.charCodeAt(0);
                    (i === "utf8" && o < 128 || i === "latin1") && (e = o)
                }
            } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
            if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
            if (n <= t) return this;
            t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
            var a;
            if (typeof e == "number")
                for (a = t; a < n; ++a) this[a] = e;
            else {
                var y = fe.isBuffer(e) ? e : fe.from(e, i),
                    g = y.length;
                if (g === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                for (a = 0; a < n - t; ++a) this[a + t] = y[a % g]
            }
            return this
        };
        var G6 = /[^+/0-9A-Za-z-_]/g;

        function Z6(r) {
            if (r = r.split("=")[0], r = r.trim().replace(G6, ""), r.length < 2) return "";
            for (; r.length % 4 !== 0;) r = r + "=";
            return r
        }

        function Ih(r, e) {
            e = e || 1 / 0;
            for (var t, n = r.length, i = null, o = [], a = 0; a < n; ++a) {
                if (t = r.charCodeAt(a), t > 55295 && t < 57344) {
                    if (!i) {
                        if (t > 56319) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        } else if (a + 1 === n) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        i = t;
                        continue
                    }
                    if (t < 56320) {
                        (e -= 3) > -1 && o.push(239, 191, 189), i = t;
                        continue
                    }
                    t = (i - 55296 << 10 | t - 56320) + 65536
                } else i && (e -= 3) > -1 && o.push(239, 191, 189);
                if (i = null, t < 128) {
                    if ((e -= 1) < 0) break;
                    o.push(t)
                } else if (t < 2048) {
                    if ((e -= 2) < 0) break;
                    o.push(t >> 6 | 192, t & 63 | 128)
                } else if (t < 65536) {
                    if ((e -= 3) < 0) break;
                    o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128)
                } else if (t < 1114112) {
                    if ((e -= 4) < 0) break;
                    o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128)
                } else throw new Error("Invalid code point")
            }
            return o
        }

        function Y6(r) {
            for (var e = [], t = 0; t < r.length; ++t) e.push(r.charCodeAt(t) & 255);
            return e
        }

        function J6(r, e) {
            for (var t, n, i, o = [], a = 0; a < r.length && !((e -= 2) < 0); ++a) t = r.charCodeAt(a), n = t >> 8, i = t % 256, o.push(i), o.push(n);
            return o
        }

        function Hd(r) {
            return Sh.toByteArray(Z6(r))
        }

        function lf(r, e, t, n) {
            for (var i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i) e[i + t] = r[i];
            return i
        }

        function ni(r, e) {
            return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name
        }

        function kh(r) {
            return r !== r
        }
        var X6 = function() {
            for (var r = "0123456789abcdef", e = new Array(256), t = 0; t < 16; ++t)
                for (var n = t * 16, i = 0; i < 16; ++i) e[n + i] = r[t] + r[i];
            return e
        }()
    });
    var Zd = Ue((Ph, Gd) => {
        var df = ps(),
            ii = df.Buffer;

        function Vd(r, e) {
            for (var t in r) e[t] = r[t]
        }
        ii.from && ii.alloc && ii.allocUnsafe && ii.allocUnsafeSlow ? Gd.exports = df : (Vd(df, Ph), Ph.Buffer = To);

        function To(r, e, t) {
            return ii(r, e, t)
        }
        To.prototype = Object.create(ii.prototype);
        Vd(ii, To);
        To.from = function(r, e, t) {
            if (typeof r == "number") throw new TypeError("Argument must not be a number");
            return ii(r, e, t)
        };
        To.alloc = function(r, e, t) {
            if (typeof r != "number") throw new TypeError("Argument must be a number");
            var n = ii(r);
            return e !== void 0 ? typeof t == "string" ? n.fill(e, t) : n.fill(e) : n.fill(0), n
        };
        To.allocUnsafe = function(r) {
            if (typeof r != "number") throw new TypeError("Argument must be a number");
            return ii(r)
        };
        To.allocUnsafeSlow = function(r) {
            if (typeof r != "number") throw new TypeError("Argument must be a number");
            return df.SlowBuffer(r)
        }
    });
    var Jd = Ue((JA, Yd) => {
        "use strict";
        var pf = Zd().Buffer;

        function Q6(r) {
            if (r.length >= 255) throw new TypeError("Alphabet too long");
            for (var e = new Uint8Array(256), t = 0; t < e.length; t++) e[t] = 255;
            for (var n = 0; n < r.length; n++) {
                var i = r.charAt(n),
                    o = i.charCodeAt(0);
                if (e[o] !== 255) throw new TypeError(i + " is ambiguous");
                e[o] = n
            }
            var a = r.length,
                y = r.charAt(0),
                g = Math.log(a) / Math.log(256),
                E = Math.log(256) / Math.log(a);

            function A(L) {
                if ((Array.isArray(L) || L instanceof Uint8Array) && (L = pf.from(L)), !pf.isBuffer(L)) throw new TypeError("Expected Buffer");
                if (L.length === 0) return "";
                for (var O = 0, Z = 0, ge = 0, ce = L.length; ge !== ce && L[ge] === 0;) ge++, O++;
                for (var Xe = (ce - ge) * E + 1 >>> 0, xe = new Uint8Array(Xe); ge !== ce;) {
                    for (var ie = L[ge], ae = 0, be = Xe - 1;
                        (ie !== 0 || ae < Z) && be !== -1; be--, ae++) ie += 256 * xe[be] >>> 0, xe[be] = ie % a >>> 0, ie = ie / a >>> 0;
                    if (ie !== 0) throw new Error("Non-zero carry");
                    Z = ae, ge++
                }
                for (var we = Xe - Z; we !== Xe && xe[we] === 0;) we++;
                for (var he = y.repeat(O); we < Xe; ++we) he += r.charAt(xe[we]);
                return he
            }

            function I(L) {
                if (typeof L != "string") throw new TypeError("Expected String");
                if (L.length === 0) return pf.alloc(0);
                for (var O = 0, Z = 0, ge = 0; L[O] === y;) Z++, O++;
                for (var ce = (L.length - O) * g + 1 >>> 0, Xe = new Uint8Array(ce); L[O];) {
                    var xe = e[L.charCodeAt(O)];
                    if (xe === 255) return;
                    for (var ie = 0, ae = ce - 1;
                        (xe !== 0 || ie < ge) && ae !== -1; ae--, ie++) xe += a * Xe[ae] >>> 0, Xe[ae] = xe % 256 >>> 0, xe = xe / 256 >>> 0;
                    if (xe !== 0) throw new Error("Non-zero carry");
                    ge = ie, O++
                }
                for (var be = ce - ge; be !== ce && Xe[be] === 0;) be++;
                var we = pf.allocUnsafe(Z + (ce - be));
                we.fill(0, 0, Z);
                for (var he = Z; be !== ce;) we[he++] = Xe[be++];
                return we
            }

            function q(L) {
                var O = I(L);
                if (O) return O;
                throw new Error("Non-base" + a + " character")
            }
            return {
                encode: A,
                decodeUnsafe: I,
                decode: q
            }
        }
        Yd.exports = Q6
    });
    var Ti = Ue((XA, Xd) => {
        var ew = Jd(),
            tw = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        Xd.exports = ew(tw)
    });
    var pa = Ue((Bk, Hh) => {
        "use strict";
        var B4 = Object.prototype.hasOwnProperty,
            an = "~";

        function da() {}
        Object.create && (da.prototype = Object.create(null), new da().__proto__ || (an = !1));

        function R4(r, e, t) {
            this.fn = r, this.context = e, this.once = t || !1
        }

        function Ig(r, e, t, n, i) {
            if (typeof t != "function") throw new TypeError("The listener must be a function");
            var o = new R4(t, n || r, i),
                a = an ? an + e : e;
            return r._events[a] ? r._events[a].fn ? r._events[a] = [r._events[a], o] : r._events[a].push(o) : (r._events[a] = o, r._eventsCount++), r
        }

        function Au(r, e) {
            --r._eventsCount === 0 ? r._events = new da : delete r._events[e]
        }

        function Zr() {
            this._events = new da, this._eventsCount = 0
        }
        Zr.prototype.eventNames = function() {
            var e = [],
                t, n;
            if (this._eventsCount === 0) return e;
            for (n in t = this._events) B4.call(t, n) && e.push(an ? n.slice(1) : n);
            return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t)) : e
        };
        Zr.prototype.listeners = function(e) {
            var t = an ? an + e : e,
                n = this._events[t];
            if (!n) return [];
            if (n.fn) return [n.fn];
            for (var i = 0, o = n.length, a = new Array(o); i < o; i++) a[i] = n[i].fn;
            return a
        };
        Zr.prototype.listenerCount = function(e) {
            var t = an ? an + e : e,
                n = this._events[t];
            return n ? n.fn ? 1 : n.length : 0
        };
        Zr.prototype.emit = function(e, t, n, i, o, a) {
            var y = an ? an + e : e;
            if (!this._events[y]) return !1;
            var g = this._events[y],
                E = arguments.length,
                A, I;
            if (g.fn) {
                switch (g.once && this.removeListener(e, g.fn, void 0, !0), E) {
                    case 1:
                        return g.fn.call(g.context), !0;
                    case 2:
                        return g.fn.call(g.context, t), !0;
                    case 3:
                        return g.fn.call(g.context, t, n), !0;
                    case 4:
                        return g.fn.call(g.context, t, n, i), !0;
                    case 5:
                        return g.fn.call(g.context, t, n, i, o), !0;
                    case 6:
                        return g.fn.call(g.context, t, n, i, o, a), !0
                }
                for (I = 1, A = new Array(E - 1); I < E; I++) A[I - 1] = arguments[I];
                g.fn.apply(g.context, A)
            } else {
                var q = g.length,
                    L;
                for (I = 0; I < q; I++) switch (g[I].once && this.removeListener(e, g[I].fn, void 0, !0), E) {
                    case 1:
                        g[I].fn.call(g[I].context);
                        break;
                    case 2:
                        g[I].fn.call(g[I].context, t);
                        break;
                    case 3:
                        g[I].fn.call(g[I].context, t, n);
                        break;
                    case 4:
                        g[I].fn.call(g[I].context, t, n, i);
                        break;
                    default:
                        if (!A)
                            for (L = 1, A = new Array(E - 1); L < E; L++) A[L - 1] = arguments[L];
                        g[I].fn.apply(g[I].context, A)
                }
            }
            return !0
        };
        Zr.prototype.on = function(e, t, n) {
            return Ig(this, e, t, n, !1)
        };
        Zr.prototype.once = function(e, t, n) {
            return Ig(this, e, t, n, !0)
        };
        Zr.prototype.removeListener = function(e, t, n, i) {
            var o = an ? an + e : e;
            if (!this._events[o]) return this;
            if (!t) return Au(this, o), this;
            var a = this._events[o];
            if (a.fn) a.fn === t && (!i || a.once) && (!n || a.context === n) && Au(this, o);
            else {
                for (var y = 0, g = [], E = a.length; y < E; y++)(a[y].fn !== t || i && !a[y].once || n && a[y].context !== n) && g.push(a[y]);
                g.length ? this._events[o] = g.length === 1 ? g[0] : g : Au(this, o)
            }
            return this
        };
        Zr.prototype.removeAllListeners = function(e) {
            var t;
            return e ? (t = an ? an + e : e, this._events[t] && Au(this, t)) : (this._events = new da, this._eventsCount = 0), this
        };
        Zr.prototype.off = Zr.prototype.removeListener;
        Zr.prototype.addListener = Zr.prototype.on;
        Zr.prefixed = an;
        Zr.EventEmitter = Zr;
        typeof Hh < "u" && (Hh.exports = Zr)
    });
    var zg = Ue((Vh, Gh) => {
        (function(r, e) {
            typeof Vh == "object" && typeof Gh < "u" ? Gh.exports = e() : typeof define == "function" && define.amd ? define(e) : (r = typeof globalThis < "u" ? globalThis : r || self).dayjs = e()
        })(Vh, function() {
            "use strict";
            var r = 1e3,
                e = 6e4,
                t = 36e5,
                n = "millisecond",
                i = "second",
                o = "minute",
                a = "hour",
                y = "day",
                g = "week",
                E = "month",
                A = "quarter",
                I = "year",
                q = "date",
                L = "Invalid Date",
                O = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
                Z = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
                ge = {
                    name: "en",
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
                },
                ce = function(m, w, l) {
                    var s = String(m);
                    return !s || s.length >= w ? m : "" + Array(w + 1 - s.length).join(l) + m
                },
                Xe = {
                    s: ce,
                    z: function(m) {
                        var w = -m.utcOffset(),
                            l = Math.abs(w),
                            s = Math.floor(l / 60),
                            f = l % 60;
                        return (w <= 0 ? "+" : "-") + ce(s, 2, "0") + ":" + ce(f, 2, "0")
                    },
                    m: function m(w, l) {
                        if (w.date() < l.date()) return -m(l, w);
                        var s = 12 * (l.year() - w.year()) + (l.month() - w.month()),
                            f = w.clone().add(s, E),
                            h = l - f < 0,
                            p = w.clone().add(s + (h ? -1 : 1), E);
                        return +(-(s + (l - f) / (h ? f - p : p - f)) || 0)
                    },
                    a: function(m) {
                        return m < 0 ? Math.ceil(m) || 0 : Math.floor(m)
                    },
                    p: function(m) {
                        return {
                            M: E,
                            y: I,
                            w: g,
                            d: y,
                            D: q,
                            h: a,
                            m: o,
                            s: i,
                            ms: n,
                            Q: A
                        } [m] || String(m || "").toLowerCase().replace(/s$/, "")
                    },
                    u: function(m) {
                        return m === void 0
                    }
                },
                xe = "en",
                ie = {};
            ie[xe] = ge;
            var ae = function(m) {
                    return m instanceof gt
                },
                be = function(m, w, l) {
                    var s;
                    if (!m) return xe;
                    if (typeof m == "string") ie[m] && (s = m), w && (ie[m] = w, s = m);
                    else {
                        var f = m.name;
                        ie[f] = m, s = f
                    }
                    return !l && s && (xe = s), s || !l && xe
                },
                we = function(m, w) {
                    if (ae(m)) return m.clone();
                    var l = typeof w == "object" ? w : {};
                    return l.date = m, l.args = arguments, new gt(l)
                },
                he = Xe;
            he.l = be, he.i = ae, he.w = function(m, w) {
                return we(m, {
                    locale: w.$L,
                    utc: w.$u,
                    x: w.$x,
                    $offset: w.$offset
                })
            };
            var gt = function() {
                    function m(l) {
                        this.$L = be(l.locale, null, !0), this.parse(l)
                    }
                    var w = m.prototype;
                    return w.parse = function(l) {
                        this.$d = function(s) {
                            var f = s.date,
                                h = s.utc;
                            if (f === null) return new Date(NaN);
                            if (he.u(f)) return new Date;
                            if (f instanceof Date) return new Date(f);
                            if (typeof f == "string" && !/Z$/i.test(f)) {
                                var p = f.match(O);
                                if (p) {
                                    var d = p[2] - 1 || 0,
                                        c = (p[7] || "0").substring(0, 3);
                                    return h ? new Date(Date.UTC(p[1], d, p[3] || 1, p[4] || 0, p[5] || 0, p[6] || 0, c)) : new Date(p[1], d, p[3] || 1, p[4] || 0, p[5] || 0, p[6] || 0, c)
                                }
                            }
                            return new Date(f)
                        }(l), this.$x = l.x || {}, this.init()
                    }, w.init = function() {
                        var l = this.$d;
                        this.$y = l.getFullYear(), this.$M = l.getMonth(), this.$D = l.getDate(), this.$W = l.getDay(), this.$H = l.getHours(), this.$m = l.getMinutes(), this.$s = l.getSeconds(), this.$ms = l.getMilliseconds()
                    }, w.$utils = function() {
                        return he
                    }, w.isValid = function() {
                        return this.$d.toString() !== L
                    }, w.isSame = function(l, s) {
                        var f = we(l);
                        return this.startOf(s) <= f && f <= this.endOf(s)
                    }, w.isAfter = function(l, s) {
                        return we(l) < this.startOf(s)
                    }, w.isBefore = function(l, s) {
                        return this.endOf(s) < we(l)
                    }, w.$g = function(l, s, f) {
                        return he.u(l) ? this[s] : this.set(f, l)
                    }, w.unix = function() {
                        return Math.floor(this.valueOf() / 1e3)
                    }, w.valueOf = function() {
                        return this.$d.getTime()
                    }, w.startOf = function(l, s) {
                        var f = this,
                            h = !!he.u(s) || s,
                            p = he.p(l),
                            d = function(z, C) {
                                var D = he.w(f.$u ? Date.UTC(f.$y, C, z) : new Date(f.$y, C, z), f);
                                return h ? D : D.endOf(y)
                            },
                            c = function(z, C) {
                                return he.w(f.toDate()[z].apply(f.toDate("s"), (h ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(C)), f)
                            },
                            x = this.$W,
                            v = this.$M,
                            u = this.$D,
                            _ = "set" + (this.$u ? "UTC" : "");
                        switch (p) {
                            case I:
                                return h ? d(1, 0) : d(31, 11);
                            case E:
                                return h ? d(1, v) : d(0, v + 1);
                            case g:
                                var F = this.$locale().weekStart || 0,
                                    S = (x < F ? x + 7 : x) - F;
                                return d(h ? u - S : u + (6 - S), v);
                            case y:
                            case q:
                                return c(_ + "Hours", 0);
                            case a:
                                return c(_ + "Minutes", 1);
                            case o:
                                return c(_ + "Seconds", 2);
                            case i:
                                return c(_ + "Milliseconds", 3);
                            default:
                                return this.clone()
                        }
                    }, w.endOf = function(l) {
                        return this.startOf(l, !1)
                    }, w.$set = function(l, s) {
                        var f, h = he.p(l),
                            p = "set" + (this.$u ? "UTC" : ""),
                            d = (f = {}, f[y] = p + "Date", f[q] = p + "Date", f[E] = p + "Month", f[I] = p + "FullYear", f[a] = p + "Hours", f[o] = p + "Minutes", f[i] = p + "Seconds", f[n] = p + "Milliseconds", f)[h],
                            c = h === y ? this.$D + (s - this.$W) : s;
                        if (h === E || h === I) {
                            var x = this.clone().set(q, 1);
                            x.$d[d](c), x.init(), this.$d = x.set(q, Math.min(this.$D, x.daysInMonth())).$d
                        } else d && this.$d[d](c);
                        return this.init(), this
                    }, w.set = function(l, s) {
                        return this.clone().$set(l, s)
                    }, w.get = function(l) {
                        return this[he.p(l)]()
                    }, w.add = function(l, s) {
                        var f, h = this;
                        l = Number(l);
                        var p = he.p(s),
                            d = function(v) {
                                var u = we(h);
                                return he.w(u.date(u.date() + Math.round(v * l)), h)
                            };
                        if (p === E) return this.set(E, this.$M + l);
                        if (p === I) return this.set(I, this.$y + l);
                        if (p === y) return d(1);
                        if (p === g) return d(7);
                        var c = (f = {}, f[o] = e, f[a] = t, f[i] = r, f)[p] || 1,
                            x = this.$d.getTime() + l * c;
                        return he.w(x, this)
                    }, w.subtract = function(l, s) {
                        return this.add(-1 * l, s)
                    }, w.format = function(l) {
                        var s = this,
                            f = this.$locale();
                        if (!this.isValid()) return f.invalidDate || L;
                        var h = l || "YYYY-MM-DDTHH:mm:ssZ",
                            p = he.z(this),
                            d = this.$H,
                            c = this.$m,
                            x = this.$M,
                            v = f.weekdays,
                            u = f.months,
                            _ = function(C, D, Y, Re) {
                                return C && (C[D] || C(s, h)) || Y[D].substr(0, Re)
                            },
                            F = function(C) {
                                return he.s(d % 12 || 12, C, "0")
                            },
                            S = f.meridiem || function(C, D, Y) {
                                var Re = C < 12 ? "AM" : "PM";
                                return Y ? Re.toLowerCase() : Re
                            },
                            z = {
                                YY: String(this.$y).slice(-2),
                                YYYY: this.$y,
                                M: x + 1,
                                MM: he.s(x + 1, 2, "0"),
                                MMM: _(f.monthsShort, x, u, 3),
                                MMMM: _(u, x),
                                D: this.$D,
                                DD: he.s(this.$D, 2, "0"),
                                d: String(this.$W),
                                dd: _(f.weekdaysMin, this.$W, v, 2),
                                ddd: _(f.weekdaysShort, this.$W, v, 3),
                                dddd: v[this.$W],
                                H: String(d),
                                HH: he.s(d, 2, "0"),
                                h: F(1),
                                hh: F(2),
                                a: S(d, c, !0),
                                A: S(d, c, !1),
                                m: String(c),
                                mm: he.s(c, 2, "0"),
                                s: String(this.$s),
                                ss: he.s(this.$s, 2, "0"),
                                SSS: he.s(this.$ms, 3, "0"),
                                Z: p
                            };
                        return h.replace(Z, function(C, D) {
                            return D || z[C] || p.replace(":", "")
                        })
                    }, w.utcOffset = function() {
                        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                    }, w.diff = function(l, s, f) {
                        var h, p = he.p(s),
                            d = we(l),
                            c = (d.utcOffset() - this.utcOffset()) * e,
                            x = this - d,
                            v = he.m(this, d);
                        return v = (h = {}, h[I] = v / 12, h[E] = v, h[A] = v / 3, h[g] = (x - c) / 6048e5, h[y] = (x - c) / 864e5, h[a] = x / t, h[o] = x / e, h[i] = x / r, h)[p] || x, f ? v : he.a(v)
                    }, w.daysInMonth = function() {
                        return this.endOf(E).$D
                    }, w.$locale = function() {
                        return ie[this.$L]
                    }, w.locale = function(l, s) {
                        if (!l) return this.$L;
                        var f = this.clone(),
                            h = be(l, s, !0);
                        return h && (f.$L = h), f
                    }, w.clone = function() {
                        return he.w(this.$d, this)
                    }, w.toDate = function() {
                        return new Date(this.valueOf())
                    }, w.toJSON = function() {
                        return this.isValid() ? this.toISOString() : null
                    }, w.toISOString = function() {
                        return this.$d.toISOString()
                    }, w.toString = function() {
                        return this.$d.toUTCString()
                    }, m
                }(),
                T = gt.prototype;
            return we.prototype = T, [
                ["$ms", n],
                ["$s", i],
                ["$m", o],
                ["$H", a],
                ["$W", y],
                ["$M", E],
                ["$y", I],
                ["$D", q]
            ].forEach(function(m) {
                T[m[1]] = function(w) {
                    return this.$g(w, m[0], m[1])
                }
            }), we.extend = function(m, w) {
                return m.$i || (m(w, gt, we), m.$i = !0), we
            }, we.locale = be, we.isDayjs = ae, we.unix = function(m) {
                return we(1e3 * m)
            }, we.en = ie[xe], we.Ls = ie, we.p = {}, we
        })
    });
    var Ug = Ue((Zh, Yh) => {
        (function(r, e) {
            typeof Zh == "object" && typeof Yh < "u" ? Yh.exports = e() : typeof define == "function" && define.amd ? define(e) : (r = typeof globalThis < "u" ? globalThis : r || self).dayjs_plugin_duration = e()
        })(Zh, function() {
            "use strict";
            var r, e, t = 1e3,
                n = 6e4,
                i = 36e5,
                o = 864e5,
                a = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
                y = 31536e6,
                g = 2592e6,
                E = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/,
                A = {
                    years: y,
                    months: g,
                    days: o,
                    hours: i,
                    minutes: n,
                    seconds: t,
                    milliseconds: 1,
                    weeks: 6048e5
                },
                I = function(xe) {
                    return xe instanceof Xe
                },
                q = function(xe, ie, ae) {
                    return new Xe(xe, ae, ie.$l)
                },
                L = function(xe) {
                    return e.p(xe) + "s"
                },
                O = function(xe) {
                    return xe < 0
                },
                Z = function(xe) {
                    return O(xe) ? Math.ceil(xe) : Math.floor(xe)
                },
                ge = function(xe) {
                    return Math.abs(xe)
                },
                ce = function(xe, ie) {
                    return xe ? O(xe) ? {
                        negative: !0,
                        format: "" + ge(xe) + ie
                    } : {
                        negative: !1,
                        format: "" + xe + ie
                    } : {
                        negative: !1,
                        format: ""
                    }
                },
                Xe = function() {
                    function xe(ae, be, we) {
                        var he = this;
                        if (this.$d = {}, this.$l = we, ae === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), be) return q(ae * A[L(be)], this);
                        if (typeof ae == "number") return this.$ms = ae, this.parseFromMilliseconds(), this;
                        if (typeof ae == "object") return Object.keys(ae).forEach(function(m) {
                            he.$d[L(m)] = ae[m]
                        }), this.calMilliseconds(), this;
                        if (typeof ae == "string") {
                            var gt = ae.match(E);
                            if (gt) {
                                var T = gt.slice(2).map(function(m) {
                                    return m != null ? Number(m) : 0
                                });
                                return this.$d.years = T[0], this.$d.months = T[1], this.$d.weeks = T[2], this.$d.days = T[3], this.$d.hours = T[4], this.$d.minutes = T[5], this.$d.seconds = T[6], this.calMilliseconds(), this
                            }
                        }
                        return this
                    }
                    var ie = xe.prototype;
                    return ie.calMilliseconds = function() {
                        var ae = this;
                        this.$ms = Object.keys(this.$d).reduce(function(be, we) {
                            return be + (ae.$d[we] || 0) * A[we]
                        }, 0)
                    }, ie.parseFromMilliseconds = function() {
                        var ae = this.$ms;
                        this.$d.years = Z(ae / y), ae %= y, this.$d.months = Z(ae / g), ae %= g, this.$d.days = Z(ae / o), ae %= o, this.$d.hours = Z(ae / i), ae %= i, this.$d.minutes = Z(ae / n), ae %= n, this.$d.seconds = Z(ae / t), ae %= t, this.$d.milliseconds = ae
                    }, ie.toISOString = function() {
                        var ae = ce(this.$d.years, "Y"),
                            be = ce(this.$d.months, "M"),
                            we = +this.$d.days || 0;
                        this.$d.weeks && (we += 7 * this.$d.weeks);
                        var he = ce(we, "D"),
                            gt = ce(this.$d.hours, "H"),
                            T = ce(this.$d.minutes, "M"),
                            m = this.$d.seconds || 0;
                        this.$d.milliseconds && (m += this.$d.milliseconds / 1e3);
                        var w = ce(m, "S"),
                            l = ae.negative || be.negative || he.negative || gt.negative || T.negative || w.negative,
                            s = gt.format || T.format || w.format ? "T" : "",
                            f = (l ? "-" : "") + "P" + ae.format + be.format + he.format + s + gt.format + T.format + w.format;
                        return f === "P" || f === "-P" ? "P0D" : f
                    }, ie.toJSON = function() {
                        return this.toISOString()
                    }, ie.format = function(ae) {
                        var be = ae || "YYYY-MM-DDTHH:mm:ss",
                            we = {
                                Y: this.$d.years,
                                YY: e.s(this.$d.years, 2, "0"),
                                YYYY: e.s(this.$d.years, 4, "0"),
                                M: this.$d.months,
                                MM: e.s(this.$d.months, 2, "0"),
                                D: this.$d.days,
                                DD: e.s(this.$d.days, 2, "0"),
                                H: this.$d.hours,
                                HH: e.s(this.$d.hours, 2, "0"),
                                m: this.$d.minutes,
                                mm: e.s(this.$d.minutes, 2, "0"),
                                s: this.$d.seconds,
                                ss: e.s(this.$d.seconds, 2, "0"),
                                SSS: e.s(this.$d.milliseconds, 3, "0")
                            };
                        return be.replace(a, function(he, gt) {
                            return gt || String(we[he])
                        })
                    }, ie.as = function(ae) {
                        return this.$ms / A[L(ae)]
                    }, ie.get = function(ae) {
                        var be = this.$ms,
                            we = L(ae);
                        return we === "milliseconds" ? be %= 1e3 : be = we === "weeks" ? Z(be / A[we]) : this.$d[we], be === 0 ? 0 : be
                    }, ie.add = function(ae, be, we) {
                        var he;
                        return he = be ? ae * A[L(be)] : I(ae) ? ae.$ms : q(ae, this).$ms, q(this.$ms + he * (we ? -1 : 1), this)
                    }, ie.subtract = function(ae, be) {
                        return this.add(ae, be, !0)
                    }, ie.locale = function(ae) {
                        var be = this.clone();
                        return be.$l = ae, be
                    }, ie.clone = function() {
                        return q(this.$ms, this)
                    }, ie.humanize = function(ae) {
                        return r().add(this.$ms, "ms").locale(this.$l).fromNow(!ae)
                    }, ie.milliseconds = function() {
                        return this.get("milliseconds")
                    }, ie.asMilliseconds = function() {
                        return this.as("milliseconds")
                    }, ie.seconds = function() {
                        return this.get("seconds")
                    }, ie.asSeconds = function() {
                        return this.as("seconds")
                    }, ie.minutes = function() {
                        return this.get("minutes")
                    }, ie.asMinutes = function() {
                        return this.as("minutes")
                    }, ie.hours = function() {
                        return this.get("hours")
                    }, ie.asHours = function() {
                        return this.as("hours")
                    }, ie.days = function() {
                        return this.get("days")
                    }, ie.asDays = function() {
                        return this.as("days")
                    }, ie.weeks = function() {
                        return this.get("weeks")
                    }, ie.asWeeks = function() {
                        return this.as("weeks")
                    }, ie.months = function() {
                        return this.get("months")
                    }, ie.asMonths = function() {
                        return this.as("months")
                    }, ie.years = function() {
                        return this.get("years")
                    }, ie.asYears = function() {
                        return this.as("years")
                    }, xe
                }();
            return function(xe, ie, ae) {
                r = ae, e = ae().$utils(), ae.duration = function(he, gt) {
                    var T = ae.locale();
                    return q(he, {
                        $l: T
                    }, gt)
                }, ae.isDuration = I;
                var be = ie.prototype.add,
                    we = ie.prototype.subtract;
                ie.prototype.add = function(he, gt) {
                    return I(he) && (he = he.asMilliseconds()), be.bind(this)(he, gt)
                }, ie.prototype.subtract = function(he, gt) {
                    return I(he) && (he = he.asMilliseconds()), we.bind(this)(he, gt)
                }
            }
        })
    });
    var Jh = Ue(() => {});
    var Xh = Ue((BT, Ru) => {
        (function(r) {
            "use strict";
            var e = function(M) {
                    var k, R = new Float64Array(16);
                    if (M)
                        for (k = 0; k < M.length; k++) R[k] = M[k];
                    return R
                },
                t = function() {
                    throw new Error("no PRNG")
                },
                n = new Uint8Array(16),
                i = new Uint8Array(32);
            i[0] = 9;
            var o = e(),
                a = e([1]),
                y = e([56129, 1]),
                g = e([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
                E = e([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
                A = e([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
                I = e([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
                q = e([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

            function L(M, k, R, b) {
                M[k] = R >> 24 & 255, M[k + 1] = R >> 16 & 255, M[k + 2] = R >> 8 & 255, M[k + 3] = R & 255, M[k + 4] = b >> 24 & 255, M[k + 5] = b >> 16 & 255, M[k + 6] = b >> 8 & 255, M[k + 7] = b & 255
            }

            function O(M, k, R, b, P) {
                var U, j = 0;
                for (U = 0; U < P; U++) j |= M[k + U] ^ R[b + U];
                return (1 & j - 1 >>> 8) - 1
            }

            function Z(M, k, R, b) {
                return O(M, k, R, b, 16)
            }

            function ge(M, k, R, b) {
                return O(M, k, R, b, 32)
            }

            function ce(M, k, R, b) {
                for (var P = b[0] & 255 | (b[1] & 255) << 8 | (b[2] & 255) << 16 | (b[3] & 255) << 24, U = R[0] & 255 | (R[1] & 255) << 8 | (R[2] & 255) << 16 | (R[3] & 255) << 24, j = R[4] & 255 | (R[5] & 255) << 8 | (R[6] & 255) << 16 | (R[7] & 255) << 24, K = R[8] & 255 | (R[9] & 255) << 8 | (R[10] & 255) << 16 | (R[11] & 255) << 24, W = R[12] & 255 | (R[13] & 255) << 8 | (R[14] & 255) << 16 | (R[15] & 255) << 24, Pe = b[4] & 255 | (b[5] & 255) << 8 | (b[6] & 255) << 16 | (b[7] & 255) << 24, ne = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, Me = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, Ae = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, ut = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, ht = b[8] & 255 | (b[9] & 255) << 8 | (b[10] & 255) << 16 | (b[11] & 255) << 24, pt = R[16] & 255 | (R[17] & 255) << 8 | (R[18] & 255) << 16 | (R[19] & 255) << 24, dt = R[20] & 255 | (R[21] & 255) << 8 | (R[22] & 255) << 16 | (R[23] & 255) << 24, yt = R[24] & 255 | (R[25] & 255) << 8 | (R[26] & 255) << 16 | (R[27] & 255) << 24, bt = R[28] & 255 | (R[29] & 255) << 8 | (R[30] & 255) << 16 | (R[31] & 255) << 24, mt = b[12] & 255 | (b[13] & 255) << 8 | (b[14] & 255) << 16 | (b[15] & 255) << 24, ke = P, at = U, Ie = j, Te = K, qe = W, Se = Pe, H = ne, V = Me, ye = Ae, oe = ut, se = ht, ve = pt, wt = dt, It = yt, Rt = bt, Bt = mt, N, Tt = 0; Tt < 20; Tt += 2) N = ke + wt | 0, qe ^= N << 7 | N >>> 32 - 7, N = qe + ke | 0, ye ^= N << 9 | N >>> 32 - 9, N = ye + qe | 0, wt ^= N << 13 | N >>> 32 - 13, N = wt + ye | 0, ke ^= N << 18 | N >>> 32 - 18, N = Se + at | 0, oe ^= N << 7 | N >>> 32 - 7, N = oe + Se | 0, It ^= N << 9 | N >>> 32 - 9, N = It + oe | 0, at ^= N << 13 | N >>> 32 - 13, N = at + It | 0, Se ^= N << 18 | N >>> 32 - 18, N = se + H | 0, Rt ^= N << 7 | N >>> 32 - 7, N = Rt + se | 0, Ie ^= N << 9 | N >>> 32 - 9, N = Ie + Rt | 0, H ^= N << 13 | N >>> 32 - 13, N = H + Ie | 0, se ^= N << 18 | N >>> 32 - 18, N = Bt + ve | 0, Te ^= N << 7 | N >>> 32 - 7, N = Te + Bt | 0, V ^= N << 9 | N >>> 32 - 9, N = V + Te | 0, ve ^= N << 13 | N >>> 32 - 13, N = ve + V | 0, Bt ^= N << 18 | N >>> 32 - 18, N = ke + Te | 0, at ^= N << 7 | N >>> 32 - 7, N = at + ke | 0, Ie ^= N << 9 | N >>> 32 - 9, N = Ie + at | 0, Te ^= N << 13 | N >>> 32 - 13, N = Te + Ie | 0, ke ^= N << 18 | N >>> 32 - 18, N = Se + qe | 0, H ^= N << 7 | N >>> 32 - 7, N = H + Se | 0, V ^= N << 9 | N >>> 32 - 9, N = V + H | 0, qe ^= N << 13 | N >>> 32 - 13, N = qe + V | 0, Se ^= N << 18 | N >>> 32 - 18, N = se + oe | 0, ve ^= N << 7 | N >>> 32 - 7, N = ve + se | 0, ye ^= N << 9 | N >>> 32 - 9, N = ye + ve | 0, oe ^= N << 13 | N >>> 32 - 13, N = oe + ye | 0, se ^= N << 18 | N >>> 32 - 18, N = Bt + Rt | 0, wt ^= N << 7 | N >>> 32 - 7, N = wt + Bt | 0, It ^= N << 9 | N >>> 32 - 9, N = It + wt | 0, Rt ^= N << 13 | N >>> 32 - 13, N = Rt + It | 0, Bt ^= N << 18 | N >>> 32 - 18;
                ke = ke + P | 0, at = at + U | 0, Ie = Ie + j | 0, Te = Te + K | 0, qe = qe + W | 0, Se = Se + Pe | 0, H = H + ne | 0, V = V + Me | 0, ye = ye + Ae | 0, oe = oe + ut | 0, se = se + ht | 0, ve = ve + pt | 0, wt = wt + dt | 0, It = It + yt | 0, Rt = Rt + bt | 0, Bt = Bt + mt | 0, M[0] = ke >>> 0 & 255, M[1] = ke >>> 8 & 255, M[2] = ke >>> 16 & 255, M[3] = ke >>> 24 & 255, M[4] = at >>> 0 & 255, M[5] = at >>> 8 & 255, M[6] = at >>> 16 & 255, M[7] = at >>> 24 & 255, M[8] = Ie >>> 0 & 255, M[9] = Ie >>> 8 & 255, M[10] = Ie >>> 16 & 255, M[11] = Ie >>> 24 & 255, M[12] = Te >>> 0 & 255, M[13] = Te >>> 8 & 255, M[14] = Te >>> 16 & 255, M[15] = Te >>> 24 & 255, M[16] = qe >>> 0 & 255, M[17] = qe >>> 8 & 255, M[18] = qe >>> 16 & 255, M[19] = qe >>> 24 & 255, M[20] = Se >>> 0 & 255, M[21] = Se >>> 8 & 255, M[22] = Se >>> 16 & 255, M[23] = Se >>> 24 & 255, M[24] = H >>> 0 & 255, M[25] = H >>> 8 & 255, M[26] = H >>> 16 & 255, M[27] = H >>> 24 & 255, M[28] = V >>> 0 & 255, M[29] = V >>> 8 & 255, M[30] = V >>> 16 & 255, M[31] = V >>> 24 & 255, M[32] = ye >>> 0 & 255, M[33] = ye >>> 8 & 255, M[34] = ye >>> 16 & 255, M[35] = ye >>> 24 & 255, M[36] = oe >>> 0 & 255, M[37] = oe >>> 8 & 255, M[38] = oe >>> 16 & 255, M[39] = oe >>> 24 & 255, M[40] = se >>> 0 & 255, M[41] = se >>> 8 & 255, M[42] = se >>> 16 & 255, M[43] = se >>> 24 & 255, M[44] = ve >>> 0 & 255, M[45] = ve >>> 8 & 255, M[46] = ve >>> 16 & 255, M[47] = ve >>> 24 & 255, M[48] = wt >>> 0 & 255, M[49] = wt >>> 8 & 255, M[50] = wt >>> 16 & 255, M[51] = wt >>> 24 & 255, M[52] = It >>> 0 & 255, M[53] = It >>> 8 & 255, M[54] = It >>> 16 & 255, M[55] = It >>> 24 & 255, M[56] = Rt >>> 0 & 255, M[57] = Rt >>> 8 & 255, M[58] = Rt >>> 16 & 255, M[59] = Rt >>> 24 & 255, M[60] = Bt >>> 0 & 255, M[61] = Bt >>> 8 & 255, M[62] = Bt >>> 16 & 255, M[63] = Bt >>> 24 & 255
            }

            function Xe(M, k, R, b) {
                for (var P = b[0] & 255 | (b[1] & 255) << 8 | (b[2] & 255) << 16 | (b[3] & 255) << 24, U = R[0] & 255 | (R[1] & 255) << 8 | (R[2] & 255) << 16 | (R[3] & 255) << 24, j = R[4] & 255 | (R[5] & 255) << 8 | (R[6] & 255) << 16 | (R[7] & 255) << 24, K = R[8] & 255 | (R[9] & 255) << 8 | (R[10] & 255) << 16 | (R[11] & 255) << 24, W = R[12] & 255 | (R[13] & 255) << 8 | (R[14] & 255) << 16 | (R[15] & 255) << 24, Pe = b[4] & 255 | (b[5] & 255) << 8 | (b[6] & 255) << 16 | (b[7] & 255) << 24, ne = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, Me = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, Ae = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, ut = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, ht = b[8] & 255 | (b[9] & 255) << 8 | (b[10] & 255) << 16 | (b[11] & 255) << 24, pt = R[16] & 255 | (R[17] & 255) << 8 | (R[18] & 255) << 16 | (R[19] & 255) << 24, dt = R[20] & 255 | (R[21] & 255) << 8 | (R[22] & 255) << 16 | (R[23] & 255) << 24, yt = R[24] & 255 | (R[25] & 255) << 8 | (R[26] & 255) << 16 | (R[27] & 255) << 24, bt = R[28] & 255 | (R[29] & 255) << 8 | (R[30] & 255) << 16 | (R[31] & 255) << 24, mt = b[12] & 255 | (b[13] & 255) << 8 | (b[14] & 255) << 16 | (b[15] & 255) << 24, ke = P, at = U, Ie = j, Te = K, qe = W, Se = Pe, H = ne, V = Me, ye = Ae, oe = ut, se = ht, ve = pt, wt = dt, It = yt, Rt = bt, Bt = mt, N, Tt = 0; Tt < 20; Tt += 2) N = ke + wt | 0, qe ^= N << 7 | N >>> 32 - 7, N = qe + ke | 0, ye ^= N << 9 | N >>> 32 - 9, N = ye + qe | 0, wt ^= N << 13 | N >>> 32 - 13, N = wt + ye | 0, ke ^= N << 18 | N >>> 32 - 18, N = Se + at | 0, oe ^= N << 7 | N >>> 32 - 7, N = oe + Se | 0, It ^= N << 9 | N >>> 32 - 9, N = It + oe | 0, at ^= N << 13 | N >>> 32 - 13, N = at + It | 0, Se ^= N << 18 | N >>> 32 - 18, N = se + H | 0, Rt ^= N << 7 | N >>> 32 - 7, N = Rt + se | 0, Ie ^= N << 9 | N >>> 32 - 9, N = Ie + Rt | 0, H ^= N << 13 | N >>> 32 - 13, N = H + Ie | 0, se ^= N << 18 | N >>> 32 - 18, N = Bt + ve | 0, Te ^= N << 7 | N >>> 32 - 7, N = Te + Bt | 0, V ^= N << 9 | N >>> 32 - 9, N = V + Te | 0, ve ^= N << 13 | N >>> 32 - 13, N = ve + V | 0, Bt ^= N << 18 | N >>> 32 - 18, N = ke + Te | 0, at ^= N << 7 | N >>> 32 - 7, N = at + ke | 0, Ie ^= N << 9 | N >>> 32 - 9, N = Ie + at | 0, Te ^= N << 13 | N >>> 32 - 13, N = Te + Ie | 0, ke ^= N << 18 | N >>> 32 - 18, N = Se + qe | 0, H ^= N << 7 | N >>> 32 - 7, N = H + Se | 0, V ^= N << 9 | N >>> 32 - 9, N = V + H | 0, qe ^= N << 13 | N >>> 32 - 13, N = qe + V | 0, Se ^= N << 18 | N >>> 32 - 18, N = se + oe | 0, ve ^= N << 7 | N >>> 32 - 7, N = ve + se | 0, ye ^= N << 9 | N >>> 32 - 9, N = ye + ve | 0, oe ^= N << 13 | N >>> 32 - 13, N = oe + ye | 0, se ^= N << 18 | N >>> 32 - 18, N = Bt + Rt | 0, wt ^= N << 7 | N >>> 32 - 7, N = wt + Bt | 0, It ^= N << 9 | N >>> 32 - 9, N = It + wt | 0, Rt ^= N << 13 | N >>> 32 - 13, N = Rt + It | 0, Bt ^= N << 18 | N >>> 32 - 18;
                M[0] = ke >>> 0 & 255, M[1] = ke >>> 8 & 255, M[2] = ke >>> 16 & 255, M[3] = ke >>> 24 & 255, M[4] = Se >>> 0 & 255, M[5] = Se >>> 8 & 255, M[6] = Se >>> 16 & 255, M[7] = Se >>> 24 & 255, M[8] = se >>> 0 & 255, M[9] = se >>> 8 & 255, M[10] = se >>> 16 & 255, M[11] = se >>> 24 & 255, M[12] = Bt >>> 0 & 255, M[13] = Bt >>> 8 & 255, M[14] = Bt >>> 16 & 255, M[15] = Bt >>> 24 & 255, M[16] = H >>> 0 & 255, M[17] = H >>> 8 & 255, M[18] = H >>> 16 & 255, M[19] = H >>> 24 & 255, M[20] = V >>> 0 & 255, M[21] = V >>> 8 & 255, M[22] = V >>> 16 & 255, M[23] = V >>> 24 & 255, M[24] = ye >>> 0 & 255, M[25] = ye >>> 8 & 255, M[26] = ye >>> 16 & 255, M[27] = ye >>> 24 & 255, M[28] = oe >>> 0 & 255, M[29] = oe >>> 8 & 255, M[30] = oe >>> 16 & 255, M[31] = oe >>> 24 & 255
            }

            function xe(M, k, R, b) {
                ce(M, k, R, b)
            }

            function ie(M, k, R, b) {
                Xe(M, k, R, b)
            }
            var ae = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);

            function be(M, k, R, b, P, U, j) {
                var K = new Uint8Array(16),
                    W = new Uint8Array(64),
                    Pe, ne;
                for (ne = 0; ne < 16; ne++) K[ne] = 0;
                for (ne = 0; ne < 8; ne++) K[ne] = U[ne];
                for (; P >= 64;) {
                    for (xe(W, K, j, ae), ne = 0; ne < 64; ne++) M[k + ne] = R[b + ne] ^ W[ne];
                    for (Pe = 1, ne = 8; ne < 16; ne++) Pe = Pe + (K[ne] & 255) | 0, K[ne] = Pe & 255, Pe >>>= 8;
                    P -= 64, k += 64, b += 64
                }
                if (P > 0)
                    for (xe(W, K, j, ae), ne = 0; ne < P; ne++) M[k + ne] = R[b + ne] ^ W[ne];
                return 0
            }

            function we(M, k, R, b, P) {
                var U = new Uint8Array(16),
                    j = new Uint8Array(64),
                    K, W;
                for (W = 0; W < 16; W++) U[W] = 0;
                for (W = 0; W < 8; W++) U[W] = b[W];
                for (; R >= 64;) {
                    for (xe(j, U, P, ae), W = 0; W < 64; W++) M[k + W] = j[W];
                    for (K = 1, W = 8; W < 16; W++) K = K + (U[W] & 255) | 0, U[W] = K & 255, K >>>= 8;
                    R -= 64, k += 64
                }
                if (R > 0)
                    for (xe(j, U, P, ae), W = 0; W < R; W++) M[k + W] = j[W];
                return 0
            }

            function he(M, k, R, b, P) {
                var U = new Uint8Array(32);
                ie(U, b, P, ae);
                for (var j = new Uint8Array(8), K = 0; K < 8; K++) j[K] = b[K + 16];
                return we(M, k, R, j, U)
            }

            function gt(M, k, R, b, P, U, j) {
                var K = new Uint8Array(32);
                ie(K, U, j, ae);
                for (var W = new Uint8Array(8), Pe = 0; Pe < 8; Pe++) W[Pe] = U[Pe + 16];
                return be(M, k, R, b, P, W, K)
            }
            var T = function(M) {
                this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
                var k, R, b, P, U, j, K, W;
                k = M[0] & 255 | (M[1] & 255) << 8, this.r[0] = k & 8191, R = M[2] & 255 | (M[3] & 255) << 8, this.r[1] = (k >>> 13 | R << 3) & 8191, b = M[4] & 255 | (M[5] & 255) << 8, this.r[2] = (R >>> 10 | b << 6) & 7939, P = M[6] & 255 | (M[7] & 255) << 8, this.r[3] = (b >>> 7 | P << 9) & 8191, U = M[8] & 255 | (M[9] & 255) << 8, this.r[4] = (P >>> 4 | U << 12) & 255, this.r[5] = U >>> 1 & 8190, j = M[10] & 255 | (M[11] & 255) << 8, this.r[6] = (U >>> 14 | j << 2) & 8191, K = M[12] & 255 | (M[13] & 255) << 8, this.r[7] = (j >>> 11 | K << 5) & 8065, W = M[14] & 255 | (M[15] & 255) << 8, this.r[8] = (K >>> 8 | W << 8) & 8191, this.r[9] = W >>> 5 & 127, this.pad[0] = M[16] & 255 | (M[17] & 255) << 8, this.pad[1] = M[18] & 255 | (M[19] & 255) << 8, this.pad[2] = M[20] & 255 | (M[21] & 255) << 8, this.pad[3] = M[22] & 255 | (M[23] & 255) << 8, this.pad[4] = M[24] & 255 | (M[25] & 255) << 8, this.pad[5] = M[26] & 255 | (M[27] & 255) << 8, this.pad[6] = M[28] & 255 | (M[29] & 255) << 8, this.pad[7] = M[30] & 255 | (M[31] & 255) << 8
            };
            T.prototype.blocks = function(M, k, R) {
                for (var b = this.fin ? 0 : 2048, P, U, j, K, W, Pe, ne, Me, Ae, ut, ht, pt, dt, yt, bt, mt, ke, at, Ie, Te = this.h[0], qe = this.h[1], Se = this.h[2], H = this.h[3], V = this.h[4], ye = this.h[5], oe = this.h[6], se = this.h[7], ve = this.h[8], wt = this.h[9], It = this.r[0], Rt = this.r[1], Bt = this.r[2], N = this.r[3], Tt = this.r[4], Kt = this.r[5], $t = this.r[6], Pt = this.r[7], Ct = this.r[8], Ot = this.r[9]; R >= 16;) P = M[k + 0] & 255 | (M[k + 1] & 255) << 8, Te += P & 8191, U = M[k + 2] & 255 | (M[k + 3] & 255) << 8, qe += (P >>> 13 | U << 3) & 8191, j = M[k + 4] & 255 | (M[k + 5] & 255) << 8, Se += (U >>> 10 | j << 6) & 8191, K = M[k + 6] & 255 | (M[k + 7] & 255) << 8, H += (j >>> 7 | K << 9) & 8191, W = M[k + 8] & 255 | (M[k + 9] & 255) << 8, V += (K >>> 4 | W << 12) & 8191, ye += W >>> 1 & 8191, Pe = M[k + 10] & 255 | (M[k + 11] & 255) << 8, oe += (W >>> 14 | Pe << 2) & 8191, ne = M[k + 12] & 255 | (M[k + 13] & 255) << 8, se += (Pe >>> 11 | ne << 5) & 8191, Me = M[k + 14] & 255 | (M[k + 15] & 255) << 8, ve += (ne >>> 8 | Me << 8) & 8191, wt += Me >>> 5 | b, Ae = 0, ut = Ae, ut += Te * It, ut += qe * (5 * Ot), ut += Se * (5 * Ct), ut += H * (5 * Pt), ut += V * (5 * $t), Ae = ut >>> 13, ut &= 8191, ut += ye * (5 * Kt), ut += oe * (5 * Tt), ut += se * (5 * N), ut += ve * (5 * Bt), ut += wt * (5 * Rt), Ae += ut >>> 13, ut &= 8191, ht = Ae, ht += Te * Rt, ht += qe * It, ht += Se * (5 * Ot), ht += H * (5 * Ct), ht += V * (5 * Pt), Ae = ht >>> 13, ht &= 8191, ht += ye * (5 * $t), ht += oe * (5 * Kt), ht += se * (5 * Tt), ht += ve * (5 * N), ht += wt * (5 * Bt), Ae += ht >>> 13, ht &= 8191, pt = Ae, pt += Te * Bt, pt += qe * Rt, pt += Se * It, pt += H * (5 * Ot), pt += V * (5 * Ct), Ae = pt >>> 13, pt &= 8191, pt += ye * (5 * Pt), pt += oe * (5 * $t), pt += se * (5 * Kt), pt += ve * (5 * Tt), pt += wt * (5 * N), Ae += pt >>> 13, pt &= 8191, dt = Ae, dt += Te * N, dt += qe * Bt, dt += Se * Rt, dt += H * It, dt += V * (5 * Ot), Ae = dt >>> 13, dt &= 8191, dt += ye * (5 * Ct), dt += oe * (5 * Pt), dt += se * (5 * $t), dt += ve * (5 * Kt), dt += wt * (5 * Tt), Ae += dt >>> 13, dt &= 8191, yt = Ae, yt += Te * Tt, yt += qe * N, yt += Se * Bt, yt += H * Rt, yt += V * It, Ae = yt >>> 13, yt &= 8191, yt += ye * (5 * Ot), yt += oe * (5 * Ct), yt += se * (5 * Pt), yt += ve * (5 * $t), yt += wt * (5 * Kt), Ae += yt >>> 13, yt &= 8191, bt = Ae, bt += Te * Kt, bt += qe * Tt, bt += Se * N, bt += H * Bt, bt += V * Rt, Ae = bt >>> 13, bt &= 8191, bt += ye * It, bt += oe * (5 * Ot), bt += se * (5 * Ct), bt += ve * (5 * Pt), bt += wt * (5 * $t), Ae += bt >>> 13, bt &= 8191, mt = Ae, mt += Te * $t, mt += qe * Kt, mt += Se * Tt, mt += H * N, mt += V * Bt, Ae = mt >>> 13, mt &= 8191, mt += ye * Rt, mt += oe * It, mt += se * (5 * Ot), mt += ve * (5 * Ct), mt += wt * (5 * Pt), Ae += mt >>> 13, mt &= 8191, ke = Ae, ke += Te * Pt, ke += qe * $t, ke += Se * Kt, ke += H * Tt, ke += V * N, Ae = ke >>> 13, ke &= 8191, ke += ye * Bt, ke += oe * Rt, ke += se * It, ke += ve * (5 * Ot), ke += wt * (5 * Ct), Ae += ke >>> 13, ke &= 8191, at = Ae, at += Te * Ct, at += qe * Pt, at += Se * $t, at += H * Kt, at += V * Tt, Ae = at >>> 13, at &= 8191, at += ye * N, at += oe * Bt, at += se * Rt, at += ve * It, at += wt * (5 * Ot), Ae += at >>> 13, at &= 8191, Ie = Ae, Ie += Te * Ot, Ie += qe * Ct, Ie += Se * Pt, Ie += H * $t, Ie += V * Kt, Ae = Ie >>> 13, Ie &= 8191, Ie += ye * Tt, Ie += oe * N, Ie += se * Bt, Ie += ve * Rt, Ie += wt * It, Ae += Ie >>> 13, Ie &= 8191, Ae = (Ae << 2) + Ae | 0, Ae = Ae + ut | 0, ut = Ae & 8191, Ae = Ae >>> 13, ht += Ae, Te = ut, qe = ht, Se = pt, H = dt, V = yt, ye = bt, oe = mt, se = ke, ve = at, wt = Ie, k += 16, R -= 16;
                this.h[0] = Te, this.h[1] = qe, this.h[2] = Se, this.h[3] = H, this.h[4] = V, this.h[5] = ye, this.h[6] = oe, this.h[7] = se, this.h[8] = ve, this.h[9] = wt
            }, T.prototype.finish = function(M, k) {
                var R = new Uint16Array(10),
                    b, P, U, j;
                if (this.leftover) {
                    for (j = this.leftover, this.buffer[j++] = 1; j < 16; j++) this.buffer[j] = 0;
                    this.fin = 1, this.blocks(this.buffer, 0, 16)
                }
                for (b = this.h[1] >>> 13, this.h[1] &= 8191, j = 2; j < 10; j++) this.h[j] += b, b = this.h[j] >>> 13, this.h[j] &= 8191;
                for (this.h[0] += b * 5, b = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += b, b = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += b, R[0] = this.h[0] + 5, b = R[0] >>> 13, R[0] &= 8191, j = 1; j < 10; j++) R[j] = this.h[j] + b, b = R[j] >>> 13, R[j] &= 8191;
                for (R[9] -= 1 << 13, P = (b ^ 1) - 1, j = 0; j < 10; j++) R[j] &= P;
                for (P = ~P, j = 0; j < 10; j++) this.h[j] = this.h[j] & P | R[j];
                for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, U = this.h[0] + this.pad[0], this.h[0] = U & 65535, j = 1; j < 8; j++) U = (this.h[j] + this.pad[j] | 0) + (U >>> 16) | 0, this.h[j] = U & 65535;
                M[k + 0] = this.h[0] >>> 0 & 255, M[k + 1] = this.h[0] >>> 8 & 255, M[k + 2] = this.h[1] >>> 0 & 255, M[k + 3] = this.h[1] >>> 8 & 255, M[k + 4] = this.h[2] >>> 0 & 255, M[k + 5] = this.h[2] >>> 8 & 255, M[k + 6] = this.h[3] >>> 0 & 255, M[k + 7] = this.h[3] >>> 8 & 255, M[k + 8] = this.h[4] >>> 0 & 255, M[k + 9] = this.h[4] >>> 8 & 255, M[k + 10] = this.h[5] >>> 0 & 255, M[k + 11] = this.h[5] >>> 8 & 255, M[k + 12] = this.h[6] >>> 0 & 255, M[k + 13] = this.h[6] >>> 8 & 255, M[k + 14] = this.h[7] >>> 0 & 255, M[k + 15] = this.h[7] >>> 8 & 255
            }, T.prototype.update = function(M, k, R) {
                var b, P;
                if (this.leftover) {
                    for (P = 16 - this.leftover, P > R && (P = R), b = 0; b < P; b++) this.buffer[this.leftover + b] = M[k + b];
                    if (R -= P, k += P, this.leftover += P, this.leftover < 16) return;
                    this.blocks(this.buffer, 0, 16), this.leftover = 0
                }
                if (R >= 16 && (P = R - R % 16, this.blocks(M, k, P), k += P, R -= P), R) {
                    for (b = 0; b < R; b++) this.buffer[this.leftover + b] = M[k + b];
                    this.leftover += R
                }
            };

            function m(M, k, R, b, P, U) {
                var j = new T(U);
                return j.update(R, b, P), j.finish(M, k), 0
            }

            function w(M, k, R, b, P, U) {
                var j = new Uint8Array(16);
                return m(j, 0, R, b, P, U), Z(M, k, j, 0)
            }

            function l(M, k, R, b, P) {
                var U;
                if (R < 32) return -1;
                for (gt(M, 0, k, 0, R, b, P), m(M, 16, M, 32, R - 32, M), U = 0; U < 16; U++) M[U] = 0;
                return 0
            }

            function s(M, k, R, b, P) {
                var U, j = new Uint8Array(32);
                if (R < 32 || (he(j, 0, 32, b, P), w(k, 16, k, 32, R - 32, j) !== 0)) return -1;
                for (gt(M, 0, k, 0, R, b, P), U = 0; U < 32; U++) M[U] = 0;
                return 0
            }

            function f(M, k) {
                var R;
                for (R = 0; R < 16; R++) M[R] = k[R] | 0
            }

            function h(M) {
                var k, R, b = 1;
                for (k = 0; k < 16; k++) R = M[k] + b + 65535, b = Math.floor(R / 65536), M[k] = R - b * 65536;
                M[0] += b - 1 + 37 * (b - 1)
            }

            function p(M, k, R) {
                for (var b, P = ~(R - 1), U = 0; U < 16; U++) b = P & (M[U] ^ k[U]), M[U] ^= b, k[U] ^= b
            }

            function d(M, k) {
                var R, b, P, U = e(),
                    j = e();
                for (R = 0; R < 16; R++) j[R] = k[R];
                for (h(j), h(j), h(j), b = 0; b < 2; b++) {
                    for (U[0] = j[0] - 65517, R = 1; R < 15; R++) U[R] = j[R] - 65535 - (U[R - 1] >> 16 & 1), U[R - 1] &= 65535;
                    U[15] = j[15] - 32767 - (U[14] >> 16 & 1), P = U[15] >> 16 & 1, U[14] &= 65535, p(j, U, 1 - P)
                }
                for (R = 0; R < 16; R++) M[2 * R] = j[R] & 255, M[2 * R + 1] = j[R] >> 8
            }

            function c(M, k) {
                var R = new Uint8Array(32),
                    b = new Uint8Array(32);
                return d(R, M), d(b, k), ge(R, 0, b, 0)
            }

            function x(M) {
                var k = new Uint8Array(32);
                return d(k, M), k[0] & 1
            }

            function v(M, k) {
                var R;
                for (R = 0; R < 16; R++) M[R] = k[2 * R] + (k[2 * R + 1] << 8);
                M[15] &= 32767
            }

            function u(M, k, R) {
                for (var b = 0; b < 16; b++) M[b] = k[b] + R[b]
            }

            function _(M, k, R) {
                for (var b = 0; b < 16; b++) M[b] = k[b] - R[b]
            }

            function F(M, k, R) {
                var b, P, U = 0,
                    j = 0,
                    K = 0,
                    W = 0,
                    Pe = 0,
                    ne = 0,
                    Me = 0,
                    Ae = 0,
                    ut = 0,
                    ht = 0,
                    pt = 0,
                    dt = 0,
                    yt = 0,
                    bt = 0,
                    mt = 0,
                    ke = 0,
                    at = 0,
                    Ie = 0,
                    Te = 0,
                    qe = 0,
                    Se = 0,
                    H = 0,
                    V = 0,
                    ye = 0,
                    oe = 0,
                    se = 0,
                    ve = 0,
                    wt = 0,
                    It = 0,
                    Rt = 0,
                    Bt = 0,
                    N = R[0],
                    Tt = R[1],
                    Kt = R[2],
                    $t = R[3],
                    Pt = R[4],
                    Ct = R[5],
                    Ot = R[6],
                    br = R[7],
                    Qt = R[8],
                    pr = R[9],
                    yr = R[10],
                    mr = R[11],
                    Er = R[12],
                    Hr = R[13],
                    Vr = R[14],
                    Gr = R[15];
                b = k[0], U += b * N, j += b * Tt, K += b * Kt, W += b * $t, Pe += b * Pt, ne += b * Ct, Me += b * Ot, Ae += b * br, ut += b * Qt, ht += b * pr, pt += b * yr, dt += b * mr, yt += b * Er, bt += b * Hr, mt += b * Vr, ke += b * Gr, b = k[1], j += b * N, K += b * Tt, W += b * Kt, Pe += b * $t, ne += b * Pt, Me += b * Ct, Ae += b * Ot, ut += b * br, ht += b * Qt, pt += b * pr, dt += b * yr, yt += b * mr, bt += b * Er, mt += b * Hr, ke += b * Vr, at += b * Gr, b = k[2], K += b * N, W += b * Tt, Pe += b * Kt, ne += b * $t, Me += b * Pt, Ae += b * Ct, ut += b * Ot, ht += b * br, pt += b * Qt, dt += b * pr, yt += b * yr, bt += b * mr, mt += b * Er, ke += b * Hr, at += b * Vr, Ie += b * Gr, b = k[3], W += b * N, Pe += b * Tt, ne += b * Kt, Me += b * $t, Ae += b * Pt, ut += b * Ct, ht += b * Ot, pt += b * br, dt += b * Qt, yt += b * pr, bt += b * yr, mt += b * mr, ke += b * Er, at += b * Hr, Ie += b * Vr, Te += b * Gr, b = k[4], Pe += b * N, ne += b * Tt, Me += b * Kt, Ae += b * $t, ut += b * Pt, ht += b * Ct, pt += b * Ot, dt += b * br, yt += b * Qt, bt += b * pr, mt += b * yr, ke += b * mr, at += b * Er, Ie += b * Hr, Te += b * Vr, qe += b * Gr, b = k[5], ne += b * N, Me += b * Tt, Ae += b * Kt, ut += b * $t, ht += b * Pt, pt += b * Ct, dt += b * Ot, yt += b * br, bt += b * Qt, mt += b * pr, ke += b * yr, at += b * mr, Ie += b * Er, Te += b * Hr, qe += b * Vr, Se += b * Gr, b = k[6], Me += b * N, Ae += b * Tt, ut += b * Kt, ht += b * $t, pt += b * Pt, dt += b * Ct, yt += b * Ot, bt += b * br, mt += b * Qt, ke += b * pr, at += b * yr, Ie += b * mr, Te += b * Er, qe += b * Hr, Se += b * Vr, H += b * Gr, b = k[7], Ae += b * N, ut += b * Tt, ht += b * Kt, pt += b * $t, dt += b * Pt, yt += b * Ct, bt += b * Ot, mt += b * br, ke += b * Qt, at += b * pr, Ie += b * yr, Te += b * mr, qe += b * Er, Se += b * Hr, H += b * Vr, V += b * Gr, b = k[8], ut += b * N, ht += b * Tt, pt += b * Kt, dt += b * $t, yt += b * Pt, bt += b * Ct, mt += b * Ot, ke += b * br, at += b * Qt, Ie += b * pr, Te += b * yr, qe += b * mr, Se += b * Er, H += b * Hr, V += b * Vr, ye += b * Gr, b = k[9], ht += b * N, pt += b * Tt, dt += b * Kt, yt += b * $t, bt += b * Pt, mt += b * Ct, ke += b * Ot, at += b * br, Ie += b * Qt, Te += b * pr, qe += b * yr, Se += b * mr, H += b * Er, V += b * Hr, ye += b * Vr, oe += b * Gr, b = k[10], pt += b * N, dt += b * Tt, yt += b * Kt, bt += b * $t, mt += b * Pt, ke += b * Ct, at += b * Ot, Ie += b * br, Te += b * Qt, qe += b * pr, Se += b * yr, H += b * mr, V += b * Er, ye += b * Hr, oe += b * Vr, se += b * Gr, b = k[11], dt += b * N, yt += b * Tt, bt += b * Kt, mt += b * $t, ke += b * Pt, at += b * Ct, Ie += b * Ot, Te += b * br, qe += b * Qt, Se += b * pr, H += b * yr, V += b * mr, ye += b * Er, oe += b * Hr, se += b * Vr, ve += b * Gr, b = k[12], yt += b * N, bt += b * Tt, mt += b * Kt, ke += b * $t, at += b * Pt, Ie += b * Ct, Te += b * Ot, qe += b * br, Se += b * Qt, H += b * pr, V += b * yr, ye += b * mr, oe += b * Er, se += b * Hr, ve += b * Vr, wt += b * Gr, b = k[13], bt += b * N, mt += b * Tt, ke += b * Kt, at += b * $t, Ie += b * Pt, Te += b * Ct, qe += b * Ot, Se += b * br, H += b * Qt, V += b * pr, ye += b * yr, oe += b * mr, se += b * Er, ve += b * Hr, wt += b * Vr, It += b * Gr, b = k[14], mt += b * N, ke += b * Tt, at += b * Kt, Ie += b * $t, Te += b * Pt, qe += b * Ct, Se += b * Ot, H += b * br, V += b * Qt, ye += b * pr, oe += b * yr, se += b * mr, ve += b * Er, wt += b * Hr, It += b * Vr, Rt += b * Gr, b = k[15], ke += b * N, at += b * Tt, Ie += b * Kt, Te += b * $t, qe += b * Pt, Se += b * Ct, H += b * Ot, V += b * br, ye += b * Qt, oe += b * pr, se += b * yr, ve += b * mr, wt += b * Er, It += b * Hr, Rt += b * Vr, Bt += b * Gr, U += 38 * at, j += 38 * Ie, K += 38 * Te, W += 38 * qe, Pe += 38 * Se, ne += 38 * H, Me += 38 * V, Ae += 38 * ye, ut += 38 * oe, ht += 38 * se, pt += 38 * ve, dt += 38 * wt, yt += 38 * It, bt += 38 * Rt, mt += 38 * Bt, P = 1, b = U + P + 65535, P = Math.floor(b / 65536), U = b - P * 65536, b = j + P + 65535, P = Math.floor(b / 65536), j = b - P * 65536, b = K + P + 65535, P = Math.floor(b / 65536), K = b - P * 65536, b = W + P + 65535, P = Math.floor(b / 65536), W = b - P * 65536, b = Pe + P + 65535, P = Math.floor(b / 65536), Pe = b - P * 65536, b = ne + P + 65535, P = Math.floor(b / 65536), ne = b - P * 65536, b = Me + P + 65535, P = Math.floor(b / 65536), Me = b - P * 65536, b = Ae + P + 65535, P = Math.floor(b / 65536), Ae = b - P * 65536, b = ut + P + 65535, P = Math.floor(b / 65536), ut = b - P * 65536, b = ht + P + 65535, P = Math.floor(b / 65536), ht = b - P * 65536, b = pt + P + 65535, P = Math.floor(b / 65536), pt = b - P * 65536, b = dt + P + 65535, P = Math.floor(b / 65536), dt = b - P * 65536, b = yt + P + 65535, P = Math.floor(b / 65536), yt = b - P * 65536, b = bt + P + 65535, P = Math.floor(b / 65536), bt = b - P * 65536, b = mt + P + 65535, P = Math.floor(b / 65536), mt = b - P * 65536, b = ke + P + 65535, P = Math.floor(b / 65536), ke = b - P * 65536, U += P - 1 + 37 * (P - 1), P = 1, b = U + P + 65535, P = Math.floor(b / 65536), U = b - P * 65536, b = j + P + 65535, P = Math.floor(b / 65536), j = b - P * 65536, b = K + P + 65535, P = Math.floor(b / 65536), K = b - P * 65536, b = W + P + 65535, P = Math.floor(b / 65536), W = b - P * 65536, b = Pe + P + 65535, P = Math.floor(b / 65536), Pe = b - P * 65536, b = ne + P + 65535, P = Math.floor(b / 65536), ne = b - P * 65536, b = Me + P + 65535, P = Math.floor(b / 65536), Me = b - P * 65536, b = Ae + P + 65535, P = Math.floor(b / 65536), Ae = b - P * 65536, b = ut + P + 65535, P = Math.floor(b / 65536), ut = b - P * 65536, b = ht + P + 65535, P = Math.floor(b / 65536), ht = b - P * 65536, b = pt + P + 65535, P = Math.floor(b / 65536), pt = b - P * 65536, b = dt + P + 65535, P = Math.floor(b / 65536), dt = b - P * 65536, b = yt + P + 65535, P = Math.floor(b / 65536), yt = b - P * 65536, b = bt + P + 65535, P = Math.floor(b / 65536), bt = b - P * 65536, b = mt + P + 65535, P = Math.floor(b / 65536), mt = b - P * 65536, b = ke + P + 65535, P = Math.floor(b / 65536), ke = b - P * 65536, U += P - 1 + 37 * (P - 1), M[0] = U, M[1] = j, M[2] = K, M[3] = W, M[4] = Pe, M[5] = ne, M[6] = Me, M[7] = Ae, M[8] = ut, M[9] = ht, M[10] = pt, M[11] = dt, M[12] = yt, M[13] = bt, M[14] = mt, M[15] = ke
            }

            function S(M, k) {
                F(M, k, k)
            }

            function z(M, k) {
                var R = e(),
                    b;
                for (b = 0; b < 16; b++) R[b] = k[b];
                for (b = 253; b >= 0; b--) S(R, R), b !== 2 && b !== 4 && F(R, R, k);
                for (b = 0; b < 16; b++) M[b] = R[b]
            }

            function C(M, k) {
                var R = e(),
                    b;
                for (b = 0; b < 16; b++) R[b] = k[b];
                for (b = 250; b >= 0; b--) S(R, R), b !== 1 && F(R, R, k);
                for (b = 0; b < 16; b++) M[b] = R[b]
            }

            function D(M, k, R) {
                var b = new Uint8Array(32),
                    P = new Float64Array(80),
                    U, j, K = e(),
                    W = e(),
                    Pe = e(),
                    ne = e(),
                    Me = e(),
                    Ae = e();
                for (j = 0; j < 31; j++) b[j] = k[j];
                for (b[31] = k[31] & 127 | 64, b[0] &= 248, v(P, R), j = 0; j < 16; j++) W[j] = P[j], ne[j] = K[j] = Pe[j] = 0;
                for (K[0] = ne[0] = 1, j = 254; j >= 0; --j) U = b[j >>> 3] >>> (j & 7) & 1, p(K, W, U), p(Pe, ne, U), u(Me, K, Pe), _(K, K, Pe), u(Pe, W, ne), _(W, W, ne), S(ne, Me), S(Ae, K), F(K, Pe, K), F(Pe, W, Me), u(Me, K, Pe), _(K, K, Pe), S(W, K), _(Pe, ne, Ae), F(K, Pe, y), u(K, K, ne), F(Pe, Pe, K), F(K, ne, Ae), F(ne, W, P), S(W, Me), p(K, W, U), p(Pe, ne, U);
                for (j = 0; j < 16; j++) P[j + 16] = K[j], P[j + 32] = Pe[j], P[j + 48] = W[j], P[j + 64] = ne[j];
                var ut = P.subarray(32),
                    ht = P.subarray(16);
                return z(ut, ut), F(ht, ht, ut), d(M, ht), 0
            }

            function Y(M, k) {
                return D(M, k, i)
            }

            function Re(M, k) {
                return t(k, 32), Y(M, k)
            }

            function ee(M, k, R) {
                var b = new Uint8Array(32);
                return D(b, R, k), ie(M, n, b, ae)
            }
            var re = l,
                Zt = s;

            function me(M, k, R, b, P, U) {
                var j = new Uint8Array(32);
                return ee(j, P, U), re(M, k, R, b, j)
            }

            function Ee(M, k, R, b, P, U) {
                var j = new Uint8Array(32);
                return ee(j, P, U), Zt(M, k, R, b, j)
            }
            var $r = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

            function Qe(M, k, R, b) {
                for (var P = new Int32Array(16), U = new Int32Array(16), j, K, W, Pe, ne, Me, Ae, ut, ht, pt, dt, yt, bt, mt, ke, at, Ie, Te, qe, Se, H, V, ye, oe, se, ve, wt = M[0], It = M[1], Rt = M[2], Bt = M[3], N = M[4], Tt = M[5], Kt = M[6], $t = M[7], Pt = k[0], Ct = k[1], Ot = k[2], br = k[3], Qt = k[4], pr = k[5], yr = k[6], mr = k[7], Er = 0; b >= 128;) {
                    for (qe = 0; qe < 16; qe++) Se = 8 * qe + Er, P[qe] = R[Se + 0] << 24 | R[Se + 1] << 16 | R[Se + 2] << 8 | R[Se + 3], U[qe] = R[Se + 4] << 24 | R[Se + 5] << 16 | R[Se + 6] << 8 | R[Se + 7];
                    for (qe = 0; qe < 80; qe++)
                        if (j = wt, K = It, W = Rt, Pe = Bt, ne = N, Me = Tt, Ae = Kt, ut = $t, ht = Pt, pt = Ct, dt = Ot, yt = br, bt = Qt, mt = pr, ke = yr, at = mr, H = $t, V = mr, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = (N >>> 14 | Qt << 32 - 14) ^ (N >>> 18 | Qt << 32 - 18) ^ (Qt >>> 41 - 32 | N << 32 - (41 - 32)), V = (Qt >>> 14 | N << 32 - 14) ^ (Qt >>> 18 | N << 32 - 18) ^ (N >>> 41 - 32 | Qt << 32 - (41 - 32)), ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, H = N & Tt ^ ~N & Kt, V = Qt & pr ^ ~Qt & yr, ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, H = $r[qe * 2], V = $r[qe * 2 + 1], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, H = P[qe % 16], V = U[qe % 16], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, Ie = se & 65535 | ve << 16, Te = ye & 65535 | oe << 16, H = Ie, V = Te, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = (wt >>> 28 | Pt << 32 - 28) ^ (Pt >>> 34 - 32 | wt << 32 - (34 - 32)) ^ (Pt >>> 39 - 32 | wt << 32 - (39 - 32)), V = (Pt >>> 28 | wt << 32 - 28) ^ (wt >>> 34 - 32 | Pt << 32 - (34 - 32)) ^ (wt >>> 39 - 32 | Pt << 32 - (39 - 32)), ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, H = wt & It ^ wt & Rt ^ It & Rt, V = Pt & Ct ^ Pt & Ot ^ Ct & Ot, ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, ut = se & 65535 | ve << 16, at = ye & 65535 | oe << 16, H = Pe, V = yt, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = Ie, V = Te, ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, Pe = se & 65535 | ve << 16, yt = ye & 65535 | oe << 16, It = j, Rt = K, Bt = W, N = Pe, Tt = ne, Kt = Me, $t = Ae, wt = ut, Ct = ht, Ot = pt, br = dt, Qt = yt, pr = bt, yr = mt, mr = ke, Pt = at, qe % 16 === 15)
                            for (Se = 0; Se < 16; Se++) H = P[Se], V = U[Se], ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = P[(Se + 9) % 16], V = U[(Se + 9) % 16], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, Ie = P[(Se + 1) % 16], Te = U[(Se + 1) % 16], H = (Ie >>> 1 | Te << 32 - 1) ^ (Ie >>> 8 | Te << 32 - 8) ^ Ie >>> 7, V = (Te >>> 1 | Ie << 32 - 1) ^ (Te >>> 8 | Ie << 32 - 8) ^ (Te >>> 7 | Ie << 32 - 7), ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, Ie = P[(Se + 14) % 16], Te = U[(Se + 14) % 16], H = (Ie >>> 19 | Te << 32 - 19) ^ (Te >>> 61 - 32 | Ie << 32 - (61 - 32)) ^ Ie >>> 6, V = (Te >>> 19 | Ie << 32 - 19) ^ (Ie >>> 61 - 32 | Te << 32 - (61 - 32)) ^ (Te >>> 6 | Ie << 32 - 6), ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, P[Se] = se & 65535 | ve << 16, U[Se] = ye & 65535 | oe << 16;
                    H = wt, V = Pt, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = M[0], V = k[0], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, M[0] = wt = se & 65535 | ve << 16, k[0] = Pt = ye & 65535 | oe << 16, H = It, V = Ct, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = M[1], V = k[1], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, M[1] = It = se & 65535 | ve << 16, k[1] = Ct = ye & 65535 | oe << 16, H = Rt, V = Ot, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = M[2], V = k[2], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, M[2] = Rt = se & 65535 | ve << 16, k[2] = Ot = ye & 65535 | oe << 16, H = Bt, V = br, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = M[3], V = k[3], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, M[3] = Bt = se & 65535 | ve << 16, k[3] = br = ye & 65535 | oe << 16, H = N, V = Qt, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = M[4], V = k[4], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, M[4] = N = se & 65535 | ve << 16, k[4] = Qt = ye & 65535 | oe << 16, H = Tt, V = pr, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = M[5], V = k[5], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, M[5] = Tt = se & 65535 | ve << 16, k[5] = pr = ye & 65535 | oe << 16, H = Kt, V = yr, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = M[6], V = k[6], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, M[6] = Kt = se & 65535 | ve << 16, k[6] = yr = ye & 65535 | oe << 16, H = $t, V = mr, ye = V & 65535, oe = V >>> 16, se = H & 65535, ve = H >>> 16, H = M[7], V = k[7], ye += V & 65535, oe += V >>> 16, se += H & 65535, ve += H >>> 16, oe += ye >>> 16, se += oe >>> 16, ve += se >>> 16, M[7] = $t = se & 65535 | ve << 16, k[7] = mr = ye & 65535 | oe << 16, Er += 128, b -= 128
                }
                return b
            }

            function Le(M, k, R) {
                var b = new Int32Array(8),
                    P = new Int32Array(8),
                    U = new Uint8Array(256),
                    j, K = R;
                for (b[0] = 1779033703, b[1] = 3144134277, b[2] = 1013904242, b[3] = 2773480762, b[4] = 1359893119, b[5] = 2600822924, b[6] = 528734635, b[7] = 1541459225, P[0] = 4089235720, P[1] = 2227873595, P[2] = 4271175723, P[3] = 1595750129, P[4] = 2917565137, P[5] = 725511199, P[6] = 4215389547, P[7] = 327033209, Qe(b, P, k, R), R %= 128, j = 0; j < R; j++) U[j] = k[K - R + j];
                for (U[R] = 128, R = 256 - 128 * (R < 112 ? 1 : 0), U[R - 9] = 0, L(U, R - 8, K / 536870912 | 0, K << 3), Qe(b, P, U, R), j = 0; j < 8; j++) L(M, 8 * j, b[j], P[j]);
                return 0
            }

            function Ar(M, k) {
                var R = e(),
                    b = e(),
                    P = e(),
                    U = e(),
                    j = e(),
                    K = e(),
                    W = e(),
                    Pe = e(),
                    ne = e();
                _(R, M[1], M[0]), _(ne, k[1], k[0]), F(R, R, ne), u(b, M[0], M[1]), u(ne, k[0], k[1]), F(b, b, ne), F(P, M[3], k[3]), F(P, P, E), F(U, M[2], k[2]), u(U, U, U), _(j, b, R), _(K, U, P), u(W, U, P), u(Pe, b, R), F(M[0], j, K), F(M[1], Pe, W), F(M[2], W, K), F(M[3], j, Pe)
            }

            function et(M, k, R) {
                var b;
                for (b = 0; b < 4; b++) p(M[b], k[b], R)
            }

            function je(M, k) {
                var R = e(),
                    b = e(),
                    P = e();
                z(P, k[2]), F(R, k[0], P), F(b, k[1], P), d(M, b), M[31] ^= x(R) << 7
            }

            function Ur(M, k, R) {
                var b, P;
                for (f(M[0], o), f(M[1], a), f(M[2], a), f(M[3], o), P = 255; P >= 0; --P) b = R[P / 8 | 0] >> (P & 7) & 1, et(M, k, b), Ar(k, M), Ar(M, M), et(M, k, b)
            }

            function De(M, k) {
                var R = [e(), e(), e(), e()];
                f(R[0], A), f(R[1], I), f(R[2], a), F(R[3], A, I), Ur(M, R, k)
            }

            function We(M, k, R) {
                var b = new Uint8Array(64),
                    P = [e(), e(), e(), e()],
                    U;
                for (R || t(k, 32), Le(b, k, 32), b[0] &= 248, b[31] &= 127, b[31] |= 64, De(P, b), je(M, P), U = 0; U < 32; U++) k[U + 32] = M[U];
                return 0
            }
            var Ir = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

            function He(M, k) {
                var R, b, P, U;
                for (b = 63; b >= 32; --b) {
                    for (R = 0, P = b - 32, U = b - 12; P < U; ++P) k[P] += R - 16 * k[b] * Ir[P - (b - 32)], R = Math.floor((k[P] + 128) / 256), k[P] -= R * 256;
                    k[P] += R, k[b] = 0
                }
                for (R = 0, P = 0; P < 32; P++) k[P] += R - (k[31] >> 4) * Ir[P], R = k[P] >> 8, k[P] &= 255;
                for (P = 0; P < 32; P++) k[P] -= R * Ir[P];
                for (b = 0; b < 32; b++) k[b + 1] += k[b] >> 8, M[b] = k[b] & 255
            }

            function Ve(M) {
                var k = new Float64Array(64),
                    R;
                for (R = 0; R < 64; R++) k[R] = M[R];
                for (R = 0; R < 64; R++) M[R] = 0;
                He(M, k)
            }

            function jr(M, k, R, b) {
                var P = new Uint8Array(64),
                    U = new Uint8Array(64),
                    j = new Uint8Array(64),
                    K, W, Pe = new Float64Array(64),
                    ne = [e(), e(), e(), e()];
                Le(P, b, 32), P[0] &= 248, P[31] &= 127, P[31] |= 64;
                var Me = R + 64;
                for (K = 0; K < R; K++) M[64 + K] = k[K];
                for (K = 0; K < 32; K++) M[32 + K] = P[32 + K];
                for (Le(j, M.subarray(32), R + 32), Ve(j), De(ne, j), je(M, ne), K = 32; K < 64; K++) M[K] = b[K];
                for (Le(U, M, R + 64), Ve(U), K = 0; K < 64; K++) Pe[K] = 0;
                for (K = 0; K < 32; K++) Pe[K] = j[K];
                for (K = 0; K < 32; K++)
                    for (W = 0; W < 32; W++) Pe[K + W] += U[K] * P[W];
                return He(M.subarray(32), Pe), Me
            }

            function it(M, k) {
                var R = e(),
                    b = e(),
                    P = e(),
                    U = e(),
                    j = e(),
                    K = e(),
                    W = e();
                return f(M[2], a), v(M[1], k), S(P, M[1]), F(U, P, g), _(P, P, M[2]), u(U, M[2], U), S(j, U), S(K, j), F(W, K, j), F(R, W, P), F(R, R, U), C(R, R), F(R, R, P), F(R, R, U), F(R, R, U), F(M[0], R, U), S(b, M[0]), F(b, b, U), c(b, P) && F(M[0], M[0], q), S(b, M[0]), F(b, b, U), c(b, P) ? -1 : (x(M[0]) === k[31] >> 7 && _(M[0], o, M[0]), F(M[3], M[0], M[1]), 0)
            }

            function Ge(M, k, R, b) {
                var P, U = new Uint8Array(32),
                    j = new Uint8Array(64),
                    K = [e(), e(), e(), e()],
                    W = [e(), e(), e(), e()];
                if (R < 64 || it(W, b)) return -1;
                for (P = 0; P < R; P++) M[P] = k[P];
                for (P = 0; P < 32; P++) M[P + 32] = b[P];
                if (Le(j, M, R), Ve(j), Ur(K, W, j), De(W, k.subarray(32)), Ar(K, W), je(U, K), R -= 64, ge(k, 0, U, 0)) {
                    for (P = 0; P < R; P++) M[P] = 0;
                    return -1
                }
                for (P = 0; P < R; P++) M[P] = k[P + 64];
                return R
            }
            var Nr = 32,
                Ke = 24,
                Fe = 32,
                vr = 16,
                Ce = 32,
                $e = 32,
                _r = 32,
                Oe = 32,
                Ze = 32,
                Wr = Ke,
                ot = Fe,
                st = vr,
                dr = 64,
                ze = 32,
                Ne = 64,
                qr = 32,
                Ye = 64;
            r.lowlevel = {
                crypto_core_hsalsa20: ie,
                crypto_stream_xor: gt,
                crypto_stream: he,
                crypto_stream_salsa20_xor: be,
                crypto_stream_salsa20: we,
                crypto_onetimeauth: m,
                crypto_onetimeauth_verify: w,
                crypto_verify_16: Z,
                crypto_verify_32: ge,
                crypto_secretbox: l,
                crypto_secretbox_open: s,
                crypto_scalarmult: D,
                crypto_scalarmult_base: Y,
                crypto_box_beforenm: ee,
                crypto_box_afternm: re,
                crypto_box: me,
                crypto_box_open: Ee,
                crypto_box_keypair: Re,
                crypto_hash: Le,
                crypto_sign: jr,
                crypto_sign_keypair: We,
                crypto_sign_open: Ge,
                crypto_secretbox_KEYBYTES: Nr,
                crypto_secretbox_NONCEBYTES: Ke,
                crypto_secretbox_ZEROBYTES: Fe,
                crypto_secretbox_BOXZEROBYTES: vr,
                crypto_scalarmult_BYTES: Ce,
                crypto_scalarmult_SCALARBYTES: $e,
                crypto_box_PUBLICKEYBYTES: _r,
                crypto_box_SECRETKEYBYTES: Oe,
                crypto_box_BEFORENMBYTES: Ze,
                crypto_box_NONCEBYTES: Wr,
                crypto_box_ZEROBYTES: ot,
                crypto_box_BOXZEROBYTES: st,
                crypto_sign_BYTES: dr,
                crypto_sign_PUBLICKEYBYTES: ze,
                crypto_sign_SECRETKEYBYTES: Ne,
                crypto_sign_SEEDBYTES: qr,
                crypto_hash_BYTES: Ye,
                gf: e,
                D: g,
                L: Ir,
                pack25519: d,
                unpack25519: v,
                M: F,
                A: u,
                S,
                Z: _,
                pow2523: C,
                add: Ar,
                set25519: f,
                modL: He,
                scalarmult: Ur,
                scalarbase: De
            };

            function tt(M, k) {
                if (M.length !== Nr) throw new Error("bad key size");
                if (k.length !== Ke) throw new Error("bad nonce size")
            }

            function nn(M, k) {
                if (M.length !== _r) throw new Error("bad public key size");
                if (k.length !== Oe) throw new Error("bad secret key size")
            }

            function Be() {
                for (var M = 0; M < arguments.length; M++)
                    if (!(arguments[M] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array")
            }

            function rt(M) {
                for (var k = 0; k < M.length; k++) M[k] = 0
            }
            r.randomBytes = function(M) {
                    var k = new Uint8Array(M);
                    return t(k, M), k
                }, r.secretbox = function(M, k, R) {
                    Be(M, k, R), tt(R, k);
                    for (var b = new Uint8Array(Fe + M.length), P = new Uint8Array(b.length), U = 0; U < M.length; U++) b[U + Fe] = M[U];
                    return l(P, b, b.length, k, R), P.subarray(vr)
                }, r.secretbox.open = function(M, k, R) {
                    Be(M, k, R), tt(R, k);
                    for (var b = new Uint8Array(vr + M.length), P = new Uint8Array(b.length), U = 0; U < M.length; U++) b[U + vr] = M[U];
                    return b.length < 32 || s(P, b, b.length, k, R) !== 0 ? null : P.subarray(Fe)
                }, r.secretbox.keyLength = Nr, r.secretbox.nonceLength = Ke, r.secretbox.overheadLength = vr, r.scalarMult = function(M, k) {
                    if (Be(M, k), M.length !== $e) throw new Error("bad n size");
                    if (k.length !== Ce) throw new Error("bad p size");
                    var R = new Uint8Array(Ce);
                    return D(R, M, k), R
                }, r.scalarMult.base = function(M) {
                    if (Be(M), M.length !== $e) throw new Error("bad n size");
                    var k = new Uint8Array(Ce);
                    return Y(k, M), k
                }, r.scalarMult.scalarLength = $e, r.scalarMult.groupElementLength = Ce, r.box = function(M, k, R, b) {
                    var P = r.box.before(R, b);
                    return r.secretbox(M, k, P)
                }, r.box.before = function(M, k) {
                    Be(M, k), nn(M, k);
                    var R = new Uint8Array(Ze);
                    return ee(R, M, k), R
                }, r.box.after = r.secretbox, r.box.open = function(M, k, R, b) {
                    var P = r.box.before(R, b);
                    return r.secretbox.open(M, k, P)
                }, r.box.open.after = r.secretbox.open, r.box.keyPair = function() {
                    var M = new Uint8Array(_r),
                        k = new Uint8Array(Oe);
                    return Re(M, k), {
                        publicKey: M,
                        secretKey: k
                    }
                }, r.box.keyPair.fromSecretKey = function(M) {
                    if (Be(M), M.length !== Oe) throw new Error("bad secret key size");
                    var k = new Uint8Array(_r);
                    return Y(k, M), {
                        publicKey: k,
                        secretKey: new Uint8Array(M)
                    }
                }, r.box.publicKeyLength = _r, r.box.secretKeyLength = Oe, r.box.sharedKeyLength = Ze, r.box.nonceLength = Wr, r.box.overheadLength = r.secretbox.overheadLength, r.sign = function(M, k) {
                    if (Be(M, k), k.length !== Ne) throw new Error("bad secret key size");
                    var R = new Uint8Array(dr + M.length);
                    return jr(R, M, M.length, k), R
                }, r.sign.open = function(M, k) {
                    if (Be(M, k), k.length !== ze) throw new Error("bad public key size");
                    var R = new Uint8Array(M.length),
                        b = Ge(R, M, M.length, k);
                    if (b < 0) return null;
                    for (var P = new Uint8Array(b), U = 0; U < P.length; U++) P[U] = R[U];
                    return P
                }, r.sign.detached = function(M, k) {
                    for (var R = r.sign(M, k), b = new Uint8Array(dr), P = 0; P < b.length; P++) b[P] = R[P];
                    return b
                }, r.sign.detached.verify = function(M, k, R) {
                    if (Be(M, k, R), k.length !== dr) throw new Error("bad signature size");
                    if (R.length !== ze) throw new Error("bad public key size");
                    var b = new Uint8Array(dr + M.length),
                        P = new Uint8Array(dr + M.length),
                        U;
                    for (U = 0; U < dr; U++) b[U] = k[U];
                    for (U = 0; U < M.length; U++) b[U + dr] = M[U];
                    return Ge(P, b, b.length, R) >= 0
                }, r.sign.keyPair = function() {
                    var M = new Uint8Array(ze),
                        k = new Uint8Array(Ne);
                    return We(M, k), {
                        publicKey: M,
                        secretKey: k
                    }
                }, r.sign.keyPair.fromSecretKey = function(M) {
                    if (Be(M), M.length !== Ne) throw new Error("bad secret key size");
                    for (var k = new Uint8Array(ze), R = 0; R < k.length; R++) k[R] = M[32 + R];
                    return {
                        publicKey: k,
                        secretKey: new Uint8Array(M)
                    }
                }, r.sign.keyPair.fromSeed = function(M) {
                    if (Be(M), M.length !== qr) throw new Error("bad seed size");
                    for (var k = new Uint8Array(ze), R = new Uint8Array(Ne), b = 0; b < 32; b++) R[b] = M[b];
                    return We(k, R, !0), {
                        publicKey: k,
                        secretKey: R
                    }
                }, r.sign.publicKeyLength = ze, r.sign.secretKeyLength = Ne, r.sign.seedLength = qr, r.sign.signatureLength = dr, r.hash = function(M) {
                    Be(M);
                    var k = new Uint8Array(Ye);
                    return Le(k, M, M.length), k
                }, r.hash.hashLength = Ye, r.verify = function(M, k) {
                    return Be(M, k), M.length === 0 || k.length === 0 || M.length !== k.length ? !1 : O(M, 0, k, 0, M.length) === 0
                }, r.setPRNG = function(M) {
                    t = M
                },
                function() {
                    var M = typeof self < "u" ? self.crypto || self.msCrypto : null;
                    if (M && M.getRandomValues) {
                        var k = 65536;
                        r.setPRNG(function(R, b) {
                            var P, U = new Uint8Array(b);
                            for (P = 0; P < b; P += k) M.getRandomValues(U.subarray(P, P + Math.min(b - P, k)));
                            for (P = 0; P < b; P++) R[P] = U[P];
                            rt(U)
                        })
                    } else typeof nd < "u" && (M = Jh(), M && M.randomBytes && r.setPRNG(function(R, b) {
                        var P, U = M.randomBytes(b);
                        for (P = 0; P < b; P++) R[P] = U[P];
                        rt(U)
                    }))
                }()
        })(typeof Ru < "u" && Ru.exports ? Ru.exports : self.nacl = self.nacl || {})
    });
    var a0 = Ue(vs => {
        "use strict";
        var Qh = ca(),
            bs = ha(),
            Fg = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        vs.Buffer = J;
        vs.SlowBuffer = q4;
        vs.INSPECT_MAX_BYTES = 50;
        var ku = 2147483647;
        vs.kMaxLength = ku;
        J.TYPED_ARRAY_SUPPORT = T4();
        !J.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

        function T4() {
            try {
                let r = new Uint8Array(1),
                    e = {
                        foo: function() {
                            return 42
                        }
                    };
                return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42
            } catch {
                return !1
            }
        }
        Object.defineProperty(J.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (!!J.isBuffer(this)) return this.buffer
            }
        });
        Object.defineProperty(J.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (!!J.isBuffer(this)) return this.byteOffset
            }
        });

        function Ui(r) {
            if (r > ku) throw new RangeError('The value "' + r + '" is invalid for option "size"');
            let e = new Uint8Array(r);
            return Object.setPrototypeOf(e, J.prototype), e
        }

        function J(r, e, t) {
            if (typeof r == "number") {
                if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
                return n0(r)
            }
            return Kg(r, e, t)
        }
        J.poolSize = 8192;

        function Kg(r, e, t) {
            if (typeof r == "string") return z4(r, e);
            if (ArrayBuffer.isView(r)) return U4(r);
            if (r == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
            if (oi(r, ArrayBuffer) || r && oi(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (oi(r, SharedArrayBuffer) || r && oi(r.buffer, SharedArrayBuffer))) return t0(r, e, t);
            if (typeof r == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
            let n = r.valueOf && r.valueOf();
            if (n != null && n !== r) return J.from(n, e, t);
            let i = N4(r);
            if (i) return i;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function") return J.from(r[Symbol.toPrimitive]("string"), e, t);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r)
        }
        J.from = function(r, e, t) {
            return Kg(r, e, t)
        };
        Object.setPrototypeOf(J.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(J, Uint8Array);

        function $g(r) {
            if (typeof r != "number") throw new TypeError('"size" argument must be of type number');
            if (r < 0) throw new RangeError('The value "' + r + '" is invalid for option "size"')
        }

        function L4(r, e, t) {
            return $g(r), r <= 0 ? Ui(r) : e !== void 0 ? typeof t == "string" ? Ui(r).fill(e, t) : Ui(r).fill(e) : Ui(r)
        }
        J.alloc = function(r, e, t) {
            return L4(r, e, t)
        };

        function n0(r) {
            return $g(r), Ui(r < 0 ? 0 : i0(r) | 0)
        }
        J.allocUnsafe = function(r) {
            return n0(r)
        };
        J.allocUnsafeSlow = function(r) {
            return n0(r)
        };

        function z4(r, e) {
            if ((typeof e != "string" || e === "") && (e = "utf8"), !J.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            let t = jg(r, e) | 0,
                n = Ui(t),
                i = n.write(r, e);
            return i !== t && (n = n.slice(0, i)), n
        }

        function e0(r) {
            let e = r.length < 0 ? 0 : i0(r.length) | 0,
                t = Ui(e);
            for (let n = 0; n < e; n += 1) t[n] = r[n] & 255;
            return t
        }

        function U4(r) {
            if (oi(r, Uint8Array)) {
                let e = new Uint8Array(r);
                return t0(e.buffer, e.byteOffset, e.byteLength)
            }
            return e0(r)
        }

        function t0(r, e, t) {
            if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
            if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
            let n;
            return e === void 0 && t === void 0 ? n = new Uint8Array(r) : t === void 0 ? n = new Uint8Array(r, e) : n = new Uint8Array(r, e, t), Object.setPrototypeOf(n, J.prototype), n
        }

        function N4(r) {
            if (J.isBuffer(r)) {
                let e = i0(r.length) | 0,
                    t = Ui(e);
                return t.length === 0 || r.copy(t, 0, 0, e), t
            }
            if (r.length !== void 0) return typeof r.length != "number" || s0(r.length) ? Ui(0) : e0(r);
            if (r.type === "Buffer" && Array.isArray(r.data)) return e0(r.data)
        }

        function i0(r) {
            if (r >= ku) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ku.toString(16) + " bytes");
            return r | 0
        }

        function q4(r) {
            return +r != r && (r = 0), J.alloc(+r)
        }
        J.isBuffer = function(e) {
            return e != null && e._isBuffer === !0 && e !== J.prototype
        };
        J.compare = function(e, t) {
            if (oi(e, Uint8Array) && (e = J.from(e, e.offset, e.byteLength)), oi(t, Uint8Array) && (t = J.from(t, t.offset, t.byteLength)), !J.isBuffer(e) || !J.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (e === t) return 0;
            let n = e.length,
                i = t.length;
            for (let o = 0, a = Math.min(n, i); o < a; ++o)
                if (e[o] !== t[o]) {
                    n = e[o], i = t[o];
                    break
                } return n < i ? -1 : i < n ? 1 : 0
        };
        J.isEncoding = function(e) {
            switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
            }
        };
        J.concat = function(e, t) {
            if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (e.length === 0) return J.alloc(0);
            let n;
            if (t === void 0)
                for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
            let i = J.allocUnsafe(t),
                o = 0;
            for (n = 0; n < e.length; ++n) {
                let a = e[n];
                if (oi(a, Uint8Array)) o + a.length > i.length ? (J.isBuffer(a) || (a = J.from(a)), a.copy(i, o)) : Uint8Array.prototype.set.call(i, a, o);
                else if (J.isBuffer(a)) a.copy(i, o);
                else throw new TypeError('"list" argument must be an Array of Buffers');
                o += a.length
            }
            return i
        };

        function jg(r, e) {
            if (J.isBuffer(r)) return r.length;
            if (ArrayBuffer.isView(r) || oi(r, ArrayBuffer)) return r.byteLength;
            if (typeof r != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r);
            let t = r.length,
                n = arguments.length > 2 && arguments[2] === !0;
            if (!n && t === 0) return 0;
            let i = !1;
            for (;;) switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                    return t;
                case "utf8":
                case "utf-8":
                    return r0(r).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return t * 2;
                case "hex":
                    return t >>> 1;
                case "base64":
                    return Qg(r).length;
                default:
                    if (i) return n ? -1 : r0(r).length;
                    e = ("" + e).toLowerCase(), i = !0
            }
        }
        J.byteLength = jg;

        function F4(r, e, t) {
            let n = !1;
            if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e)) return "";
            for (r || (r = "utf8");;) switch (r) {
                case "hex":
                    return G4(this, e, t);
                case "utf8":
                case "utf-8":
                    return Hg(this, e, t);
                case "ascii":
                    return H4(this, e, t);
                case "latin1":
                case "binary":
                    return V4(this, e, t);
                case "base64":
                    return j4(this, e, t);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return Z4(this, e, t);
                default:
                    if (n) throw new TypeError("Unknown encoding: " + r);
                    r = (r + "").toLowerCase(), n = !0
            }
        }
        J.prototype._isBuffer = !0;

        function zo(r, e, t) {
            let n = r[e];
            r[e] = r[t], r[t] = n
        }
        J.prototype.swap16 = function() {
            let e = this.length;
            if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let t = 0; t < e; t += 2) zo(this, t, t + 1);
            return this
        };
        J.prototype.swap32 = function() {
            let e = this.length;
            if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let t = 0; t < e; t += 4) zo(this, t, t + 3), zo(this, t + 1, t + 2);
            return this
        };
        J.prototype.swap64 = function() {
            let e = this.length;
            if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let t = 0; t < e; t += 8) zo(this, t, t + 7), zo(this, t + 1, t + 6), zo(this, t + 2, t + 5), zo(this, t + 3, t + 4);
            return this
        };
        J.prototype.toString = function() {
            let e = this.length;
            return e === 0 ? "" : arguments.length === 0 ? Hg(this, 0, e) : F4.apply(this, arguments)
        };
        J.prototype.toLocaleString = J.prototype.toString;
        J.prototype.equals = function(e) {
            if (!J.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
            return this === e ? !0 : J.compare(this, e) === 0
        };
        J.prototype.inspect = function() {
            let e = "",
                t = vs.INSPECT_MAX_BYTES;
            return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">"
        };
        Fg && (J.prototype[Fg] = J.prototype.inspect);
        J.prototype.compare = function(e, t, n, i, o) {
            if (oi(e, Uint8Array) && (e = J.from(e, e.offset, e.byteLength)), !J.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
            if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), o === void 0 && (o = this.length), t < 0 || n > e.length || i < 0 || o > this.length) throw new RangeError("out of range index");
            if (i >= o && t >= n) return 0;
            if (i >= o) return -1;
            if (t >= n) return 1;
            if (t >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === e) return 0;
            let a = o - i,
                y = n - t,
                g = Math.min(a, y),
                E = this.slice(i, o),
                A = e.slice(t, n);
            for (let I = 0; I < g; ++I)
                if (E[I] !== A[I]) {
                    a = E[I], y = A[I];
                    break
                } return a < y ? -1 : y < a ? 1 : 0
        };

        function Wg(r, e, t, n, i) {
            if (r.length === 0) return -1;
            if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, s0(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
                if (i) return -1;
                t = r.length - 1
            } else if (t < 0)
                if (i) t = 0;
                else return -1;
            if (typeof e == "string" && (e = J.from(e, n)), J.isBuffer(e)) return e.length === 0 ? -1 : Cg(r, e, t, n, i);
            if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : Cg(r, [e], t, n, i);
            throw new TypeError("val must be string, number or Buffer")
        }

        function Cg(r, e, t, n, i) {
            let o = 1,
                a = r.length,
                y = e.length;
            if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
                if (r.length < 2 || e.length < 2) return -1;
                o = 2, a /= 2, y /= 2, t /= 2
            }

            function g(A, I) {
                return o === 1 ? A[I] : A.readUInt16BE(I * o)
            }
            let E;
            if (i) {
                let A = -1;
                for (E = t; E < a; E++)
                    if (g(r, E) === g(e, A === -1 ? 0 : E - A)) {
                        if (A === -1 && (A = E), E - A + 1 === y) return A * o
                    } else A !== -1 && (E -= E - A), A = -1
            } else
                for (t + y > a && (t = a - y), E = t; E >= 0; E--) {
                    let A = !0;
                    for (let I = 0; I < y; I++)
                        if (g(r, E + I) !== g(e, I)) {
                            A = !1;
                            break
                        } if (A) return E
                }
            return -1
        }
        J.prototype.includes = function(e, t, n) {
            return this.indexOf(e, t, n) !== -1
        };
        J.prototype.indexOf = function(e, t, n) {
            return Wg(this, e, t, n, !0)
        };
        J.prototype.lastIndexOf = function(e, t, n) {
            return Wg(this, e, t, n, !1)
        };

        function C4(r, e, t, n) {
            t = Number(t) || 0;
            let i = r.length - t;
            n ? (n = Number(n), n > i && (n = i)) : n = i;
            let o = e.length;
            n > o / 2 && (n = o / 2);
            let a;
            for (a = 0; a < n; ++a) {
                let y = parseInt(e.substr(a * 2, 2), 16);
                if (s0(y)) return a;
                r[t + a] = y
            }
            return a
        }

        function O4(r, e, t, n) {
            return Pu(r0(e, r.length - t), r, t, n)
        }

        function D4(r, e, t, n) {
            return Pu(Q4(e), r, t, n)
        }

        function K4(r, e, t, n) {
            return Pu(Qg(e), r, t, n)
        }

        function $4(r, e, t, n) {
            return Pu(e5(e, r.length - t), r, t, n)
        }
        J.prototype.write = function(e, t, n, i) {
            if (t === void 0) i = "utf8", n = this.length, t = 0;
            else if (n === void 0 && typeof t == "string") i = t, n = this.length, t = 0;
            else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
            else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            let o = this.length - t;
            if ((n === void 0 || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            i || (i = "utf8");
            let a = !1;
            for (;;) switch (i) {
                case "hex":
                    return C4(this, e, t, n);
                case "utf8":
                case "utf-8":
                    return O4(this, e, t, n);
                case "ascii":
                case "latin1":
                case "binary":
                    return D4(this, e, t, n);
                case "base64":
                    return K4(this, e, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return $4(this, e, t, n);
                default:
                    if (a) throw new TypeError("Unknown encoding: " + i);
                    i = ("" + i).toLowerCase(), a = !0
            }
        };
        J.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        };

        function j4(r, e, t) {
            return e === 0 && t === r.length ? Qh.fromByteArray(r) : Qh.fromByteArray(r.slice(e, t))
        }

        function Hg(r, e, t) {
            t = Math.min(r.length, t);
            let n = [],
                i = e;
            for (; i < t;) {
                let o = r[i],
                    a = null,
                    y = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
                if (i + y <= t) {
                    let g, E, A, I;
                    switch (y) {
                        case 1:
                            o < 128 && (a = o);
                            break;
                        case 2:
                            g = r[i + 1], (g & 192) === 128 && (I = (o & 31) << 6 | g & 63, I > 127 && (a = I));
                            break;
                        case 3:
                            g = r[i + 1], E = r[i + 2], (g & 192) === 128 && (E & 192) === 128 && (I = (o & 15) << 12 | (g & 63) << 6 | E & 63, I > 2047 && (I < 55296 || I > 57343) && (a = I));
                            break;
                        case 4:
                            g = r[i + 1], E = r[i + 2], A = r[i + 3], (g & 192) === 128 && (E & 192) === 128 && (A & 192) === 128 && (I = (o & 15) << 18 | (g & 63) << 12 | (E & 63) << 6 | A & 63, I > 65535 && I < 1114112 && (a = I))
                    }
                }
                a === null ? (a = 65533, y = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), n.push(a), i += y
            }
            return W4(n)
        }
        var Og = 4096;

        function W4(r) {
            let e = r.length;
            if (e <= Og) return String.fromCharCode.apply(String, r);
            let t = "",
                n = 0;
            for (; n < e;) t += String.fromCharCode.apply(String, r.slice(n, n += Og));
            return t
        }

        function H4(r, e, t) {
            let n = "";
            t = Math.min(r.length, t);
            for (let i = e; i < t; ++i) n += String.fromCharCode(r[i] & 127);
            return n
        }

        function V4(r, e, t) {
            let n = "";
            t = Math.min(r.length, t);
            for (let i = e; i < t; ++i) n += String.fromCharCode(r[i]);
            return n
        }

        function G4(r, e, t) {
            let n = r.length;
            (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
            let i = "";
            for (let o = e; o < t; ++o) i += t5[r[o]];
            return i
        }

        function Z4(r, e, t) {
            let n = r.slice(e, t),
                i = "";
            for (let o = 0; o < n.length - 1; o += 2) i += String.fromCharCode(n[o] + n[o + 1] * 256);
            return i
        }
        J.prototype.slice = function(e, t) {
            let n = this.length;
            e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
            let i = this.subarray(e, t);
            return Object.setPrototypeOf(i, J.prototype), i
        };

        function Rr(r, e, t) {
            if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
            if (r + e > t) throw new RangeError("Trying to access beyond buffer length")
        }
        J.prototype.readUintLE = J.prototype.readUIntLE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || Rr(e, t, this.length);
            let i = this[e],
                o = 1,
                a = 0;
            for (; ++a < t && (o *= 256);) i += this[e + a] * o;
            return i
        };
        J.prototype.readUintBE = J.prototype.readUIntBE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || Rr(e, t, this.length);
            let i = this[e + --t],
                o = 1;
            for (; t > 0 && (o *= 256);) i += this[e + --t] * o;
            return i
        };
        J.prototype.readUint8 = J.prototype.readUInt8 = function(e, t) {
            return e = e >>> 0, t || Rr(e, 1, this.length), this[e]
        };
        J.prototype.readUint16LE = J.prototype.readUInt16LE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 2, this.length), this[e] | this[e + 1] << 8
        };
        J.prototype.readUint16BE = J.prototype.readUInt16BE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 2, this.length), this[e] << 8 | this[e + 1]
        };
        J.prototype.readUint32LE = J.prototype.readUInt32LE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216
        };
        J.prototype.readUint32BE = J.prototype.readUInt32BE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
        };
        J.prototype.readBigUInt64LE = no(function(e) {
            e = e >>> 0, xs(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && ya(e, this.length - 8);
            let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24,
                o = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24;
            return BigInt(i) + (BigInt(o) << BigInt(32))
        });
        J.prototype.readBigUInt64BE = no(function(e) {
            e = e >>> 0, xs(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && ya(e, this.length - 8);
            let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e],
                o = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n;
            return (BigInt(i) << BigInt(32)) + BigInt(o)
        });
        J.prototype.readIntLE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || Rr(e, t, this.length);
            let i = this[e],
                o = 1,
                a = 0;
            for (; ++a < t && (o *= 256);) i += this[e + a] * o;
            return o *= 128, i >= o && (i -= Math.pow(2, 8 * t)), i
        };
        J.prototype.readIntBE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || Rr(e, t, this.length);
            let i = t,
                o = 1,
                a = this[e + --i];
            for (; i > 0 && (o *= 256);) a += this[e + --i] * o;
            return o *= 128, a >= o && (a -= Math.pow(2, 8 * t)), a
        };
        J.prototype.readInt8 = function(e, t) {
            return e = e >>> 0, t || Rr(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
        };
        J.prototype.readInt16LE = function(e, t) {
            e = e >>> 0, t || Rr(e, 2, this.length);
            let n = this[e] | this[e + 1] << 8;
            return n & 32768 ? n | 4294901760 : n
        };
        J.prototype.readInt16BE = function(e, t) {
            e = e >>> 0, t || Rr(e, 2, this.length);
            let n = this[e + 1] | this[e] << 8;
            return n & 32768 ? n | 4294901760 : n
        };
        J.prototype.readInt32LE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
        };
        J.prototype.readInt32BE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
        };
        J.prototype.readBigInt64LE = no(function(e) {
            e = e >>> 0, xs(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && ya(e, this.length - 8);
            let i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24);
            return (BigInt(i) << BigInt(32)) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
        });
        J.prototype.readBigInt64BE = no(function(e) {
            e = e >>> 0, xs(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && ya(e, this.length - 8);
            let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
            return (BigInt(i) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n)
        });
        J.prototype.readFloatLE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 4, this.length), bs.read(this, e, !0, 23, 4)
        };
        J.prototype.readFloatBE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 4, this.length), bs.read(this, e, !1, 23, 4)
        };
        J.prototype.readDoubleLE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 8, this.length), bs.read(this, e, !0, 52, 8)
        };
        J.prototype.readDoubleBE = function(e, t) {
            return e = e >>> 0, t || Rr(e, 8, this.length), bs.read(this, e, !1, 52, 8)
        };

        function dn(r, e, t, n, i, o) {
            if (!J.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > i || e < o) throw new RangeError('"value" argument is out of bounds');
            if (t + n > r.length) throw new RangeError("Index out of range")
        }
        J.prototype.writeUintLE = J.prototype.writeUIntLE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
                let y = Math.pow(2, 8 * n) - 1;
                dn(this, e, t, n, y, 0)
            }
            let o = 1,
                a = 0;
            for (this[t] = e & 255; ++a < n && (o *= 256);) this[t + a] = e / o & 255;
            return t + n
        };
        J.prototype.writeUintBE = J.prototype.writeUIntBE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
                let y = Math.pow(2, 8 * n) - 1;
                dn(this, e, t, n, y, 0)
            }
            let o = n - 1,
                a = 1;
            for (this[t + o] = e & 255; --o >= 0 && (a *= 256);) this[t + o] = e / a & 255;
            return t + n
        };
        J.prototype.writeUint8 = J.prototype.writeUInt8 = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1
        };
        J.prototype.writeUint16LE = J.prototype.writeUInt16LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
        };
        J.prototype.writeUint16BE = J.prototype.writeUInt16BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
        };
        J.prototype.writeUint32LE = J.prototype.writeUInt32LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4
        };
        J.prototype.writeUint32BE = J.prototype.writeUInt32BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
        };

        function Vg(r, e, t, n, i) {
            Xg(e, n, i, r, t, 7);
            let o = Number(e & BigInt(4294967295));
            r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o;
            let a = Number(e >> BigInt(32) & BigInt(4294967295));
            return r[t++] = a, a = a >> 8, r[t++] = a, a = a >> 8, r[t++] = a, a = a >> 8, r[t++] = a, t
        }

        function Gg(r, e, t, n, i) {
            Xg(e, n, i, r, t, 7);
            let o = Number(e & BigInt(4294967295));
            r[t + 7] = o, o = o >> 8, r[t + 6] = o, o = o >> 8, r[t + 5] = o, o = o >> 8, r[t + 4] = o;
            let a = Number(e >> BigInt(32) & BigInt(4294967295));
            return r[t + 3] = a, a = a >> 8, r[t + 2] = a, a = a >> 8, r[t + 1] = a, a = a >> 8, r[t] = a, t + 8
        }
        J.prototype.writeBigUInt64LE = no(function(e, t = 0) {
            return Vg(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
        });
        J.prototype.writeBigUInt64BE = no(function(e, t = 0) {
            return Gg(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
        });
        J.prototype.writeIntLE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, !i) {
                let g = Math.pow(2, 8 * n - 1);
                dn(this, e, t, n, g - 1, -g)
            }
            let o = 0,
                a = 1,
                y = 0;
            for (this[t] = e & 255; ++o < n && (a *= 256);) e < 0 && y === 0 && this[t + o - 1] !== 0 && (y = 1), this[t + o] = (e / a >> 0) - y & 255;
            return t + n
        };
        J.prototype.writeIntBE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, !i) {
                let g = Math.pow(2, 8 * n - 1);
                dn(this, e, t, n, g - 1, -g)
            }
            let o = n - 1,
                a = 1,
                y = 0;
            for (this[t + o] = e & 255; --o >= 0 && (a *= 256);) e < 0 && y === 0 && this[t + o + 1] !== 0 && (y = 1), this[t + o] = (e / a >> 0) - y & 255;
            return t + n
        };
        J.prototype.writeInt8 = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1
        };
        J.prototype.writeInt16LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
        };
        J.prototype.writeInt16BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
        };
        J.prototype.writeInt32LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
        };
        J.prototype.writeInt32BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || dn(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
        };
        J.prototype.writeBigInt64LE = no(function(e, t = 0) {
            return Vg(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        });
        J.prototype.writeBigInt64BE = no(function(e, t = 0) {
            return Gg(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        });

        function Zg(r, e, t, n, i, o) {
            if (t + n > r.length) throw new RangeError("Index out of range");
            if (t < 0) throw new RangeError("Index out of range")
        }

        function Yg(r, e, t, n, i) {
            return e = +e, t = t >>> 0, i || Zg(r, e, t, 4, 34028234663852886e22, -34028234663852886e22), bs.write(r, e, t, n, 23, 4), t + 4
        }
        J.prototype.writeFloatLE = function(e, t, n) {
            return Yg(this, e, t, !0, n)
        };
        J.prototype.writeFloatBE = function(e, t, n) {
            return Yg(this, e, t, !1, n)
        };

        function Jg(r, e, t, n, i) {
            return e = +e, t = t >>> 0, i || Zg(r, e, t, 8, 17976931348623157e292, -17976931348623157e292), bs.write(r, e, t, n, 52, 8), t + 8
        }
        J.prototype.writeDoubleLE = function(e, t, n) {
            return Jg(this, e, t, !0, n)
        };
        J.prototype.writeDoubleBE = function(e, t, n) {
            return Jg(this, e, t, !1, n)
        };
        J.prototype.copy = function(e, t, n, i) {
            if (!J.isBuffer(e)) throw new TypeError("argument should be a Buffer");
            if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0) return 0;
            if (t < 0) throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
            if (i < 0) throw new RangeError("sourceEnd out of bounds");
            i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
            let o = i - n;
            return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, i) : Uint8Array.prototype.set.call(e, this.subarray(n, i), t), o
        };
        J.prototype.fill = function(e, t, n, i) {
            if (typeof e == "string") {
                if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string") throw new TypeError("encoding must be a string");
                if (typeof i == "string" && !J.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                if (e.length === 1) {
                    let a = e.charCodeAt(0);
                    (i === "utf8" && a < 128 || i === "latin1") && (e = a)
                }
            } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
            if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
            if (n <= t) return this;
            t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
            let o;
            if (typeof e == "number")
                for (o = t; o < n; ++o) this[o] = e;
            else {
                let a = J.isBuffer(e) ? e : J.from(e, i),
                    y = a.length;
                if (y === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                for (o = 0; o < n - t; ++o) this[o + t] = a[o % y]
            }
            return this
        };
        var gs = {};

        function o0(r, e, t) {
            gs[r] = class extends t {
                constructor() {
                    super(), Object.defineProperty(this, "message", {
                        value: e.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }), this.name = `${this.name} [${r}]`, this.stack, delete this.name
                }
                get code() {
                    return r
                }
                set code(i) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: i,
                        writable: !0
                    })
                }
                toString() {
                    return `${this.name} [${r}]: ${this.message}`
                }
            }
        }
        o0("ERR_BUFFER_OUT_OF_BOUNDS", function(r) {
            return r ? `${r} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
        }, RangeError);
        o0("ERR_INVALID_ARG_TYPE", function(r, e) {
            return `The "${r}" argument must be of type number. Received type ${typeof e}`
        }, TypeError);
        o0("ERR_OUT_OF_RANGE", function(r, e, t) {
            let n = `The value of "${r}" is out of range.`,
                i = t;
            return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? i = Dg(String(t)) : typeof t == "bigint" && (i = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (i = Dg(i)), i += "n"), n += ` It must be ${e}. Received ${i}`, n
        }, RangeError);

        function Dg(r) {
            let e = "",
                t = r.length,
                n = r[0] === "-" ? 1 : 0;
            for (; t >= n + 4; t -= 3) e = `_${r.slice(t-3,t)}${e}`;
            return `${r.slice(0,t)}${e}`
        }

        function Y4(r, e, t) {
            xs(e, "offset"), (r[e] === void 0 || r[e + t] === void 0) && ya(e, r.length - (t + 1))
        }

        function Xg(r, e, t, n, i, o) {
            if (r > t || r < e) {
                let a = typeof e == "bigint" ? "n" : "",
                    y;
                throw o > 3 ? e === 0 || e === BigInt(0) ? y = `>= 0${a} and < 2${a} ** ${(o+1)*8}${a}` : y = `>= -(2${a} ** ${(o+1)*8-1}${a}) and < 2 ** ${(o+1)*8-1}${a}` : y = `>= ${e}${a} and <= ${t}${a}`, new gs.ERR_OUT_OF_RANGE("value", y, r)
            }
            Y4(n, i, o)
        }

        function xs(r, e) {
            if (typeof r != "number") throw new gs.ERR_INVALID_ARG_TYPE(e, "number", r)
        }

        function ya(r, e, t) {
            throw Math.floor(r) !== r ? (xs(r, t), new gs.ERR_OUT_OF_RANGE(t || "offset", "an integer", r)) : e < 0 ? new gs.ERR_BUFFER_OUT_OF_BOUNDS : new gs.ERR_OUT_OF_RANGE(t || "offset", `>= ${t?1:0} and <= ${e}`, r)
        }
        var J4 = /[^+/0-9A-Za-z-_]/g;

        function X4(r) {
            if (r = r.split("=")[0], r = r.trim().replace(J4, ""), r.length < 2) return "";
            for (; r.length % 4 !== 0;) r = r + "=";
            return r
        }

        function r0(r, e) {
            e = e || 1 / 0;
            let t, n = r.length,
                i = null,
                o = [];
            for (let a = 0; a < n; ++a) {
                if (t = r.charCodeAt(a), t > 55295 && t < 57344) {
                    if (!i) {
                        if (t > 56319) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        } else if (a + 1 === n) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        i = t;
                        continue
                    }
                    if (t < 56320) {
                        (e -= 3) > -1 && o.push(239, 191, 189), i = t;
                        continue
                    }
                    t = (i - 55296 << 10 | t - 56320) + 65536
                } else i && (e -= 3) > -1 && o.push(239, 191, 189);
                if (i = null, t < 128) {
                    if ((e -= 1) < 0) break;
                    o.push(t)
                } else if (t < 2048) {
                    if ((e -= 2) < 0) break;
                    o.push(t >> 6 | 192, t & 63 | 128)
                } else if (t < 65536) {
                    if ((e -= 3) < 0) break;
                    o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128)
                } else if (t < 1114112) {
                    if ((e -= 4) < 0) break;
                    o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128)
                } else throw new Error("Invalid code point")
            }
            return o
        }

        function Q4(r) {
            let e = [];
            for (let t = 0; t < r.length; ++t) e.push(r.charCodeAt(t) & 255);
            return e
        }

        function e5(r, e) {
            let t, n, i, o = [];
            for (let a = 0; a < r.length && !((e -= 2) < 0); ++a) t = r.charCodeAt(a), n = t >> 8, i = t % 256, o.push(i), o.push(n);
            return o
        }

        function Qg(r) {
            return Qh.toByteArray(X4(r))
        }

        function Pu(r, e, t, n) {
            let i;
            for (i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i) e[i + t] = r[i];
            return i
        }

        function oi(r, e) {
            return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name
        }

        function s0(r) {
            return r !== r
        }
        var t5 = function() {
            let r = "0123456789abcdef",
                e = new Array(256);
            for (let t = 0; t < 16; ++t) {
                let n = t * 16;
                for (let i = 0; i < 16; ++i) e[n + i] = r[t] + r[i]
            }
            return e
        }();

        function no(r) {
            return typeof BigInt > "u" ? r5 : r
        }

        function r5() {
            throw new Error("BigInt not supported")
        }
    });
    var u0 = Ue((eb, f0) => {
        (function(r, e) {
            "use strict";

            function t(l, s) {
                if (!l) throw new Error(s || "Assertion failed")
            }

            function n(l, s) {
                l.super_ = s;
                var f = function() {};
                f.prototype = s.prototype, l.prototype = new f, l.prototype.constructor = l
            }

            function i(l, s, f) {
                if (i.isBN(l)) return l;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, l !== null && ((s === "le" || s === "be") && (f = s, s = 10), this._init(l || 0, s || 10, f || "be"))
            }
            typeof r == "object" ? r.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
            var o;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = ff().Buffer
            } catch {}
            i.isBN = function(s) {
                return s instanceof i ? !0 : s !== null && typeof s == "object" && s.constructor.wordSize === i.wordSize && Array.isArray(s.words)
            }, i.max = function(s, f) {
                return s.cmp(f) > 0 ? s : f
            }, i.min = function(s, f) {
                return s.cmp(f) < 0 ? s : f
            }, i.prototype._init = function(s, f, h) {
                if (typeof s == "number") return this._initNumber(s, f, h);
                if (typeof s == "object") return this._initArray(s, f, h);
                f === "hex" && (f = 16), t(f === (f | 0) && f >= 2 && f <= 36), s = s.toString().replace(/\s+/g, "");
                var p = 0;
                s[0] === "-" && (p++, this.negative = 1), p < s.length && (f === 16 ? this._parseHex(s, p, h) : (this._parseBase(s, f, p), h === "le" && this._initArray(this.toArray(), f, h)))
            }, i.prototype._initNumber = function(s, f, h) {
                s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [s & 67108863, s / 67108864 & 67108863], this.length = 2) : (t(s < 9007199254740992), this.words = [s & 67108863, s / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), f, h)
            }, i.prototype._initArray = function(s, f, h) {
                if (t(typeof s.length == "number"), s.length <= 0) return this.words = [0], this.length = 1, this;
                this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);
                for (var p = 0; p < this.length; p++) this.words[p] = 0;
                var d, c, x = 0;
                if (h === "be")
                    for (p = s.length - 1, d = 0; p >= 0; p -= 3) c = s[p] | s[p - 1] << 8 | s[p - 2] << 16, this.words[d] |= c << x & 67108863, this.words[d + 1] = c >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, d++);
                else if (h === "le")
                    for (p = 0, d = 0; p < s.length; p += 3) c = s[p] | s[p + 1] << 8 | s[p + 2] << 16, this.words[d] |= c << x & 67108863, this.words[d + 1] = c >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, d++);
                return this._strip()
            };

            function a(l, s) {
                var f = l.charCodeAt(s);
                if (f >= 48 && f <= 57) return f - 48;
                if (f >= 65 && f <= 70) return f - 55;
                if (f >= 97 && f <= 102) return f - 87;
                t(!1, "Invalid character in " + l)
            }

            function y(l, s, f) {
                var h = a(l, f);
                return f - 1 >= s && (h |= a(l, f - 1) << 4), h
            }
            i.prototype._parseHex = function(s, f, h) {
                this.length = Math.ceil((s.length - f) / 6), this.words = new Array(this.length);
                for (var p = 0; p < this.length; p++) this.words[p] = 0;
                var d = 0,
                    c = 0,
                    x;
                if (h === "be")
                    for (p = s.length - 1; p >= f; p -= 2) x = y(s, f, p) << d, this.words[c] |= x & 67108863, d >= 18 ? (d -= 18, c += 1, this.words[c] |= x >>> 26) : d += 8;
                else {
                    var v = s.length - f;
                    for (p = v % 2 === 0 ? f + 1 : f; p < s.length; p += 2) x = y(s, f, p) << d, this.words[c] |= x & 67108863, d >= 18 ? (d -= 18, c += 1, this.words[c] |= x >>> 26) : d += 8
                }
                this._strip()
            };

            function g(l, s, f, h) {
                for (var p = 0, d = 0, c = Math.min(l.length, f), x = s; x < c; x++) {
                    var v = l.charCodeAt(x) - 48;
                    p *= h, v >= 49 ? d = v - 49 + 10 : v >= 17 ? d = v - 17 + 10 : d = v, t(v >= 0 && d < h, "Invalid character"), p += d
                }
                return p
            }
            i.prototype._parseBase = function(s, f, h) {
                this.words = [0], this.length = 1;
                for (var p = 0, d = 1; d <= 67108863; d *= f) p++;
                p--, d = d / f | 0;
                for (var c = s.length - h, x = c % p, v = Math.min(c, c - x) + h, u = 0, _ = h; _ < v; _ += p) u = g(s, _, _ + p, f), this.imuln(d), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
                if (x !== 0) {
                    var F = 1;
                    for (u = g(s, _, s.length, f), _ = 0; _ < x; _++) F *= f;
                    this.imuln(F), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u)
                }
                this._strip()
            }, i.prototype.copy = function(s) {
                s.words = new Array(this.length);
                for (var f = 0; f < this.length; f++) s.words[f] = this.words[f];
                s.length = this.length, s.negative = this.negative, s.red = this.red
            };

            function E(l, s) {
                l.words = s.words, l.length = s.length, l.negative = s.negative, l.red = s.red
            }
            if (i.prototype._move = function(s) {
                    E(s, this)
                }, i.prototype.clone = function() {
                    var s = new i(null);
                    return this.copy(s), s
                }, i.prototype._expand = function(s) {
                    for (; this.length < s;) this.words[this.length++] = 0;
                    return this
                }, i.prototype._strip = function() {
                    for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
                    return this._normSign()
                }, i.prototype._normSign = function() {
                    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
                }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
                i.prototype[Symbol.for("nodejs.util.inspect.custom")] = A
            } catch {
                i.prototype.inspect = A
            } else i.prototype.inspect = A;

            function A() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            var I = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                q = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                L = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            i.prototype.toString = function(s, f) {
                s = s || 10, f = f | 0 || 1;
                var h;
                if (s === 16 || s === "hex") {
                    h = "";
                    for (var p = 0, d = 0, c = 0; c < this.length; c++) {
                        var x = this.words[c],
                            v = ((x << p | d) & 16777215).toString(16);
                        d = x >>> 24 - p & 16777215, d !== 0 || c !== this.length - 1 ? h = I[6 - v.length] + v + h : h = v + h, p += 2, p >= 26 && (p -= 26, c--)
                    }
                    for (d !== 0 && (h = d.toString(16) + h); h.length % f !== 0;) h = "0" + h;
                    return this.negative !== 0 && (h = "-" + h), h
                }
                if (s === (s | 0) && s >= 2 && s <= 36) {
                    var u = q[s],
                        _ = L[s];
                    h = "";
                    var F = this.clone();
                    for (F.negative = 0; !F.isZero();) {
                        var S = F.modrn(_).toString(s);
                        F = F.idivn(_), F.isZero() ? h = S + h : h = I[u - S.length] + S + h
                    }
                    for (this.isZero() && (h = "0" + h); h.length % f !== 0;) h = "0" + h;
                    return this.negative !== 0 && (h = "-" + h), h
                }
                t(!1, "Base should be between 2 and 36")
            }, i.prototype.toNumber = function() {
                var s = this.words[0];
                return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && t(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s : s
            }, i.prototype.toJSON = function() {
                return this.toString(16, 2)
            }, o && (i.prototype.toBuffer = function(s, f) {
                return this.toArrayLike(o, s, f)
            }), i.prototype.toArray = function(s, f) {
                return this.toArrayLike(Array, s, f)
            };
            var O = function(s, f) {
                return s.allocUnsafe ? s.allocUnsafe(f) : new s(f)
            };
            i.prototype.toArrayLike = function(s, f, h) {
                this._strip();
                var p = this.byteLength(),
                    d = h || Math.max(1, p);
                t(p <= d, "byte array longer than desired length"), t(d > 0, "Requested array length <= 0");
                var c = O(s, d),
                    x = f === "le" ? "LE" : "BE";
                return this["_toArrayLike" + x](c, p), c
            }, i.prototype._toArrayLikeLE = function(s, f) {
                for (var h = 0, p = 0, d = 0, c = 0; d < this.length; d++) {
                    var x = this.words[d] << c | p;
                    s[h++] = x & 255, h < s.length && (s[h++] = x >> 8 & 255), h < s.length && (s[h++] = x >> 16 & 255), c === 6 ? (h < s.length && (s[h++] = x >> 24 & 255), p = 0, c = 0) : (p = x >>> 24, c += 2)
                }
                if (h < s.length)
                    for (s[h++] = p; h < s.length;) s[h++] = 0
            }, i.prototype._toArrayLikeBE = function(s, f) {
                for (var h = s.length - 1, p = 0, d = 0, c = 0; d < this.length; d++) {
                    var x = this.words[d] << c | p;
                    s[h--] = x & 255, h >= 0 && (s[h--] = x >> 8 & 255), h >= 0 && (s[h--] = x >> 16 & 255), c === 6 ? (h >= 0 && (s[h--] = x >> 24 & 255), p = 0, c = 0) : (p = x >>> 24, c += 2)
                }
                if (h >= 0)
                    for (s[h--] = p; h >= 0;) s[h--] = 0
            }, Math.clz32 ? i.prototype._countBits = function(s) {
                return 32 - Math.clz32(s)
            } : i.prototype._countBits = function(s) {
                var f = s,
                    h = 0;
                return f >= 4096 && (h += 13, f >>>= 13), f >= 64 && (h += 7, f >>>= 7), f >= 8 && (h += 4, f >>>= 4), f >= 2 && (h += 2, f >>>= 2), h + f
            }, i.prototype._zeroBits = function(s) {
                if (s === 0) return 26;
                var f = s,
                    h = 0;
                return (f & 8191) === 0 && (h += 13, f >>>= 13), (f & 127) === 0 && (h += 7, f >>>= 7), (f & 15) === 0 && (h += 4, f >>>= 4), (f & 3) === 0 && (h += 2, f >>>= 2), (f & 1) === 0 && h++, h
            }, i.prototype.bitLength = function() {
                var s = this.words[this.length - 1],
                    f = this._countBits(s);
                return (this.length - 1) * 26 + f
            };

            function Z(l) {
                for (var s = new Array(l.bitLength()), f = 0; f < s.length; f++) {
                    var h = f / 26 | 0,
                        p = f % 26;
                    s[f] = l.words[h] >>> p & 1
                }
                return s
            }
            i.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for (var s = 0, f = 0; f < this.length; f++) {
                    var h = this._zeroBits(this.words[f]);
                    if (s += h, h !== 26) break
                }
                return s
            }, i.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }, i.prototype.toTwos = function(s) {
                return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone()
            }, i.prototype.fromTwos = function(s) {
                return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone()
            }, i.prototype.isNeg = function() {
                return this.negative !== 0
            }, i.prototype.neg = function() {
                return this.clone().ineg()
            }, i.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this
            }, i.prototype.iuor = function(s) {
                for (; this.length < s.length;) this.words[this.length++] = 0;
                for (var f = 0; f < s.length; f++) this.words[f] = this.words[f] | s.words[f];
                return this._strip()
            }, i.prototype.ior = function(s) {
                return t((this.negative | s.negative) === 0), this.iuor(s)
            }, i.prototype.or = function(s) {
                return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this)
            }, i.prototype.uor = function(s) {
                return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this)
            }, i.prototype.iuand = function(s) {
                var f;
                this.length > s.length ? f = s : f = this;
                for (var h = 0; h < f.length; h++) this.words[h] = this.words[h] & s.words[h];
                return this.length = f.length, this._strip()
            }, i.prototype.iand = function(s) {
                return t((this.negative | s.negative) === 0), this.iuand(s)
            }, i.prototype.and = function(s) {
                return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this)
            }, i.prototype.uand = function(s) {
                return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this)
            }, i.prototype.iuxor = function(s) {
                var f, h;
                this.length > s.length ? (f = this, h = s) : (f = s, h = this);
                for (var p = 0; p < h.length; p++) this.words[p] = f.words[p] ^ h.words[p];
                if (this !== f)
                    for (; p < f.length; p++) this.words[p] = f.words[p];
                return this.length = f.length, this._strip()
            }, i.prototype.ixor = function(s) {
                return t((this.negative | s.negative) === 0), this.iuxor(s)
            }, i.prototype.xor = function(s) {
                return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this)
            }, i.prototype.uxor = function(s) {
                return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this)
            }, i.prototype.inotn = function(s) {
                t(typeof s == "number" && s >= 0);
                var f = Math.ceil(s / 26) | 0,
                    h = s % 26;
                this._expand(f), h > 0 && f--;
                for (var p = 0; p < f; p++) this.words[p] = ~this.words[p] & 67108863;
                return h > 0 && (this.words[p] = ~this.words[p] & 67108863 >> 26 - h), this._strip()
            }, i.prototype.notn = function(s) {
                return this.clone().inotn(s)
            }, i.prototype.setn = function(s, f) {
                t(typeof s == "number" && s >= 0);
                var h = s / 26 | 0,
                    p = s % 26;
                return this._expand(h + 1), f ? this.words[h] = this.words[h] | 1 << p : this.words[h] = this.words[h] & ~(1 << p), this._strip()
            }, i.prototype.iadd = function(s) {
                var f;
                if (this.negative !== 0 && s.negative === 0) return this.negative = 0, f = this.isub(s), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && s.negative !== 0) return s.negative = 0, f = this.isub(s), s.negative = 1, f._normSign();
                var h, p;
                this.length > s.length ? (h = this, p = s) : (h = s, p = this);
                for (var d = 0, c = 0; c < p.length; c++) f = (h.words[c] | 0) + (p.words[c] | 0) + d, this.words[c] = f & 67108863, d = f >>> 26;
                for (; d !== 0 && c < h.length; c++) f = (h.words[c] | 0) + d, this.words[c] = f & 67108863, d = f >>> 26;
                if (this.length = h.length, d !== 0) this.words[this.length] = d, this.length++;
                else if (h !== this)
                    for (; c < h.length; c++) this.words[c] = h.words[c];
                return this
            }, i.prototype.add = function(s) {
                var f;
                return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, f = this.sub(s), s.negative ^= 1, f) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, f = s.sub(this), this.negative = 1, f) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this)
            }, i.prototype.isub = function(s) {
                if (s.negative !== 0) {
                    s.negative = 0;
                    var f = this.iadd(s);
                    return s.negative = 1, f._normSign()
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();
                var h = this.cmp(s);
                if (h === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var p, d;
                h > 0 ? (p = this, d = s) : (p = s, d = this);
                for (var c = 0, x = 0; x < d.length; x++) f = (p.words[x] | 0) - (d.words[x] | 0) + c, c = f >> 26, this.words[x] = f & 67108863;
                for (; c !== 0 && x < p.length; x++) f = (p.words[x] | 0) + c, c = f >> 26, this.words[x] = f & 67108863;
                if (c === 0 && x < p.length && p !== this)
                    for (; x < p.length; x++) this.words[x] = p.words[x];
                return this.length = Math.max(this.length, x), p !== this && (this.negative = 1), this._strip()
            }, i.prototype.sub = function(s) {
                return this.clone().isub(s)
            };

            function ge(l, s, f) {
                f.negative = s.negative ^ l.negative;
                var h = l.length + s.length | 0;
                f.length = h, h = h - 1 | 0;
                var p = l.words[0] | 0,
                    d = s.words[0] | 0,
                    c = p * d,
                    x = c & 67108863,
                    v = c / 67108864 | 0;
                f.words[0] = x;
                for (var u = 1; u < h; u++) {
                    for (var _ = v >>> 26, F = v & 67108863, S = Math.min(u, s.length - 1), z = Math.max(0, u - l.length + 1); z <= S; z++) {
                        var C = u - z | 0;
                        p = l.words[C] | 0, d = s.words[z] | 0, c = p * d + F, _ += c / 67108864 | 0, F = c & 67108863
                    }
                    f.words[u] = F | 0, v = _ | 0
                }
                return v !== 0 ? f.words[u] = v | 0 : f.length--, f._strip()
            }
            var ce = function(s, f, h) {
                var p = s.words,
                    d = f.words,
                    c = h.words,
                    x = 0,
                    v, u, _, F = p[0] | 0,
                    S = F & 8191,
                    z = F >>> 13,
                    C = p[1] | 0,
                    D = C & 8191,
                    Y = C >>> 13,
                    Re = p[2] | 0,
                    ee = Re & 8191,
                    re = Re >>> 13,
                    Zt = p[3] | 0,
                    me = Zt & 8191,
                    Ee = Zt >>> 13,
                    $r = p[4] | 0,
                    Qe = $r & 8191,
                    Le = $r >>> 13,
                    Ar = p[5] | 0,
                    et = Ar & 8191,
                    je = Ar >>> 13,
                    Ur = p[6] | 0,
                    De = Ur & 8191,
                    We = Ur >>> 13,
                    Ir = p[7] | 0,
                    He = Ir & 8191,
                    Ve = Ir >>> 13,
                    jr = p[8] | 0,
                    it = jr & 8191,
                    Ge = jr >>> 13,
                    Nr = p[9] | 0,
                    Ke = Nr & 8191,
                    Fe = Nr >>> 13,
                    vr = d[0] | 0,
                    Ce = vr & 8191,
                    $e = vr >>> 13,
                    _r = d[1] | 0,
                    Oe = _r & 8191,
                    Ze = _r >>> 13,
                    Wr = d[2] | 0,
                    ot = Wr & 8191,
                    st = Wr >>> 13,
                    dr = d[3] | 0,
                    ze = dr & 8191,
                    Ne = dr >>> 13,
                    qr = d[4] | 0,
                    Ye = qr & 8191,
                    tt = qr >>> 13,
                    nn = d[5] | 0,
                    Be = nn & 8191,
                    rt = nn >>> 13,
                    M = d[6] | 0,
                    k = M & 8191,
                    R = M >>> 13,
                    b = d[7] | 0,
                    P = b & 8191,
                    U = b >>> 13,
                    j = d[8] | 0,
                    K = j & 8191,
                    W = j >>> 13,
                    Pe = d[9] | 0,
                    ne = Pe & 8191,
                    Me = Pe >>> 13;
                h.negative = s.negative ^ f.negative, h.length = 19, v = Math.imul(S, Ce), u = Math.imul(S, $e), u = u + Math.imul(z, Ce) | 0, _ = Math.imul(z, $e);
                var Ae = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, v = Math.imul(D, Ce), u = Math.imul(D, $e), u = u + Math.imul(Y, Ce) | 0, _ = Math.imul(Y, $e), v = v + Math.imul(S, Oe) | 0, u = u + Math.imul(S, Ze) | 0, u = u + Math.imul(z, Oe) | 0, _ = _ + Math.imul(z, Ze) | 0;
                var ut = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, v = Math.imul(ee, Ce), u = Math.imul(ee, $e), u = u + Math.imul(re, Ce) | 0, _ = Math.imul(re, $e), v = v + Math.imul(D, Oe) | 0, u = u + Math.imul(D, Ze) | 0, u = u + Math.imul(Y, Oe) | 0, _ = _ + Math.imul(Y, Ze) | 0, v = v + Math.imul(S, ot) | 0, u = u + Math.imul(S, st) | 0, u = u + Math.imul(z, ot) | 0, _ = _ + Math.imul(z, st) | 0;
                var ht = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, v = Math.imul(me, Ce), u = Math.imul(me, $e), u = u + Math.imul(Ee, Ce) | 0, _ = Math.imul(Ee, $e), v = v + Math.imul(ee, Oe) | 0, u = u + Math.imul(ee, Ze) | 0, u = u + Math.imul(re, Oe) | 0, _ = _ + Math.imul(re, Ze) | 0, v = v + Math.imul(D, ot) | 0, u = u + Math.imul(D, st) | 0, u = u + Math.imul(Y, ot) | 0, _ = _ + Math.imul(Y, st) | 0, v = v + Math.imul(S, ze) | 0, u = u + Math.imul(S, Ne) | 0, u = u + Math.imul(z, ze) | 0, _ = _ + Math.imul(z, Ne) | 0;
                var pt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, v = Math.imul(Qe, Ce), u = Math.imul(Qe, $e), u = u + Math.imul(Le, Ce) | 0, _ = Math.imul(Le, $e), v = v + Math.imul(me, Oe) | 0, u = u + Math.imul(me, Ze) | 0, u = u + Math.imul(Ee, Oe) | 0, _ = _ + Math.imul(Ee, Ze) | 0, v = v + Math.imul(ee, ot) | 0, u = u + Math.imul(ee, st) | 0, u = u + Math.imul(re, ot) | 0, _ = _ + Math.imul(re, st) | 0, v = v + Math.imul(D, ze) | 0, u = u + Math.imul(D, Ne) | 0, u = u + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, Ne) | 0, v = v + Math.imul(S, Ye) | 0, u = u + Math.imul(S, tt) | 0, u = u + Math.imul(z, Ye) | 0, _ = _ + Math.imul(z, tt) | 0;
                var dt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, v = Math.imul(et, Ce), u = Math.imul(et, $e), u = u + Math.imul(je, Ce) | 0, _ = Math.imul(je, $e), v = v + Math.imul(Qe, Oe) | 0, u = u + Math.imul(Qe, Ze) | 0, u = u + Math.imul(Le, Oe) | 0, _ = _ + Math.imul(Le, Ze) | 0, v = v + Math.imul(me, ot) | 0, u = u + Math.imul(me, st) | 0, u = u + Math.imul(Ee, ot) | 0, _ = _ + Math.imul(Ee, st) | 0, v = v + Math.imul(ee, ze) | 0, u = u + Math.imul(ee, Ne) | 0, u = u + Math.imul(re, ze) | 0, _ = _ + Math.imul(re, Ne) | 0, v = v + Math.imul(D, Ye) | 0, u = u + Math.imul(D, tt) | 0, u = u + Math.imul(Y, Ye) | 0, _ = _ + Math.imul(Y, tt) | 0, v = v + Math.imul(S, Be) | 0, u = u + Math.imul(S, rt) | 0, u = u + Math.imul(z, Be) | 0, _ = _ + Math.imul(z, rt) | 0;
                var yt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, v = Math.imul(De, Ce), u = Math.imul(De, $e), u = u + Math.imul(We, Ce) | 0, _ = Math.imul(We, $e), v = v + Math.imul(et, Oe) | 0, u = u + Math.imul(et, Ze) | 0, u = u + Math.imul(je, Oe) | 0, _ = _ + Math.imul(je, Ze) | 0, v = v + Math.imul(Qe, ot) | 0, u = u + Math.imul(Qe, st) | 0, u = u + Math.imul(Le, ot) | 0, _ = _ + Math.imul(Le, st) | 0, v = v + Math.imul(me, ze) | 0, u = u + Math.imul(me, Ne) | 0, u = u + Math.imul(Ee, ze) | 0, _ = _ + Math.imul(Ee, Ne) | 0, v = v + Math.imul(ee, Ye) | 0, u = u + Math.imul(ee, tt) | 0, u = u + Math.imul(re, Ye) | 0, _ = _ + Math.imul(re, tt) | 0, v = v + Math.imul(D, Be) | 0, u = u + Math.imul(D, rt) | 0, u = u + Math.imul(Y, Be) | 0, _ = _ + Math.imul(Y, rt) | 0, v = v + Math.imul(S, k) | 0, u = u + Math.imul(S, R) | 0, u = u + Math.imul(z, k) | 0, _ = _ + Math.imul(z, R) | 0;
                var bt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, v = Math.imul(He, Ce), u = Math.imul(He, $e), u = u + Math.imul(Ve, Ce) | 0, _ = Math.imul(Ve, $e), v = v + Math.imul(De, Oe) | 0, u = u + Math.imul(De, Ze) | 0, u = u + Math.imul(We, Oe) | 0, _ = _ + Math.imul(We, Ze) | 0, v = v + Math.imul(et, ot) | 0, u = u + Math.imul(et, st) | 0, u = u + Math.imul(je, ot) | 0, _ = _ + Math.imul(je, st) | 0, v = v + Math.imul(Qe, ze) | 0, u = u + Math.imul(Qe, Ne) | 0, u = u + Math.imul(Le, ze) | 0, _ = _ + Math.imul(Le, Ne) | 0, v = v + Math.imul(me, Ye) | 0, u = u + Math.imul(me, tt) | 0, u = u + Math.imul(Ee, Ye) | 0, _ = _ + Math.imul(Ee, tt) | 0, v = v + Math.imul(ee, Be) | 0, u = u + Math.imul(ee, rt) | 0, u = u + Math.imul(re, Be) | 0, _ = _ + Math.imul(re, rt) | 0, v = v + Math.imul(D, k) | 0, u = u + Math.imul(D, R) | 0, u = u + Math.imul(Y, k) | 0, _ = _ + Math.imul(Y, R) | 0, v = v + Math.imul(S, P) | 0, u = u + Math.imul(S, U) | 0, u = u + Math.imul(z, P) | 0, _ = _ + Math.imul(z, U) | 0;
                var mt = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, v = Math.imul(it, Ce), u = Math.imul(it, $e), u = u + Math.imul(Ge, Ce) | 0, _ = Math.imul(Ge, $e), v = v + Math.imul(He, Oe) | 0, u = u + Math.imul(He, Ze) | 0, u = u + Math.imul(Ve, Oe) | 0, _ = _ + Math.imul(Ve, Ze) | 0, v = v + Math.imul(De, ot) | 0, u = u + Math.imul(De, st) | 0, u = u + Math.imul(We, ot) | 0, _ = _ + Math.imul(We, st) | 0, v = v + Math.imul(et, ze) | 0, u = u + Math.imul(et, Ne) | 0, u = u + Math.imul(je, ze) | 0, _ = _ + Math.imul(je, Ne) | 0, v = v + Math.imul(Qe, Ye) | 0, u = u + Math.imul(Qe, tt) | 0, u = u + Math.imul(Le, Ye) | 0, _ = _ + Math.imul(Le, tt) | 0, v = v + Math.imul(me, Be) | 0, u = u + Math.imul(me, rt) | 0, u = u + Math.imul(Ee, Be) | 0, _ = _ + Math.imul(Ee, rt) | 0, v = v + Math.imul(ee, k) | 0, u = u + Math.imul(ee, R) | 0, u = u + Math.imul(re, k) | 0, _ = _ + Math.imul(re, R) | 0, v = v + Math.imul(D, P) | 0, u = u + Math.imul(D, U) | 0, u = u + Math.imul(Y, P) | 0, _ = _ + Math.imul(Y, U) | 0, v = v + Math.imul(S, K) | 0, u = u + Math.imul(S, W) | 0, u = u + Math.imul(z, K) | 0, _ = _ + Math.imul(z, W) | 0;
                var ke = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, v = Math.imul(Ke, Ce), u = Math.imul(Ke, $e), u = u + Math.imul(Fe, Ce) | 0, _ = Math.imul(Fe, $e), v = v + Math.imul(it, Oe) | 0, u = u + Math.imul(it, Ze) | 0, u = u + Math.imul(Ge, Oe) | 0, _ = _ + Math.imul(Ge, Ze) | 0, v = v + Math.imul(He, ot) | 0, u = u + Math.imul(He, st) | 0, u = u + Math.imul(Ve, ot) | 0, _ = _ + Math.imul(Ve, st) | 0, v = v + Math.imul(De, ze) | 0, u = u + Math.imul(De, Ne) | 0, u = u + Math.imul(We, ze) | 0, _ = _ + Math.imul(We, Ne) | 0, v = v + Math.imul(et, Ye) | 0, u = u + Math.imul(et, tt) | 0, u = u + Math.imul(je, Ye) | 0, _ = _ + Math.imul(je, tt) | 0, v = v + Math.imul(Qe, Be) | 0, u = u + Math.imul(Qe, rt) | 0, u = u + Math.imul(Le, Be) | 0, _ = _ + Math.imul(Le, rt) | 0, v = v + Math.imul(me, k) | 0, u = u + Math.imul(me, R) | 0, u = u + Math.imul(Ee, k) | 0, _ = _ + Math.imul(Ee, R) | 0, v = v + Math.imul(ee, P) | 0, u = u + Math.imul(ee, U) | 0, u = u + Math.imul(re, P) | 0, _ = _ + Math.imul(re, U) | 0, v = v + Math.imul(D, K) | 0, u = u + Math.imul(D, W) | 0, u = u + Math.imul(Y, K) | 0, _ = _ + Math.imul(Y, W) | 0, v = v + Math.imul(S, ne) | 0, u = u + Math.imul(S, Me) | 0, u = u + Math.imul(z, ne) | 0, _ = _ + Math.imul(z, Me) | 0;
                var at = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, v = Math.imul(Ke, Oe), u = Math.imul(Ke, Ze), u = u + Math.imul(Fe, Oe) | 0, _ = Math.imul(Fe, Ze), v = v + Math.imul(it, ot) | 0, u = u + Math.imul(it, st) | 0, u = u + Math.imul(Ge, ot) | 0, _ = _ + Math.imul(Ge, st) | 0, v = v + Math.imul(He, ze) | 0, u = u + Math.imul(He, Ne) | 0, u = u + Math.imul(Ve, ze) | 0, _ = _ + Math.imul(Ve, Ne) | 0, v = v + Math.imul(De, Ye) | 0, u = u + Math.imul(De, tt) | 0, u = u + Math.imul(We, Ye) | 0, _ = _ + Math.imul(We, tt) | 0, v = v + Math.imul(et, Be) | 0, u = u + Math.imul(et, rt) | 0, u = u + Math.imul(je, Be) | 0, _ = _ + Math.imul(je, rt) | 0, v = v + Math.imul(Qe, k) | 0, u = u + Math.imul(Qe, R) | 0, u = u + Math.imul(Le, k) | 0, _ = _ + Math.imul(Le, R) | 0, v = v + Math.imul(me, P) | 0, u = u + Math.imul(me, U) | 0, u = u + Math.imul(Ee, P) | 0, _ = _ + Math.imul(Ee, U) | 0, v = v + Math.imul(ee, K) | 0, u = u + Math.imul(ee, W) | 0, u = u + Math.imul(re, K) | 0, _ = _ + Math.imul(re, W) | 0, v = v + Math.imul(D, ne) | 0, u = u + Math.imul(D, Me) | 0, u = u + Math.imul(Y, ne) | 0, _ = _ + Math.imul(Y, Me) | 0;
                var Ie = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, v = Math.imul(Ke, ot), u = Math.imul(Ke, st), u = u + Math.imul(Fe, ot) | 0, _ = Math.imul(Fe, st), v = v + Math.imul(it, ze) | 0, u = u + Math.imul(it, Ne) | 0, u = u + Math.imul(Ge, ze) | 0, _ = _ + Math.imul(Ge, Ne) | 0, v = v + Math.imul(He, Ye) | 0, u = u + Math.imul(He, tt) | 0, u = u + Math.imul(Ve, Ye) | 0, _ = _ + Math.imul(Ve, tt) | 0, v = v + Math.imul(De, Be) | 0, u = u + Math.imul(De, rt) | 0, u = u + Math.imul(We, Be) | 0, _ = _ + Math.imul(We, rt) | 0, v = v + Math.imul(et, k) | 0, u = u + Math.imul(et, R) | 0, u = u + Math.imul(je, k) | 0, _ = _ + Math.imul(je, R) | 0, v = v + Math.imul(Qe, P) | 0, u = u + Math.imul(Qe, U) | 0, u = u + Math.imul(Le, P) | 0, _ = _ + Math.imul(Le, U) | 0, v = v + Math.imul(me, K) | 0, u = u + Math.imul(me, W) | 0, u = u + Math.imul(Ee, K) | 0, _ = _ + Math.imul(Ee, W) | 0, v = v + Math.imul(ee, ne) | 0, u = u + Math.imul(ee, Me) | 0, u = u + Math.imul(re, ne) | 0, _ = _ + Math.imul(re, Me) | 0;
                var Te = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, v = Math.imul(Ke, ze), u = Math.imul(Ke, Ne), u = u + Math.imul(Fe, ze) | 0, _ = Math.imul(Fe, Ne), v = v + Math.imul(it, Ye) | 0, u = u + Math.imul(it, tt) | 0, u = u + Math.imul(Ge, Ye) | 0, _ = _ + Math.imul(Ge, tt) | 0, v = v + Math.imul(He, Be) | 0, u = u + Math.imul(He, rt) | 0, u = u + Math.imul(Ve, Be) | 0, _ = _ + Math.imul(Ve, rt) | 0, v = v + Math.imul(De, k) | 0, u = u + Math.imul(De, R) | 0, u = u + Math.imul(We, k) | 0, _ = _ + Math.imul(We, R) | 0, v = v + Math.imul(et, P) | 0, u = u + Math.imul(et, U) | 0, u = u + Math.imul(je, P) | 0, _ = _ + Math.imul(je, U) | 0, v = v + Math.imul(Qe, K) | 0, u = u + Math.imul(Qe, W) | 0, u = u + Math.imul(Le, K) | 0, _ = _ + Math.imul(Le, W) | 0, v = v + Math.imul(me, ne) | 0, u = u + Math.imul(me, Me) | 0, u = u + Math.imul(Ee, ne) | 0, _ = _ + Math.imul(Ee, Me) | 0;
                var qe = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, v = Math.imul(Ke, Ye), u = Math.imul(Ke, tt), u = u + Math.imul(Fe, Ye) | 0, _ = Math.imul(Fe, tt), v = v + Math.imul(it, Be) | 0, u = u + Math.imul(it, rt) | 0, u = u + Math.imul(Ge, Be) | 0, _ = _ + Math.imul(Ge, rt) | 0, v = v + Math.imul(He, k) | 0, u = u + Math.imul(He, R) | 0, u = u + Math.imul(Ve, k) | 0, _ = _ + Math.imul(Ve, R) | 0, v = v + Math.imul(De, P) | 0, u = u + Math.imul(De, U) | 0, u = u + Math.imul(We, P) | 0, _ = _ + Math.imul(We, U) | 0, v = v + Math.imul(et, K) | 0, u = u + Math.imul(et, W) | 0, u = u + Math.imul(je, K) | 0, _ = _ + Math.imul(je, W) | 0, v = v + Math.imul(Qe, ne) | 0, u = u + Math.imul(Qe, Me) | 0, u = u + Math.imul(Le, ne) | 0, _ = _ + Math.imul(Le, Me) | 0;
                var Se = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, v = Math.imul(Ke, Be), u = Math.imul(Ke, rt), u = u + Math.imul(Fe, Be) | 0, _ = Math.imul(Fe, rt), v = v + Math.imul(it, k) | 0, u = u + Math.imul(it, R) | 0, u = u + Math.imul(Ge, k) | 0, _ = _ + Math.imul(Ge, R) | 0, v = v + Math.imul(He, P) | 0, u = u + Math.imul(He, U) | 0, u = u + Math.imul(Ve, P) | 0, _ = _ + Math.imul(Ve, U) | 0, v = v + Math.imul(De, K) | 0, u = u + Math.imul(De, W) | 0, u = u + Math.imul(We, K) | 0, _ = _ + Math.imul(We, W) | 0, v = v + Math.imul(et, ne) | 0, u = u + Math.imul(et, Me) | 0, u = u + Math.imul(je, ne) | 0, _ = _ + Math.imul(je, Me) | 0;
                var H = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (H >>> 26) | 0, H &= 67108863, v = Math.imul(Ke, k), u = Math.imul(Ke, R), u = u + Math.imul(Fe, k) | 0, _ = Math.imul(Fe, R), v = v + Math.imul(it, P) | 0, u = u + Math.imul(it, U) | 0, u = u + Math.imul(Ge, P) | 0, _ = _ + Math.imul(Ge, U) | 0, v = v + Math.imul(He, K) | 0, u = u + Math.imul(He, W) | 0, u = u + Math.imul(Ve, K) | 0, _ = _ + Math.imul(Ve, W) | 0, v = v + Math.imul(De, ne) | 0, u = u + Math.imul(De, Me) | 0, u = u + Math.imul(We, ne) | 0, _ = _ + Math.imul(We, Me) | 0;
                var V = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (V >>> 26) | 0, V &= 67108863, v = Math.imul(Ke, P), u = Math.imul(Ke, U), u = u + Math.imul(Fe, P) | 0, _ = Math.imul(Fe, U), v = v + Math.imul(it, K) | 0, u = u + Math.imul(it, W) | 0, u = u + Math.imul(Ge, K) | 0, _ = _ + Math.imul(Ge, W) | 0, v = v + Math.imul(He, ne) | 0, u = u + Math.imul(He, Me) | 0, u = u + Math.imul(Ve, ne) | 0, _ = _ + Math.imul(Ve, Me) | 0;
                var ye = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, v = Math.imul(Ke, K), u = Math.imul(Ke, W), u = u + Math.imul(Fe, K) | 0, _ = Math.imul(Fe, W), v = v + Math.imul(it, ne) | 0, u = u + Math.imul(it, Me) | 0, u = u + Math.imul(Ge, ne) | 0, _ = _ + Math.imul(Ge, Me) | 0;
                var oe = (x + v | 0) + ((u & 8191) << 13) | 0;
                x = (_ + (u >>> 13) | 0) + (oe >>> 26) | 0, oe &= 67108863, v = Math.imul(Ke, ne), u = Math.imul(Ke, Me), u = u + Math.imul(Fe, ne) | 0, _ = Math.imul(Fe, Me);
                var se = (x + v | 0) + ((u & 8191) << 13) | 0;
                return x = (_ + (u >>> 13) | 0) + (se >>> 26) | 0, se &= 67108863, c[0] = Ae, c[1] = ut, c[2] = ht, c[3] = pt, c[4] = dt, c[5] = yt, c[6] = bt, c[7] = mt, c[8] = ke, c[9] = at, c[10] = Ie, c[11] = Te, c[12] = qe, c[13] = Se, c[14] = H, c[15] = V, c[16] = ye, c[17] = oe, c[18] = se, x !== 0 && (c[19] = x, h.length++), h
            };
            Math.imul || (ce = ge);

            function Xe(l, s, f) {
                f.negative = s.negative ^ l.negative, f.length = l.length + s.length;
                for (var h = 0, p = 0, d = 0; d < f.length - 1; d++) {
                    var c = p;
                    p = 0;
                    for (var x = h & 67108863, v = Math.min(d, s.length - 1), u = Math.max(0, d - l.length + 1); u <= v; u++) {
                        var _ = d - u,
                            F = l.words[_] | 0,
                            S = s.words[u] | 0,
                            z = F * S,
                            C = z & 67108863;
                        c = c + (z / 67108864 | 0) | 0, C = C + x | 0, x = C & 67108863, c = c + (C >>> 26) | 0, p += c >>> 26, c &= 67108863
                    }
                    f.words[d] = x, h = c, c = p
                }
                return h !== 0 ? f.words[d] = h : f.length--, f._strip()
            }

            function xe(l, s, f) {
                return Xe(l, s, f)
            }
            i.prototype.mulTo = function(s, f) {
                var h, p = this.length + s.length;
                return this.length === 10 && s.length === 10 ? h = ce(this, s, f) : p < 63 ? h = ge(this, s, f) : p < 1024 ? h = Xe(this, s, f) : h = xe(this, s, f), h
            };

            function ie(l, s) {
                this.x = l, this.y = s
            }
            ie.prototype.makeRBT = function(s) {
                for (var f = new Array(s), h = i.prototype._countBits(s) - 1, p = 0; p < s; p++) f[p] = this.revBin(p, h, s);
                return f
            }, ie.prototype.revBin = function(s, f, h) {
                if (s === 0 || s === h - 1) return s;
                for (var p = 0, d = 0; d < f; d++) p |= (s & 1) << f - d - 1, s >>= 1;
                return p
            }, ie.prototype.permute = function(s, f, h, p, d, c) {
                for (var x = 0; x < c; x++) p[x] = f[s[x]], d[x] = h[s[x]]
            }, ie.prototype.transform = function(s, f, h, p, d, c) {
                this.permute(c, s, f, h, p, d);
                for (var x = 1; x < d; x <<= 1)
                    for (var v = x << 1, u = Math.cos(2 * Math.PI / v), _ = Math.sin(2 * Math.PI / v), F = 0; F < d; F += v)
                        for (var S = u, z = _, C = 0; C < x; C++) {
                            var D = h[F + C],
                                Y = p[F + C],
                                Re = h[F + C + x],
                                ee = p[F + C + x],
                                re = S * Re - z * ee;
                            ee = S * ee + z * Re, Re = re, h[F + C] = D + Re, p[F + C] = Y + ee, h[F + C + x] = D - Re, p[F + C + x] = Y - ee, C !== v && (re = u * S - _ * z, z = u * z + _ * S, S = re)
                        }
            }, ie.prototype.guessLen13b = function(s, f) {
                var h = Math.max(f, s) | 1,
                    p = h & 1,
                    d = 0;
                for (h = h / 2 | 0; h; h = h >>> 1) d++;
                return 1 << d + 1 + p
            }, ie.prototype.conjugate = function(s, f, h) {
                if (!(h <= 1))
                    for (var p = 0; p < h / 2; p++) {
                        var d = s[p];
                        s[p] = s[h - p - 1], s[h - p - 1] = d, d = f[p], f[p] = -f[h - p - 1], f[h - p - 1] = -d
                    }
            }, ie.prototype.normalize13b = function(s, f) {
                for (var h = 0, p = 0; p < f / 2; p++) {
                    var d = Math.round(s[2 * p + 1] / f) * 8192 + Math.round(s[2 * p] / f) + h;
                    s[p] = d & 67108863, d < 67108864 ? h = 0 : h = d / 67108864 | 0
                }
                return s
            }, ie.prototype.convert13b = function(s, f, h, p) {
                for (var d = 0, c = 0; c < f; c++) d = d + (s[c] | 0), h[2 * c] = d & 8191, d = d >>> 13, h[2 * c + 1] = d & 8191, d = d >>> 13;
                for (c = 2 * f; c < p; ++c) h[c] = 0;
                t(d === 0), t((d & -8192) === 0)
            }, ie.prototype.stub = function(s) {
                for (var f = new Array(s), h = 0; h < s; h++) f[h] = 0;
                return f
            }, ie.prototype.mulp = function(s, f, h) {
                var p = 2 * this.guessLen13b(s.length, f.length),
                    d = this.makeRBT(p),
                    c = this.stub(p),
                    x = new Array(p),
                    v = new Array(p),
                    u = new Array(p),
                    _ = new Array(p),
                    F = new Array(p),
                    S = new Array(p),
                    z = h.words;
                z.length = p, this.convert13b(s.words, s.length, x, p), this.convert13b(f.words, f.length, _, p), this.transform(x, c, v, u, p, d), this.transform(_, c, F, S, p, d);
                for (var C = 0; C < p; C++) {
                    var D = v[C] * F[C] - u[C] * S[C];
                    u[C] = v[C] * S[C] + u[C] * F[C], v[C] = D
                }
                return this.conjugate(v, u, p), this.transform(v, u, z, c, p, d), this.conjugate(z, c, p), this.normalize13b(z, p), h.negative = s.negative ^ f.negative, h.length = s.length + f.length, h._strip()
            }, i.prototype.mul = function(s) {
                var f = new i(null);
                return f.words = new Array(this.length + s.length), this.mulTo(s, f)
            }, i.prototype.mulf = function(s) {
                var f = new i(null);
                return f.words = new Array(this.length + s.length), xe(this, s, f)
            }, i.prototype.imul = function(s) {
                return this.clone().mulTo(s, this)
            }, i.prototype.imuln = function(s) {
                var f = s < 0;
                f && (s = -s), t(typeof s == "number"), t(s < 67108864);
                for (var h = 0, p = 0; p < this.length; p++) {
                    var d = (this.words[p] | 0) * s,
                        c = (d & 67108863) + (h & 67108863);
                    h >>= 26, h += d / 67108864 | 0, h += c >>> 26, this.words[p] = c & 67108863
                }
                return h !== 0 && (this.words[p] = h, this.length++), f ? this.ineg() : this
            }, i.prototype.muln = function(s) {
                return this.clone().imuln(s)
            }, i.prototype.sqr = function() {
                return this.mul(this)
            }, i.prototype.isqr = function() {
                return this.imul(this.clone())
            }, i.prototype.pow = function(s) {
                var f = Z(s);
                if (f.length === 0) return new i(1);
                for (var h = this, p = 0; p < f.length && f[p] === 0; p++, h = h.sqr());
                if (++p < f.length)
                    for (var d = h.sqr(); p < f.length; p++, d = d.sqr()) f[p] !== 0 && (h = h.mul(d));
                return h
            }, i.prototype.iushln = function(s) {
                t(typeof s == "number" && s >= 0);
                var f = s % 26,
                    h = (s - f) / 26,
                    p = 67108863 >>> 26 - f << 26 - f,
                    d;
                if (f !== 0) {
                    var c = 0;
                    for (d = 0; d < this.length; d++) {
                        var x = this.words[d] & p,
                            v = (this.words[d] | 0) - x << f;
                        this.words[d] = v | c, c = x >>> 26 - f
                    }
                    c && (this.words[d] = c, this.length++)
                }
                if (h !== 0) {
                    for (d = this.length - 1; d >= 0; d--) this.words[d + h] = this.words[d];
                    for (d = 0; d < h; d++) this.words[d] = 0;
                    this.length += h
                }
                return this._strip()
            }, i.prototype.ishln = function(s) {
                return t(this.negative === 0), this.iushln(s)
            }, i.prototype.iushrn = function(s, f, h) {
                t(typeof s == "number" && s >= 0);
                var p;
                f ? p = (f - f % 26) / 26 : p = 0;
                var d = s % 26,
                    c = Math.min((s - d) / 26, this.length),
                    x = 67108863 ^ 67108863 >>> d << d,
                    v = h;
                if (p -= c, p = Math.max(0, p), v) {
                    for (var u = 0; u < c; u++) v.words[u] = this.words[u];
                    v.length = c
                }
                if (c !== 0)
                    if (this.length > c)
                        for (this.length -= c, u = 0; u < this.length; u++) this.words[u] = this.words[u + c];
                    else this.words[0] = 0, this.length = 1;
                var _ = 0;
                for (u = this.length - 1; u >= 0 && (_ !== 0 || u >= p); u--) {
                    var F = this.words[u] | 0;
                    this.words[u] = _ << 26 - d | F >>> d, _ = F & x
                }
                return v && _ !== 0 && (v.words[v.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
            }, i.prototype.ishrn = function(s, f, h) {
                return t(this.negative === 0), this.iushrn(s, f, h)
            }, i.prototype.shln = function(s) {
                return this.clone().ishln(s)
            }, i.prototype.ushln = function(s) {
                return this.clone().iushln(s)
            }, i.prototype.shrn = function(s) {
                return this.clone().ishrn(s)
            }, i.prototype.ushrn = function(s) {
                return this.clone().iushrn(s)
            }, i.prototype.testn = function(s) {
                t(typeof s == "number" && s >= 0);
                var f = s % 26,
                    h = (s - f) / 26,
                    p = 1 << f;
                if (this.length <= h) return !1;
                var d = this.words[h];
                return !!(d & p)
            }, i.prototype.imaskn = function(s) {
                t(typeof s == "number" && s >= 0);
                var f = s % 26,
                    h = (s - f) / 26;
                if (t(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h) return this;
                if (f !== 0 && h++, this.length = Math.min(h, this.length), f !== 0) {
                    var p = 67108863 ^ 67108863 >>> f << f;
                    this.words[this.length - 1] &= p
                }
                return this._strip()
            }, i.prototype.maskn = function(s) {
                return this.clone().imaskn(s)
            }, i.prototype.iaddn = function(s) {
                return t(typeof s == "number"), t(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s)
            }, i.prototype._iaddn = function(s) {
                this.words[0] += s;
                for (var f = 0; f < this.length && this.words[f] >= 67108864; f++) this.words[f] -= 67108864, f === this.length - 1 ? this.words[f + 1] = 1 : this.words[f + 1]++;
                return this.length = Math.max(this.length, f + 1), this
            }, i.prototype.isubn = function(s) {
                if (t(typeof s == "number"), t(s < 67108864), s < 0) return this.iaddn(-s);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(s), this.negative = 1, this;
                if (this.words[0] -= s, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else
                    for (var f = 0; f < this.length && this.words[f] < 0; f++) this.words[f] += 67108864, this.words[f + 1] -= 1;
                return this._strip()
            }, i.prototype.addn = function(s) {
                return this.clone().iaddn(s)
            }, i.prototype.subn = function(s) {
                return this.clone().isubn(s)
            }, i.prototype.iabs = function() {
                return this.negative = 0, this
            }, i.prototype.abs = function() {
                return this.clone().iabs()
            }, i.prototype._ishlnsubmul = function(s, f, h) {
                var p = s.length + h,
                    d;
                this._expand(p);
                var c, x = 0;
                for (d = 0; d < s.length; d++) {
                    c = (this.words[d + h] | 0) + x;
                    var v = (s.words[d] | 0) * f;
                    c -= v & 67108863, x = (c >> 26) - (v / 67108864 | 0), this.words[d + h] = c & 67108863
                }
                for (; d < this.length - h; d++) c = (this.words[d + h] | 0) + x, x = c >> 26, this.words[d + h] = c & 67108863;
                if (x === 0) return this._strip();
                for (t(x === -1), x = 0, d = 0; d < this.length; d++) c = -(this.words[d] | 0) + x, x = c >> 26, this.words[d] = c & 67108863;
                return this.negative = 1, this._strip()
            }, i.prototype._wordDiv = function(s, f) {
                var h = this.length - s.length,
                    p = this.clone(),
                    d = s,
                    c = d.words[d.length - 1] | 0,
                    x = this._countBits(c);
                h = 26 - x, h !== 0 && (d = d.ushln(h), p.iushln(h), c = d.words[d.length - 1] | 0);
                var v = p.length - d.length,
                    u;
                if (f !== "mod") {
                    u = new i(null), u.length = v + 1, u.words = new Array(u.length);
                    for (var _ = 0; _ < u.length; _++) u.words[_] = 0
                }
                var F = p.clone()._ishlnsubmul(d, 1, v);
                F.negative === 0 && (p = F, u && (u.words[v] = 1));
                for (var S = v - 1; S >= 0; S--) {
                    var z = (p.words[d.length + S] | 0) * 67108864 + (p.words[d.length + S - 1] | 0);
                    for (z = Math.min(z / c | 0, 67108863), p._ishlnsubmul(d, z, S); p.negative !== 0;) z--, p.negative = 0, p._ishlnsubmul(d, 1, S), p.isZero() || (p.negative ^= 1);
                    u && (u.words[S] = z)
                }
                return u && u._strip(), p._strip(), f !== "div" && h !== 0 && p.iushrn(h), {
                    div: u || null,
                    mod: p
                }
            }, i.prototype.divmod = function(s, f, h) {
                if (t(!s.isZero()), this.isZero()) return {
                    div: new i(0),
                    mod: new i(0)
                };
                var p, d, c;
                return this.negative !== 0 && s.negative === 0 ? (c = this.neg().divmod(s, f), f !== "mod" && (p = c.div.neg()), f !== "div" && (d = c.mod.neg(), h && d.negative !== 0 && d.iadd(s)), {
                    div: p,
                    mod: d
                }) : this.negative === 0 && s.negative !== 0 ? (c = this.divmod(s.neg(), f), f !== "mod" && (p = c.div.neg()), {
                    div: p,
                    mod: c.mod
                }) : (this.negative & s.negative) !== 0 ? (c = this.neg().divmod(s.neg(), f), f !== "div" && (d = c.mod.neg(), h && d.negative !== 0 && d.isub(s)), {
                    div: c.div,
                    mod: d
                }) : s.length > this.length || this.cmp(s) < 0 ? {
                    div: new i(0),
                    mod: this
                } : s.length === 1 ? f === "div" ? {
                    div: this.divn(s.words[0]),
                    mod: null
                } : f === "mod" ? {
                    div: null,
                    mod: new i(this.modrn(s.words[0]))
                } : {
                    div: this.divn(s.words[0]),
                    mod: new i(this.modrn(s.words[0]))
                } : this._wordDiv(s, f)
            }, i.prototype.div = function(s) {
                return this.divmod(s, "div", !1).div
            }, i.prototype.mod = function(s) {
                return this.divmod(s, "mod", !1).mod
            }, i.prototype.umod = function(s) {
                return this.divmod(s, "mod", !0).mod
            }, i.prototype.divRound = function(s) {
                var f = this.divmod(s);
                if (f.mod.isZero()) return f.div;
                var h = f.div.negative !== 0 ? f.mod.isub(s) : f.mod,
                    p = s.ushrn(1),
                    d = s.andln(1),
                    c = h.cmp(p);
                return c < 0 || d === 1 && c === 0 ? f.div : f.div.negative !== 0 ? f.div.isubn(1) : f.div.iaddn(1)
            }, i.prototype.modrn = function(s) {
                var f = s < 0;
                f && (s = -s), t(s <= 67108863);
                for (var h = (1 << 26) % s, p = 0, d = this.length - 1; d >= 0; d--) p = (h * p + (this.words[d] | 0)) % s;
                return f ? -p : p
            }, i.prototype.modn = function(s) {
                return this.modrn(s)
            }, i.prototype.idivn = function(s) {
                var f = s < 0;
                f && (s = -s), t(s <= 67108863);
                for (var h = 0, p = this.length - 1; p >= 0; p--) {
                    var d = (this.words[p] | 0) + h * 67108864;
                    this.words[p] = d / s | 0, h = d % s
                }
                return this._strip(), f ? this.ineg() : this
            }, i.prototype.divn = function(s) {
                return this.clone().idivn(s)
            }, i.prototype.egcd = function(s) {
                t(s.negative === 0), t(!s.isZero());
                var f = this,
                    h = s.clone();
                f.negative !== 0 ? f = f.umod(s) : f = f.clone();
                for (var p = new i(1), d = new i(0), c = new i(0), x = new i(1), v = 0; f.isEven() && h.isEven();) f.iushrn(1), h.iushrn(1), ++v;
                for (var u = h.clone(), _ = f.clone(); !f.isZero();) {
                    for (var F = 0, S = 1;
                        (f.words[0] & S) === 0 && F < 26; ++F, S <<= 1);
                    if (F > 0)
                        for (f.iushrn(F); F-- > 0;)(p.isOdd() || d.isOdd()) && (p.iadd(u), d.isub(_)), p.iushrn(1), d.iushrn(1);
                    for (var z = 0, C = 1;
                        (h.words[0] & C) === 0 && z < 26; ++z, C <<= 1);
                    if (z > 0)
                        for (h.iushrn(z); z-- > 0;)(c.isOdd() || x.isOdd()) && (c.iadd(u), x.isub(_)), c.iushrn(1), x.iushrn(1);
                    f.cmp(h) >= 0 ? (f.isub(h), p.isub(c), d.isub(x)) : (h.isub(f), c.isub(p), x.isub(d))
                }
                return {
                    a: c,
                    b: x,
                    gcd: h.iushln(v)
                }
            }, i.prototype._invmp = function(s) {
                t(s.negative === 0), t(!s.isZero());
                var f = this,
                    h = s.clone();
                f.negative !== 0 ? f = f.umod(s) : f = f.clone();
                for (var p = new i(1), d = new i(0), c = h.clone(); f.cmpn(1) > 0 && h.cmpn(1) > 0;) {
                    for (var x = 0, v = 1;
                        (f.words[0] & v) === 0 && x < 26; ++x, v <<= 1);
                    if (x > 0)
                        for (f.iushrn(x); x-- > 0;) p.isOdd() && p.iadd(c), p.iushrn(1);
                    for (var u = 0, _ = 1;
                        (h.words[0] & _) === 0 && u < 26; ++u, _ <<= 1);
                    if (u > 0)
                        for (h.iushrn(u); u-- > 0;) d.isOdd() && d.iadd(c), d.iushrn(1);
                    f.cmp(h) >= 0 ? (f.isub(h), p.isub(d)) : (h.isub(f), d.isub(p))
                }
                var F;
                return f.cmpn(1) === 0 ? F = p : F = d, F.cmpn(0) < 0 && F.iadd(s), F
            }, i.prototype.gcd = function(s) {
                if (this.isZero()) return s.abs();
                if (s.isZero()) return this.abs();
                var f = this.clone(),
                    h = s.clone();
                f.negative = 0, h.negative = 0;
                for (var p = 0; f.isEven() && h.isEven(); p++) f.iushrn(1), h.iushrn(1);
                do {
                    for (; f.isEven();) f.iushrn(1);
                    for (; h.isEven();) h.iushrn(1);
                    var d = f.cmp(h);
                    if (d < 0) {
                        var c = f;
                        f = h, h = c
                    } else if (d === 0 || h.cmpn(1) === 0) break;
                    f.isub(h)
                } while (!0);
                return h.iushln(p)
            }, i.prototype.invm = function(s) {
                return this.egcd(s).a.umod(s)
            }, i.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }, i.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }, i.prototype.andln = function(s) {
                return this.words[0] & s
            }, i.prototype.bincn = function(s) {
                t(typeof s == "number");
                var f = s % 26,
                    h = (s - f) / 26,
                    p = 1 << f;
                if (this.length <= h) return this._expand(h + 1), this.words[h] |= p, this;
                for (var d = p, c = h; d !== 0 && c < this.length; c++) {
                    var x = this.words[c] | 0;
                    x += d, d = x >>> 26, x &= 67108863, this.words[c] = x
                }
                return d !== 0 && (this.words[c] = d, this.length++), this
            }, i.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }, i.prototype.cmpn = function(s) {
                var f = s < 0;
                if (this.negative !== 0 && !f) return -1;
                if (this.negative === 0 && f) return 1;
                this._strip();
                var h;
                if (this.length > 1) h = 1;
                else {
                    f && (s = -s), t(s <= 67108863, "Number is too big");
                    var p = this.words[0] | 0;
                    h = p === s ? 0 : p < s ? -1 : 1
                }
                return this.negative !== 0 ? -h | 0 : h
            }, i.prototype.cmp = function(s) {
                if (this.negative !== 0 && s.negative === 0) return -1;
                if (this.negative === 0 && s.negative !== 0) return 1;
                var f = this.ucmp(s);
                return this.negative !== 0 ? -f | 0 : f
            }, i.prototype.ucmp = function(s) {
                if (this.length > s.length) return 1;
                if (this.length < s.length) return -1;
                for (var f = 0, h = this.length - 1; h >= 0; h--) {
                    var p = this.words[h] | 0,
                        d = s.words[h] | 0;
                    if (p !== d) {
                        p < d ? f = -1 : p > d && (f = 1);
                        break
                    }
                }
                return f
            }, i.prototype.gtn = function(s) {
                return this.cmpn(s) === 1
            }, i.prototype.gt = function(s) {
                return this.cmp(s) === 1
            }, i.prototype.gten = function(s) {
                return this.cmpn(s) >= 0
            }, i.prototype.gte = function(s) {
                return this.cmp(s) >= 0
            }, i.prototype.ltn = function(s) {
                return this.cmpn(s) === -1
            }, i.prototype.lt = function(s) {
                return this.cmp(s) === -1
            }, i.prototype.lten = function(s) {
                return this.cmpn(s) <= 0
            }, i.prototype.lte = function(s) {
                return this.cmp(s) <= 0
            }, i.prototype.eqn = function(s) {
                return this.cmpn(s) === 0
            }, i.prototype.eq = function(s) {
                return this.cmp(s) === 0
            }, i.red = function(s) {
                return new m(s)
            }, i.prototype.toRed = function(s) {
                return t(!this.red, "Already a number in reduction context"), t(this.negative === 0, "red works only with positives"), s.convertTo(this)._forceRed(s)
            }, i.prototype.fromRed = function() {
                return t(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }, i.prototype._forceRed = function(s) {
                return this.red = s, this
            }, i.prototype.forceRed = function(s) {
                return t(!this.red, "Already a number in reduction context"), this._forceRed(s)
            }, i.prototype.redAdd = function(s) {
                return t(this.red, "redAdd works only with red numbers"), this.red.add(this, s)
            }, i.prototype.redIAdd = function(s) {
                return t(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s)
            }, i.prototype.redSub = function(s) {
                return t(this.red, "redSub works only with red numbers"), this.red.sub(this, s)
            }, i.prototype.redISub = function(s) {
                return t(this.red, "redISub works only with red numbers"), this.red.isub(this, s)
            }, i.prototype.redShl = function(s) {
                return t(this.red, "redShl works only with red numbers"), this.red.shl(this, s)
            }, i.prototype.redMul = function(s) {
                return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.mul(this, s)
            }, i.prototype.redIMul = function(s) {
                return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.imul(this, s)
            }, i.prototype.redSqr = function() {
                return t(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }, i.prototype.redISqr = function() {
                return t(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }, i.prototype.redSqrt = function() {
                return t(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }, i.prototype.redInvm = function() {
                return t(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }, i.prototype.redNeg = function() {
                return t(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }, i.prototype.redPow = function(s) {
                return t(this.red && !s.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s)
            };
            var ae = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };

            function be(l, s) {
                this.name = l, this.p = new i(s, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
            }
            be.prototype._tmp = function() {
                var s = new i(null);
                return s.words = new Array(Math.ceil(this.n / 13)), s
            }, be.prototype.ireduce = function(s) {
                var f = s,
                    h;
                do this.split(f, this.tmp), f = this.imulK(f), f = f.iadd(this.tmp), h = f.bitLength(); while (h > this.n);
                var p = h < this.n ? -1 : f.ucmp(this.p);
                return p === 0 ? (f.words[0] = 0, f.length = 1) : p > 0 ? f.isub(this.p) : f.strip !== void 0 ? f.strip() : f._strip(), f
            }, be.prototype.split = function(s, f) {
                s.iushrn(this.n, 0, f)
            }, be.prototype.imulK = function(s) {
                return s.imul(this.k)
            };

            function we() {
                be.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            n(we, be), we.prototype.split = function(s, f) {
                for (var h = 4194303, p = Math.min(s.length, 9), d = 0; d < p; d++) f.words[d] = s.words[d];
                if (f.length = p, s.length <= 9) {
                    s.words[0] = 0, s.length = 1;
                    return
                }
                var c = s.words[9];
                for (f.words[f.length++] = c & h, d = 10; d < s.length; d++) {
                    var x = s.words[d] | 0;
                    s.words[d - 10] = (x & h) << 4 | c >>> 22, c = x
                }
                c >>>= 22, s.words[d - 10] = c, c === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9
            }, we.prototype.imulK = function(s) {
                s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;
                for (var f = 0, h = 0; h < s.length; h++) {
                    var p = s.words[h] | 0;
                    f += p * 977, s.words[h] = f & 67108863, f = p * 64 + (f / 67108864 | 0)
                }
                return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s
            };

            function he() {
                be.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            n(he, be);

            function gt() {
                be.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            n(gt, be);

            function T() {
                be.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            n(T, be), T.prototype.imulK = function(s) {
                for (var f = 0, h = 0; h < s.length; h++) {
                    var p = (s.words[h] | 0) * 19 + f,
                        d = p & 67108863;
                    p >>>= 26, s.words[h] = d, f = p
                }
                return f !== 0 && (s.words[s.length++] = f), s
            }, i._prime = function(s) {
                if (ae[s]) return ae[s];
                var f;
                if (s === "k256") f = new we;
                else if (s === "p224") f = new he;
                else if (s === "p192") f = new gt;
                else if (s === "p25519") f = new T;
                else throw new Error("Unknown prime " + s);
                return ae[s] = f, f
            };

            function m(l) {
                if (typeof l == "string") {
                    var s = i._prime(l);
                    this.m = s.p, this.prime = s
                } else t(l.gtn(1), "modulus must be greater than 1"), this.m = l, this.prime = null
            }
            m.prototype._verify1 = function(s) {
                t(s.negative === 0, "red works only with positives"), t(s.red, "red works only with red numbers")
            }, m.prototype._verify2 = function(s, f) {
                t((s.negative | f.negative) === 0, "red works only with positives"), t(s.red && s.red === f.red, "red works only with red numbers")
            }, m.prototype.imod = function(s) {
                return this.prime ? this.prime.ireduce(s)._forceRed(this) : (E(s, s.umod(this.m)._forceRed(this)), s)
            }, m.prototype.neg = function(s) {
                return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this)
            }, m.prototype.add = function(s, f) {
                this._verify2(s, f);
                var h = s.add(f);
                return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this)
            }, m.prototype.iadd = function(s, f) {
                this._verify2(s, f);
                var h = s.iadd(f);
                return h.cmp(this.m) >= 0 && h.isub(this.m), h
            }, m.prototype.sub = function(s, f) {
                this._verify2(s, f);
                var h = s.sub(f);
                return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this)
            }, m.prototype.isub = function(s, f) {
                this._verify2(s, f);
                var h = s.isub(f);
                return h.cmpn(0) < 0 && h.iadd(this.m), h
            }, m.prototype.shl = function(s, f) {
                return this._verify1(s), this.imod(s.ushln(f))
            }, m.prototype.imul = function(s, f) {
                return this._verify2(s, f), this.imod(s.imul(f))
            }, m.prototype.mul = function(s, f) {
                return this._verify2(s, f), this.imod(s.mul(f))
            }, m.prototype.isqr = function(s) {
                return this.imul(s, s.clone())
            }, m.prototype.sqr = function(s) {
                return this.mul(s, s)
            }, m.prototype.sqrt = function(s) {
                if (s.isZero()) return s.clone();
                var f = this.m.andln(3);
                if (t(f % 2 === 1), f === 3) {
                    var h = this.m.add(new i(1)).iushrn(2);
                    return this.pow(s, h)
                }
                for (var p = this.m.subn(1), d = 0; !p.isZero() && p.andln(1) === 0;) d++, p.iushrn(1);
                t(!p.isZero());
                var c = new i(1).toRed(this),
                    x = c.redNeg(),
                    v = this.m.subn(1).iushrn(1),
                    u = this.m.bitLength();
                for (u = new i(2 * u * u).toRed(this); this.pow(u, v).cmp(x) !== 0;) u.redIAdd(x);
                for (var _ = this.pow(u, p), F = this.pow(s, p.addn(1).iushrn(1)), S = this.pow(s, p), z = d; S.cmp(c) !== 0;) {
                    for (var C = S, D = 0; C.cmp(c) !== 0; D++) C = C.redSqr();
                    t(D < z);
                    var Y = this.pow(_, new i(1).iushln(z - D - 1));
                    F = F.redMul(Y), _ = Y.redSqr(), S = S.redMul(_), z = D
                }
                return F
            }, m.prototype.invm = function(s) {
                var f = s._invmp(this.m);
                return f.negative !== 0 ? (f.negative = 0, this.imod(f).redNeg()) : this.imod(f)
            }, m.prototype.pow = function(s, f) {
                if (f.isZero()) return new i(1).toRed(this);
                if (f.cmpn(1) === 0) return s.clone();
                var h = 4,
                    p = new Array(1 << h);
                p[0] = new i(1).toRed(this), p[1] = s;
                for (var d = 2; d < p.length; d++) p[d] = this.mul(p[d - 1], s);
                var c = p[0],
                    x = 0,
                    v = 0,
                    u = f.bitLength() % 26;
                for (u === 0 && (u = 26), d = f.length - 1; d >= 0; d--) {
                    for (var _ = f.words[d], F = u - 1; F >= 0; F--) {
                        var S = _ >> F & 1;
                        if (c !== p[0] && (c = this.sqr(c)), S === 0 && x === 0) {
                            v = 0;
                            continue
                        }
                        x <<= 1, x |= S, v++, !(v !== h && (d !== 0 || F !== 0)) && (c = this.mul(c, p[x]), v = 0, x = 0)
                    }
                    u = 26
                }
                return c
            }, m.prototype.convertTo = function(s) {
                var f = s.umod(this.m);
                return f === s ? f.clone() : f
            }, m.prototype.convertFrom = function(s) {
                var f = s.clone();
                return f.red = null, f
            }, i.mont = function(s) {
                return new w(s)
            };

            function w(l) {
                m.call(this, l), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
            }
            n(w, m), w.prototype.convertTo = function(s) {
                return this.imod(s.ushln(this.shift))
            }, w.prototype.convertFrom = function(s) {
                var f = this.imod(s.mul(this.rinv));
                return f.red = null, f
            }, w.prototype.imul = function(s, f) {
                if (s.isZero() || f.isZero()) return s.words[0] = 0, s.length = 1, s;
                var h = s.imul(f),
                    p = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    d = h.isub(p).iushrn(this.shift),
                    c = d;
                return d.cmp(this.m) >= 0 ? c = d.isub(this.m) : d.cmpn(0) < 0 && (c = d.iadd(this.m)), c._forceRed(this)
            }, w.prototype.mul = function(s, f) {
                if (s.isZero() || f.isZero()) return new i(0)._forceRed(this);
                var h = s.mul(f),
                    p = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    d = h.isub(p).iushrn(this.shift),
                    c = d;
                return d.cmp(this.m) >= 0 ? c = d.isub(this.m) : d.cmpn(0) < 0 && (c = d.iadd(this.m)), c._forceRed(this)
            }, w.prototype.invm = function(s) {
                var f = this.imod(s._invmp(this.m).mul(this.r2));
                return f._forceRed(this)
            }
        })(typeof f0 > "u" || f0, eb)
    });
    var tb = Ue(l0 => {
        "use strict";

        function Ni(r, e, t) {
            return e <= r && r <= t
        }

        function Nu(r) {
            if (r === void 0) return {};
            if (r === Object(r)) return r;
            throw TypeError("Could not convert argument to dictionary")
        }

        function n5(r) {
            for (var e = String(r), t = e.length, n = 0, i = []; n < t;) {
                var o = e.charCodeAt(n);
                if (o < 55296 || o > 57343) i.push(o);
                else if (56320 <= o && o <= 57343) i.push(65533);
                else if (55296 <= o && o <= 56319)
                    if (n === t - 1) i.push(65533);
                    else {
                        var a = r.charCodeAt(n + 1);
                        if (56320 <= a && a <= 57343) {
                            var y = o & 1023,
                                g = a & 1023;
                            i.push(65536 + (y << 10) + g), n += 1
                        } else i.push(65533)
                    } n += 1
            }
            return i
        }

        function i5(r) {
            for (var e = "", t = 0; t < r.length; ++t) {
                var n = r[t];
                n <= 65535 ? e += String.fromCharCode(n) : (n -= 65536, e += String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320))
            }
            return e
        }
        var Tu = -1;

        function h0(r) {
            this.tokens = [].slice.call(r)
        }
        h0.prototype = {
            endOfStream: function() {
                return !this.tokens.length
            },
            read: function() {
                return this.tokens.length ? this.tokens.shift() : Tu
            },
            prepend: function(r) {
                if (Array.isArray(r))
                    for (var e = r; e.length;) this.tokens.unshift(e.pop());
                else this.tokens.unshift(r)
            },
            push: function(r) {
                if (Array.isArray(r))
                    for (var e = r; e.length;) this.tokens.push(e.shift());
                else this.tokens.push(r)
            }
        };
        var ws = -1;

        function c0(r, e) {
            if (r) throw TypeError("Decoder error");
            return e || 65533
        }
        var Lu = "utf-8";

        function zu(r, e) {
            if (!(this instanceof zu)) return new zu(r, e);
            if (r = r !== void 0 ? String(r).toLowerCase() : Lu, r !== Lu) throw new Error("Encoding not supported. Only utf-8 is supported");
            e = Nu(e), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = Boolean(e.fatal), this._ignoreBOM = Boolean(e.ignoreBOM), Object.defineProperty(this, "encoding", {
                value: "utf-8"
            }), Object.defineProperty(this, "fatal", {
                value: this._fatal
            }), Object.defineProperty(this, "ignoreBOM", {
                value: this._ignoreBOM
            })
        }
        zu.prototype = {
            decode: function(e, t) {
                var n;
                typeof e == "object" && e instanceof ArrayBuffer ? n = new Uint8Array(e) : typeof e == "object" && "buffer" in e && e.buffer instanceof ArrayBuffer ? n = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : n = new Uint8Array(0), t = Nu(t), this._streaming || (this._decoder = new o5({
                    fatal: this._fatal
                }), this._BOMseen = !1), this._streaming = Boolean(t.stream);
                for (var i = new h0(n), o = [], a; !i.endOfStream() && (a = this._decoder.handler(i, i.read()), a !== ws);) a !== null && (Array.isArray(a) ? o.push.apply(o, a) : o.push(a));
                if (!this._streaming) {
                    do {
                        if (a = this._decoder.handler(i, i.read()), a === ws) break;
                        a !== null && (Array.isArray(a) ? o.push.apply(o, a) : o.push(a))
                    } while (!i.endOfStream());
                    this._decoder = null
                }
                return o.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (o[0] === 65279 ? (this._BOMseen = !0, o.shift()) : this._BOMseen = !0), i5(o)
            }
        };

        function Uu(r, e) {
            if (!(this instanceof Uu)) return new Uu(r, e);
            if (r = r !== void 0 ? String(r).toLowerCase() : Lu, r !== Lu) throw new Error("Encoding not supported. Only utf-8 is supported");
            e = Nu(e), this._streaming = !1, this._encoder = null, this._options = {
                fatal: Boolean(e.fatal)
            }, Object.defineProperty(this, "encoding", {
                value: "utf-8"
            })
        }
        Uu.prototype = {
            encode: function(e, t) {
                e = e ? String(e) : "", t = Nu(t), this._streaming || (this._encoder = new s5(this._options)), this._streaming = Boolean(t.stream);
                for (var n = [], i = new h0(n5(e)), o; !i.endOfStream() && (o = this._encoder.handler(i, i.read()), o !== ws);) Array.isArray(o) ? n.push.apply(n, o) : n.push(o);
                if (!this._streaming) {
                    for (; o = this._encoder.handler(i, i.read()), o !== ws;) Array.isArray(o) ? n.push.apply(n, o) : n.push(o);
                    this._encoder = null
                }
                return new Uint8Array(n)
            }
        };

        function o5(r) {
            var e = r.fatal,
                t = 0,
                n = 0,
                i = 0,
                o = 128,
                a = 191;
            this.handler = function(y, g) {
                if (g === Tu && i !== 0) return i = 0, c0(e);
                if (g === Tu) return ws;
                if (i === 0) {
                    if (Ni(g, 0, 127)) return g;
                    if (Ni(g, 194, 223)) i = 1, t = g - 192;
                    else if (Ni(g, 224, 239)) g === 224 && (o = 160), g === 237 && (a = 159), i = 2, t = g - 224;
                    else if (Ni(g, 240, 244)) g === 240 && (o = 144), g === 244 && (a = 143), i = 3, t = g - 240;
                    else return c0(e);
                    return t = t << 6 * i, null
                }
                if (!Ni(g, o, a)) return t = i = n = 0, o = 128, a = 191, y.prepend(g), c0(e);
                if (o = 128, a = 191, n += 1, t += g - 128 << 6 * (i - n), n !== i) return null;
                var E = t;
                return t = i = n = 0, E
            }
        }

        function s5(r) {
            var e = r.fatal;
            this.handler = function(t, n) {
                if (n === Tu) return ws;
                if (Ni(n, 0, 127)) return n;
                var i, o;
                Ni(n, 128, 2047) ? (i = 1, o = 192) : Ni(n, 2048, 65535) ? (i = 2, o = 224) : Ni(n, 65536, 1114111) && (i = 3, o = 240);
                for (var a = [(n >> 6 * i) + o]; i > 0;) {
                    var y = n >> 6 * (i - 1);
                    a.push(128 | y & 63), i -= 1
                }
                return a
            }
        }
        l0.TextEncoder = Uu;
        l0.TextDecoder = zu
    });
    var sb = Ue(nr => {
        "use strict";
        var a5 = nr && nr.__createBinding || (Object.create ? function(r, e, t, n) {
                n === void 0 && (n = t), Object.defineProperty(r, n, {
                    enumerable: !0,
                    get: function() {
                        return e[t]
                    }
                })
            } : function(r, e, t, n) {
                n === void 0 && (n = t), r[n] = e[t]
            }),
            f5 = nr && nr.__setModuleDefault || (Object.create ? function(r, e) {
                Object.defineProperty(r, "default", {
                    enumerable: !0,
                    value: e
                })
            } : function(r, e) {
                r.default = e
            }),
            si = nr && nr.__decorate || function(r, e, t, n) {
                var i = arguments.length,
                    o = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n,
                    a;
                if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(r, e, t, n);
                else
                    for (var y = r.length - 1; y >= 0; y--)(a = r[y]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
                return i > 3 && o && Object.defineProperty(e, t, o), o
            },
            u5 = nr && nr.__importStar || function(r) {
                if (r && r.__esModule) return r;
                var e = {};
                if (r != null)
                    for (var t in r) t !== "default" && Object.hasOwnProperty.call(r, t) && a5(e, r, t);
                return f5(e, r), e
            },
            rb = nr && nr.__importDefault || function(r) {
                return r && r.__esModule ? r : {
                    default: r
                }
            };
        Object.defineProperty(nr, "__esModule", {
            value: !0
        });
        nr.deserializeUnchecked = nr.deserialize = nr.serialize = nr.BinaryReader = nr.BinaryWriter = nr.BorshError = nr.baseDecode = nr.baseEncode = void 0;
        var io = rb(u0()),
            nb = rb(Ti()),
            c5 = u5(tb()),
            h5 = typeof TextDecoder != "function" ? c5.TextDecoder : TextDecoder,
            l5 = new h5("utf-8", {
                fatal: !0
            });

        function d5(r) {
            return typeof r == "string" && (r = Buffer.from(r, "utf8")), nb.default.encode(Buffer.from(r))
        }
        nr.baseEncode = d5;

        function p5(r) {
            return Buffer.from(nb.default.decode(r))
        }
        nr.baseDecode = p5;
        var d0 = 1024,
            Cr = class extends Error {
                constructor(e) {
                    super(e), this.fieldPath = [], this.originalMessage = e
                }
                addToFieldPath(e) {
                    this.fieldPath.splice(0, 0, e), this.message = this.originalMessage + ": " + this.fieldPath.join(".")
                }
            };
        nr.BorshError = Cr;
        var qu = class {
            constructor() {
                this.buf = Buffer.alloc(d0), this.length = 0
            }
            maybeResize() {
                this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(d0)]))
            }
            writeU8(e) {
                this.maybeResize(), this.buf.writeUInt8(e, this.length), this.length += 1
            }
            writeU16(e) {
                this.maybeResize(), this.buf.writeUInt16LE(e, this.length), this.length += 2
            }
            writeU32(e) {
                this.maybeResize(), this.buf.writeUInt32LE(e, this.length), this.length += 4
            }
            writeU64(e) {
                this.maybeResize(), this.writeBuffer(Buffer.from(new io.default(e).toArray("le", 8)))
            }
            writeU128(e) {
                this.maybeResize(), this.writeBuffer(Buffer.from(new io.default(e).toArray("le", 16)))
            }
            writeU256(e) {
                this.maybeResize(), this.writeBuffer(Buffer.from(new io.default(e).toArray("le", 32)))
            }
            writeU512(e) {
                this.maybeResize(), this.writeBuffer(Buffer.from(new io.default(e).toArray("le", 64)))
            }
            writeBuffer(e) {
                this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), e, Buffer.alloc(d0)]), this.length += e.length
            }
            writeString(e) {
                this.maybeResize();
                let t = Buffer.from(e, "utf8");
                this.writeU32(t.length), this.writeBuffer(t)
            }
            writeFixedArray(e) {
                this.writeBuffer(Buffer.from(e))
            }
            writeArray(e, t) {
                this.maybeResize(), this.writeU32(e.length);
                for (let n of e) this.maybeResize(), t(n)
            }
            toArray() {
                return this.buf.subarray(0, this.length)
            }
        };
        nr.BinaryWriter = qu;

        function ai(r, e, t) {
            let n = t.value;
            t.value = function(...i) {
                try {
                    return n.apply(this, i)
                } catch (o) {
                    if (o instanceof RangeError) {
                        let a = o.code;
                        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(a) >= 0) throw new Cr("Reached the end of buffer when deserializing")
                    }
                    throw o
                }
            }
        }
        var fn = class {
            constructor(e) {
                this.buf = e, this.offset = 0
            }
            readU8() {
                let e = this.buf.readUInt8(this.offset);
                return this.offset += 1, e
            }
            readU16() {
                let e = this.buf.readUInt16LE(this.offset);
                return this.offset += 2, e
            }
            readU32() {
                let e = this.buf.readUInt32LE(this.offset);
                return this.offset += 4, e
            }
            readU64() {
                let e = this.readBuffer(8);
                return new io.default(e, "le")
            }
            readU128() {
                let e = this.readBuffer(16);
                return new io.default(e, "le")
            }
            readU256() {
                let e = this.readBuffer(32);
                return new io.default(e, "le")
            }
            readU512() {
                let e = this.readBuffer(64);
                return new io.default(e, "le")
            }
            readBuffer(e) {
                if (this.offset + e > this.buf.length) throw new Cr(`Expected buffer length ${e} isn't within bounds`);
                let t = this.buf.slice(this.offset, this.offset + e);
                return this.offset += e, t
            }
            readString() {
                let e = this.readU32(),
                    t = this.readBuffer(e);
                try {
                    return l5.decode(t)
                } catch (n) {
                    throw new Cr(`Error decoding UTF-8 string: ${n}`)
                }
            }
            readFixedArray(e) {
                return new Uint8Array(this.readBuffer(e))
            }
            readArray(e) {
                let t = this.readU32(),
                    n = Array();
                for (let i = 0; i < t; ++i) n.push(e());
                return n
            }
        };
        si([ai], fn.prototype, "readU8", null);
        si([ai], fn.prototype, "readU16", null);
        si([ai], fn.prototype, "readU32", null);
        si([ai], fn.prototype, "readU64", null);
        si([ai], fn.prototype, "readU128", null);
        si([ai], fn.prototype, "readU256", null);
        si([ai], fn.prototype, "readU512", null);
        si([ai], fn.prototype, "readString", null);
        si([ai], fn.prototype, "readFixedArray", null);
        si([ai], fn.prototype, "readArray", null);
        nr.BinaryReader = fn;

        function ib(r) {
            return r.charAt(0).toUpperCase() + r.slice(1)
        }

        function Uo(r, e, t, n, i) {
            try {
                if (typeof n == "string") i[`write${ib(n)}`](t);
                else if (n instanceof Array)
                    if (typeof n[0] == "number") {
                        if (t.length !== n[0]) throw new Cr(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);
                        i.writeFixedArray(t)
                    } else if (n.length === 2 && typeof n[1] == "number") {
                    if (t.length !== n[1]) throw new Cr(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);
                    for (let o = 0; o < n[1]; o++) Uo(r, null, t[o], n[0], i)
                } else i.writeArray(t, o => {
                    Uo(r, e, o, n[0], i)
                });
                else if (n.kind !== void 0) switch (n.kind) {
                    case "option": {
                        t == null ? i.writeU8(0) : (i.writeU8(1), Uo(r, e, t, n.type, i));
                        break
                    }
                    case "map": {
                        i.writeU32(t.size), t.forEach((o, a) => {
                            Uo(r, e, a, n.key, i), Uo(r, e, o, n.value, i)
                        });
                        break
                    }
                    default:
                        throw new Cr(`FieldType ${n} unrecognized`)
                } else ob(r, t, i)
            } catch (o) {
                throw o instanceof Cr && o.addToFieldPath(e), o
            }
        }

        function ob(r, e, t) {
            if (typeof e.borshSerialize == "function") {
                e.borshSerialize(t);
                return
            }
            let n = r.get(e.constructor);
            if (!n) throw new Cr(`Class ${e.constructor.name} is missing in schema`);
            if (n.kind === "struct") n.fields.map(([i, o]) => {
                Uo(r, i, e[i], o, t)
            });
            else if (n.kind === "enum") {
                let i = e[n.field];
                for (let o = 0; o < n.values.length; ++o) {
                    let [a, y] = n.values[o];
                    if (a === i) {
                        t.writeU8(o), Uo(r, a, e[a], y, t);
                        break
                    }
                }
            } else throw new Cr(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)
        }

        function y5(r, e, t = qu) {
            let n = new t;
            return ob(r, e, n), n.toArray()
        }
        nr.serialize = y5;

        function No(r, e, t, n) {
            try {
                if (typeof t == "string") return n[`read${ib(t)}`]();
                if (t instanceof Array) {
                    if (typeof t[0] == "number") return n.readFixedArray(t[0]);
                    if (typeof t[1] == "number") {
                        let i = [];
                        for (let o = 0; o < t[1]; o++) i.push(No(r, null, t[0], n));
                        return i
                    } else return n.readArray(() => No(r, e, t[0], n))
                }
                if (t.kind === "option") return n.readU8() ? No(r, e, t.type, n) : void 0;
                if (t.kind === "map") {
                    let i = new Map,
                        o = n.readU32();
                    for (let a = 0; a < o; a++) {
                        let y = No(r, e, t.key, n),
                            g = No(r, e, t.value, n);
                        i.set(y, g)
                    }
                    return i
                }
                return p0(r, t, n)
            } catch (i) {
                throw i instanceof Cr && i.addToFieldPath(e), i
            }
        }

        function p0(r, e, t) {
            if (typeof e.borshDeserialize == "function") return e.borshDeserialize(t);
            let n = r.get(e);
            if (!n) throw new Cr(`Class ${e.name} is missing in schema`);
            if (n.kind === "struct") {
                let i = {};
                for (let [o, a] of r.get(e).fields) i[o] = No(r, o, a, t);
                return new e(i)
            }
            if (n.kind === "enum") {
                let i = t.readU8();
                if (i >= n.values.length) throw new Cr(`Enum index: ${i} is out of range`);
                let [o, a] = n.values[i], y = No(r, o, a, t);
                return new e({
                    [o]: y
                })
            }
            throw new Cr(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)
        }

        function m5(r, e, t, n = fn) {
            let i = new n(t),
                o = p0(r, e, i);
            if (i.offset < t.length) throw new Cr(`Unexpected ${t.length-i.offset} bytes after deserialized data`);
            return o
        }
        nr.deserialize = m5;

        function g5(r, e, t, n = fn) {
            let i = new n(t);
            return p0(r, e, i)
        }
        nr.deserializeUnchecked = g5
    });
    var Eb = Ue(Ms => {
        "use strict";
        var y0 = ca(),
            Es = ha(),
            ab = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        Ms.Buffer = X;
        Ms.SlowBuffer = E5;
        Ms.INSPECT_MAX_BYTES = 50;
        var Fu = 2147483647;
        Ms.kMaxLength = Fu;
        X.TYPED_ARRAY_SUPPORT = b5();
        !X.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

        function b5() {
            try {
                let r = new Uint8Array(1),
                    e = {
                        foo: function() {
                            return 42
                        }
                    };
                return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42
            } catch {
                return !1
            }
        }
        Object.defineProperty(X.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (!!X.isBuffer(this)) return this.buffer
            }
        });
        Object.defineProperty(X.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (!!X.isBuffer(this)) return this.byteOffset
            }
        });

        function qi(r) {
            if (r > Fu) throw new RangeError('The value "' + r + '" is invalid for option "size"');
            let e = new Uint8Array(r);
            return Object.setPrototypeOf(e, X.prototype), e
        }

        function X(r, e, t) {
            if (typeof r == "number") {
                if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
                return x0(r)
            }
            return hb(r, e, t)
        }
        X.poolSize = 8192;

        function hb(r, e, t) {
            if (typeof r == "string") return v5(r, e);
            if (ArrayBuffer.isView(r)) return w5(r);
            if (r == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
            if (fi(r, ArrayBuffer) || r && fi(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (fi(r, SharedArrayBuffer) || r && fi(r.buffer, SharedArrayBuffer))) return g0(r, e, t);
            if (typeof r == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
            let n = r.valueOf && r.valueOf();
            if (n != null && n !== r) return X.from(n, e, t);
            let i = _5(r);
            if (i) return i;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function") return X.from(r[Symbol.toPrimitive]("string"), e, t);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r)
        }
        X.from = function(r, e, t) {
            return hb(r, e, t)
        };
        Object.setPrototypeOf(X.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(X, Uint8Array);

        function lb(r) {
            if (typeof r != "number") throw new TypeError('"size" argument must be of type number');
            if (r < 0) throw new RangeError('The value "' + r + '" is invalid for option "size"')
        }

        function x5(r, e, t) {
            return lb(r), r <= 0 ? qi(r) : e !== void 0 ? typeof t == "string" ? qi(r).fill(e, t) : qi(r).fill(e) : qi(r)
        }
        X.alloc = function(r, e, t) {
            return x5(r, e, t)
        };

        function x0(r) {
            return lb(r), qi(r < 0 ? 0 : v0(r) | 0)
        }
        X.allocUnsafe = function(r) {
            return x0(r)
        };
        X.allocUnsafeSlow = function(r) {
            return x0(r)
        };

        function v5(r, e) {
            if ((typeof e != "string" || e === "") && (e = "utf8"), !X.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            let t = db(r, e) | 0,
                n = qi(t),
                i = n.write(r, e);
            return i !== t && (n = n.slice(0, i)), n
        }

        function m0(r) {
            let e = r.length < 0 ? 0 : v0(r.length) | 0,
                t = qi(e);
            for (let n = 0; n < e; n += 1) t[n] = r[n] & 255;
            return t
        }

        function w5(r) {
            if (fi(r, Uint8Array)) {
                let e = new Uint8Array(r);
                return g0(e.buffer, e.byteOffset, e.byteLength)
            }
            return m0(r)
        }

        function g0(r, e, t) {
            if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
            if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
            let n;
            return e === void 0 && t === void 0 ? n = new Uint8Array(r) : t === void 0 ? n = new Uint8Array(r, e) : n = new Uint8Array(r, e, t), Object.setPrototypeOf(n, X.prototype), n
        }

        function _5(r) {
            if (X.isBuffer(r)) {
                let e = v0(r.length) | 0,
                    t = qi(e);
                return t.length === 0 || r.copy(t, 0, 0, e), t
            }
            if (r.length !== void 0) return typeof r.length != "number" || _0(r.length) ? qi(0) : m0(r);
            if (r.type === "Buffer" && Array.isArray(r.data)) return m0(r.data)
        }

        function v0(r) {
            if (r >= Fu) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Fu.toString(16) + " bytes");
            return r | 0
        }

        function E5(r) {
            return +r != r && (r = 0), X.alloc(+r)
        }
        X.isBuffer = function(e) {
            return e != null && e._isBuffer === !0 && e !== X.prototype
        };
        X.compare = function(e, t) {
            if (fi(e, Uint8Array) && (e = X.from(e, e.offset, e.byteLength)), fi(t, Uint8Array) && (t = X.from(t, t.offset, t.byteLength)), !X.isBuffer(e) || !X.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (e === t) return 0;
            let n = e.length,
                i = t.length;
            for (let o = 0, a = Math.min(n, i); o < a; ++o)
                if (e[o] !== t[o]) {
                    n = e[o], i = t[o];
                    break
                } return n < i ? -1 : i < n ? 1 : 0
        };
        X.isEncoding = function(e) {
            switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
            }
        };
        X.concat = function(e, t) {
            if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (e.length === 0) return X.alloc(0);
            let n;
            if (t === void 0)
                for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
            let i = X.allocUnsafe(t),
                o = 0;
            for (n = 0; n < e.length; ++n) {
                let a = e[n];
                if (fi(a, Uint8Array)) o + a.length > i.length ? (X.isBuffer(a) || (a = X.from(a)), a.copy(i, o)) : Uint8Array.prototype.set.call(i, a, o);
                else if (X.isBuffer(a)) a.copy(i, o);
                else throw new TypeError('"list" argument must be an Array of Buffers');
                o += a.length
            }
            return i
        };

        function db(r, e) {
            if (X.isBuffer(r)) return r.length;
            if (ArrayBuffer.isView(r) || fi(r, ArrayBuffer)) return r.byteLength;
            if (typeof r != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r);
            let t = r.length,
                n = arguments.length > 2 && arguments[2] === !0;
            if (!n && t === 0) return 0;
            let i = !1;
            for (;;) switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                    return t;
                case "utf8":
                case "utf-8":
                    return b0(r).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return t * 2;
                case "hex":
                    return t >>> 1;
                case "base64":
                    return _b(r).length;
                default:
                    if (i) return n ? -1 : b0(r).length;
                    e = ("" + e).toLowerCase(), i = !0
            }
        }
        X.byteLength = db;

        function S5(r, e, t) {
            let n = !1;
            if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e)) return "";
            for (r || (r = "utf8");;) switch (r) {
                case "hex":
                    return z5(this, e, t);
                case "utf8":
                case "utf-8":
                    return yb(this, e, t);
                case "ascii":
                    return T5(this, e, t);
                case "latin1":
                case "binary":
                    return L5(this, e, t);
                case "base64":
                    return k5(this, e, t);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return U5(this, e, t);
                default:
                    if (n) throw new TypeError("Unknown encoding: " + r);
                    r = (r + "").toLowerCase(), n = !0
            }
        }
        X.prototype._isBuffer = !0;

        function qo(r, e, t) {
            let n = r[e];
            r[e] = r[t], r[t] = n
        }
        X.prototype.swap16 = function() {
            let e = this.length;
            if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let t = 0; t < e; t += 2) qo(this, t, t + 1);
            return this
        };
        X.prototype.swap32 = function() {
            let e = this.length;
            if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let t = 0; t < e; t += 4) qo(this, t, t + 3), qo(this, t + 1, t + 2);
            return this
        };
        X.prototype.swap64 = function() {
            let e = this.length;
            if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let t = 0; t < e; t += 8) qo(this, t, t + 7), qo(this, t + 1, t + 6), qo(this, t + 2, t + 5), qo(this, t + 3, t + 4);
            return this
        };
        X.prototype.toString = function() {
            let e = this.length;
            return e === 0 ? "" : arguments.length === 0 ? yb(this, 0, e) : S5.apply(this, arguments)
        };
        X.prototype.toLocaleString = X.prototype.toString;
        X.prototype.equals = function(e) {
            if (!X.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
            return this === e ? !0 : X.compare(this, e) === 0
        };
        X.prototype.inspect = function() {
            let e = "",
                t = Ms.INSPECT_MAX_BYTES;
            return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">"
        };
        ab && (X.prototype[ab] = X.prototype.inspect);
        X.prototype.compare = function(e, t, n, i, o) {
            if (fi(e, Uint8Array) && (e = X.from(e, e.offset, e.byteLength)), !X.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
            if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), o === void 0 && (o = this.length), t < 0 || n > e.length || i < 0 || o > this.length) throw new RangeError("out of range index");
            if (i >= o && t >= n) return 0;
            if (i >= o) return -1;
            if (t >= n) return 1;
            if (t >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === e) return 0;
            let a = o - i,
                y = n - t,
                g = Math.min(a, y),
                E = this.slice(i, o),
                A = e.slice(t, n);
            for (let I = 0; I < g; ++I)
                if (E[I] !== A[I]) {
                    a = E[I], y = A[I];
                    break
                } return a < y ? -1 : y < a ? 1 : 0
        };

        function pb(r, e, t, n, i) {
            if (r.length === 0) return -1;
            if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, _0(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
                if (i) return -1;
                t = r.length - 1
            } else if (t < 0)
                if (i) t = 0;
                else return -1;
            if (typeof e == "string" && (e = X.from(e, n)), X.isBuffer(e)) return e.length === 0 ? -1 : fb(r, e, t, n, i);
            if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : fb(r, [e], t, n, i);
            throw new TypeError("val must be string, number or Buffer")
        }

        function fb(r, e, t, n, i) {
            let o = 1,
                a = r.length,
                y = e.length;
            if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
                if (r.length < 2 || e.length < 2) return -1;
                o = 2, a /= 2, y /= 2, t /= 2
            }

            function g(A, I) {
                return o === 1 ? A[I] : A.readUInt16BE(I * o)
            }
            let E;
            if (i) {
                let A = -1;
                for (E = t; E < a; E++)
                    if (g(r, E) === g(e, A === -1 ? 0 : E - A)) {
                        if (A === -1 && (A = E), E - A + 1 === y) return A * o
                    } else A !== -1 && (E -= E - A), A = -1
            } else
                for (t + y > a && (t = a - y), E = t; E >= 0; E--) {
                    let A = !0;
                    for (let I = 0; I < y; I++)
                        if (g(r, E + I) !== g(e, I)) {
                            A = !1;
                            break
                        } if (A) return E
                }
            return -1
        }
        X.prototype.includes = function(e, t, n) {
            return this.indexOf(e, t, n) !== -1
        };
        X.prototype.indexOf = function(e, t, n) {
            return pb(this, e, t, n, !0)
        };
        X.prototype.lastIndexOf = function(e, t, n) {
            return pb(this, e, t, n, !1)
        };

        function M5(r, e, t, n) {
            t = Number(t) || 0;
            let i = r.length - t;
            n ? (n = Number(n), n > i && (n = i)) : n = i;
            let o = e.length;
            n > o / 2 && (n = o / 2);
            let a;
            for (a = 0; a < n; ++a) {
                let y = parseInt(e.substr(a * 2, 2), 16);
                if (_0(y)) return a;
                r[t + a] = y
            }
            return a
        }

        function A5(r, e, t, n) {
            return Cu(b0(e, r.length - t), r, t, n)
        }

        function I5(r, e, t, n) {
            return Cu(C5(e), r, t, n)
        }

        function B5(r, e, t, n) {
            return Cu(_b(e), r, t, n)
        }

        function R5(r, e, t, n) {
            return Cu(O5(e, r.length - t), r, t, n)
        }
        X.prototype.write = function(e, t, n, i) {
            if (t === void 0) i = "utf8", n = this.length, t = 0;
            else if (n === void 0 && typeof t == "string") i = t, n = this.length, t = 0;
            else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
            else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            let o = this.length - t;
            if ((n === void 0 || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            i || (i = "utf8");
            let a = !1;
            for (;;) switch (i) {
                case "hex":
                    return M5(this, e, t, n);
                case "utf8":
                case "utf-8":
                    return A5(this, e, t, n);
                case "ascii":
                case "latin1":
                case "binary":
                    return I5(this, e, t, n);
                case "base64":
                    return B5(this, e, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return R5(this, e, t, n);
                default:
                    if (a) throw new TypeError("Unknown encoding: " + i);
                    i = ("" + i).toLowerCase(), a = !0
            }
        };
        X.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        };

        function k5(r, e, t) {
            return e === 0 && t === r.length ? y0.fromByteArray(r) : y0.fromByteArray(r.slice(e, t))
        }

        function yb(r, e, t) {
            t = Math.min(r.length, t);
            let n = [],
                i = e;
            for (; i < t;) {
                let o = r[i],
                    a = null,
                    y = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
                if (i + y <= t) {
                    let g, E, A, I;
                    switch (y) {
                        case 1:
                            o < 128 && (a = o);
                            break;
                        case 2:
                            g = r[i + 1], (g & 192) === 128 && (I = (o & 31) << 6 | g & 63, I > 127 && (a = I));
                            break;
                        case 3:
                            g = r[i + 1], E = r[i + 2], (g & 192) === 128 && (E & 192) === 128 && (I = (o & 15) << 12 | (g & 63) << 6 | E & 63, I > 2047 && (I < 55296 || I > 57343) && (a = I));
                            break;
                        case 4:
                            g = r[i + 1], E = r[i + 2], A = r[i + 3], (g & 192) === 128 && (E & 192) === 128 && (A & 192) === 128 && (I = (o & 15) << 18 | (g & 63) << 12 | (E & 63) << 6 | A & 63, I > 65535 && I < 1114112 && (a = I))
                    }
                }
                a === null ? (a = 65533, y = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), n.push(a), i += y
            }
            return P5(n)
        }
        var ub = 4096;

        function P5(r) {
            let e = r.length;
            if (e <= ub) return String.fromCharCode.apply(String, r);
            let t = "",
                n = 0;
            for (; n < e;) t += String.fromCharCode.apply(String, r.slice(n, n += ub));
            return t
        }

        function T5(r, e, t) {
            let n = "";
            t = Math.min(r.length, t);
            for (let i = e; i < t; ++i) n += String.fromCharCode(r[i] & 127);
            return n
        }

        function L5(r, e, t) {
            let n = "";
            t = Math.min(r.length, t);
            for (let i = e; i < t; ++i) n += String.fromCharCode(r[i]);
            return n
        }

        function z5(r, e, t) {
            let n = r.length;
            (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
            let i = "";
            for (let o = e; o < t; ++o) i += D5[r[o]];
            return i
        }

        function U5(r, e, t) {
            let n = r.slice(e, t),
                i = "";
            for (let o = 0; o < n.length - 1; o += 2) i += String.fromCharCode(n[o] + n[o + 1] * 256);
            return i
        }
        X.prototype.slice = function(e, t) {
            let n = this.length;
            e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
            let i = this.subarray(e, t);
            return Object.setPrototypeOf(i, X.prototype), i
        };

        function kr(r, e, t) {
            if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
            if (r + e > t) throw new RangeError("Trying to access beyond buffer length")
        }
        X.prototype.readUintLE = X.prototype.readUIntLE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || kr(e, t, this.length);
            let i = this[e],
                o = 1,
                a = 0;
            for (; ++a < t && (o *= 256);) i += this[e + a] * o;
            return i
        };
        X.prototype.readUintBE = X.prototype.readUIntBE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || kr(e, t, this.length);
            let i = this[e + --t],
                o = 1;
            for (; t > 0 && (o *= 256);) i += this[e + --t] * o;
            return i
        };
        X.prototype.readUint8 = X.prototype.readUInt8 = function(e, t) {
            return e = e >>> 0, t || kr(e, 1, this.length), this[e]
        };
        X.prototype.readUint16LE = X.prototype.readUInt16LE = function(e, t) {
            return e = e >>> 0, t || kr(e, 2, this.length), this[e] | this[e + 1] << 8
        };
        X.prototype.readUint16BE = X.prototype.readUInt16BE = function(e, t) {
            return e = e >>> 0, t || kr(e, 2, this.length), this[e] << 8 | this[e + 1]
        };
        X.prototype.readUint32LE = X.prototype.readUInt32LE = function(e, t) {
            return e = e >>> 0, t || kr(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216
        };
        X.prototype.readUint32BE = X.prototype.readUInt32BE = function(e, t) {
            return e = e >>> 0, t || kr(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
        };
        X.prototype.readBigUInt64LE = oo(function(e) {
            e = e >>> 0, Ss(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && ma(e, this.length - 8);
            let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24,
                o = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24;
            return BigInt(i) + (BigInt(o) << BigInt(32))
        });
        X.prototype.readBigUInt64BE = oo(function(e) {
            e = e >>> 0, Ss(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && ma(e, this.length - 8);
            let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e],
                o = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n;
            return (BigInt(i) << BigInt(32)) + BigInt(o)
        });
        X.prototype.readIntLE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || kr(e, t, this.length);
            let i = this[e],
                o = 1,
                a = 0;
            for (; ++a < t && (o *= 256);) i += this[e + a] * o;
            return o *= 128, i >= o && (i -= Math.pow(2, 8 * t)), i
        };
        X.prototype.readIntBE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || kr(e, t, this.length);
            let i = t,
                o = 1,
                a = this[e + --i];
            for (; i > 0 && (o *= 256);) a += this[e + --i] * o;
            return o *= 128, a >= o && (a -= Math.pow(2, 8 * t)), a
        };
        X.prototype.readInt8 = function(e, t) {
            return e = e >>> 0, t || kr(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
        };
        X.prototype.readInt16LE = function(e, t) {
            e = e >>> 0, t || kr(e, 2, this.length);
            let n = this[e] | this[e + 1] << 8;
            return n & 32768 ? n | 4294901760 : n
        };
        X.prototype.readInt16BE = function(e, t) {
            e = e >>> 0, t || kr(e, 2, this.length);
            let n = this[e + 1] | this[e] << 8;
            return n & 32768 ? n | 4294901760 : n
        };
        X.prototype.readInt32LE = function(e, t) {
            return e = e >>> 0, t || kr(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
        };
        X.prototype.readInt32BE = function(e, t) {
            return e = e >>> 0, t || kr(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
        };
        X.prototype.readBigInt64LE = oo(function(e) {
            e = e >>> 0, Ss(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && ma(e, this.length - 8);
            let i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24);
            return (BigInt(i) << BigInt(32)) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
        });
        X.prototype.readBigInt64BE = oo(function(e) {
            e = e >>> 0, Ss(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && ma(e, this.length - 8);
            let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
            return (BigInt(i) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n)
        });
        X.prototype.readFloatLE = function(e, t) {
            return e = e >>> 0, t || kr(e, 4, this.length), Es.read(this, e, !0, 23, 4)
        };
        X.prototype.readFloatBE = function(e, t) {
            return e = e >>> 0, t || kr(e, 4, this.length), Es.read(this, e, !1, 23, 4)
        };
        X.prototype.readDoubleLE = function(e, t) {
            return e = e >>> 0, t || kr(e, 8, this.length), Es.read(this, e, !0, 52, 8)
        };
        X.prototype.readDoubleBE = function(e, t) {
            return e = e >>> 0, t || kr(e, 8, this.length), Es.read(this, e, !1, 52, 8)
        };

        function pn(r, e, t, n, i, o) {
            if (!X.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > i || e < o) throw new RangeError('"value" argument is out of bounds');
            if (t + n > r.length) throw new RangeError("Index out of range")
        }
        X.prototype.writeUintLE = X.prototype.writeUIntLE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
                let y = Math.pow(2, 8 * n) - 1;
                pn(this, e, t, n, y, 0)
            }
            let o = 1,
                a = 0;
            for (this[t] = e & 255; ++a < n && (o *= 256);) this[t + a] = e / o & 255;
            return t + n
        };
        X.prototype.writeUintBE = X.prototype.writeUIntBE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
                let y = Math.pow(2, 8 * n) - 1;
                pn(this, e, t, n, y, 0)
            }
            let o = n - 1,
                a = 1;
            for (this[t + o] = e & 255; --o >= 0 && (a *= 256);) this[t + o] = e / a & 255;
            return t + n
        };
        X.prototype.writeUint8 = X.prototype.writeUInt8 = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1
        };
        X.prototype.writeUint16LE = X.prototype.writeUInt16LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
        };
        X.prototype.writeUint16BE = X.prototype.writeUInt16BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
        };
        X.prototype.writeUint32LE = X.prototype.writeUInt32LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4
        };
        X.prototype.writeUint32BE = X.prototype.writeUInt32BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
        };

        function mb(r, e, t, n, i) {
            wb(e, n, i, r, t, 7);
            let o = Number(e & BigInt(4294967295));
            r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o;
            let a = Number(e >> BigInt(32) & BigInt(4294967295));
            return r[t++] = a, a = a >> 8, r[t++] = a, a = a >> 8, r[t++] = a, a = a >> 8, r[t++] = a, t
        }

        function gb(r, e, t, n, i) {
            wb(e, n, i, r, t, 7);
            let o = Number(e & BigInt(4294967295));
            r[t + 7] = o, o = o >> 8, r[t + 6] = o, o = o >> 8, r[t + 5] = o, o = o >> 8, r[t + 4] = o;
            let a = Number(e >> BigInt(32) & BigInt(4294967295));
            return r[t + 3] = a, a = a >> 8, r[t + 2] = a, a = a >> 8, r[t + 1] = a, a = a >> 8, r[t] = a, t + 8
        }
        X.prototype.writeBigUInt64LE = oo(function(e, t = 0) {
            return mb(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
        });
        X.prototype.writeBigUInt64BE = oo(function(e, t = 0) {
            return gb(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
        });
        X.prototype.writeIntLE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, !i) {
                let g = Math.pow(2, 8 * n - 1);
                pn(this, e, t, n, g - 1, -g)
            }
            let o = 0,
                a = 1,
                y = 0;
            for (this[t] = e & 255; ++o < n && (a *= 256);) e < 0 && y === 0 && this[t + o - 1] !== 0 && (y = 1), this[t + o] = (e / a >> 0) - y & 255;
            return t + n
        };
        X.prototype.writeIntBE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, !i) {
                let g = Math.pow(2, 8 * n - 1);
                pn(this, e, t, n, g - 1, -g)
            }
            let o = n - 1,
                a = 1,
                y = 0;
            for (this[t + o] = e & 255; --o >= 0 && (a *= 256);) e < 0 && y === 0 && this[t + o + 1] !== 0 && (y = 1), this[t + o] = (e / a >> 0) - y & 255;
            return t + n
        };
        X.prototype.writeInt8 = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1
        };
        X.prototype.writeInt16LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
        };
        X.prototype.writeInt16BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
        };
        X.prototype.writeInt32LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
        };
        X.prototype.writeInt32BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || pn(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
        };
        X.prototype.writeBigInt64LE = oo(function(e, t = 0) {
            return mb(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        });
        X.prototype.writeBigInt64BE = oo(function(e, t = 0) {
            return gb(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        });

        function bb(r, e, t, n, i, o) {
            if (t + n > r.length) throw new RangeError("Index out of range");
            if (t < 0) throw new RangeError("Index out of range")
        }

        function xb(r, e, t, n, i) {
            return e = +e, t = t >>> 0, i || bb(r, e, t, 4, 34028234663852886e22, -34028234663852886e22), Es.write(r, e, t, n, 23, 4), t + 4
        }
        X.prototype.writeFloatLE = function(e, t, n) {
            return xb(this, e, t, !0, n)
        };
        X.prototype.writeFloatBE = function(e, t, n) {
            return xb(this, e, t, !1, n)
        };

        function vb(r, e, t, n, i) {
            return e = +e, t = t >>> 0, i || bb(r, e, t, 8, 17976931348623157e292, -17976931348623157e292), Es.write(r, e, t, n, 52, 8), t + 8
        }
        X.prototype.writeDoubleLE = function(e, t, n) {
            return vb(this, e, t, !0, n)
        };
        X.prototype.writeDoubleBE = function(e, t, n) {
            return vb(this, e, t, !1, n)
        };
        X.prototype.copy = function(e, t, n, i) {
            if (!X.isBuffer(e)) throw new TypeError("argument should be a Buffer");
            if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0) return 0;
            if (t < 0) throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
            if (i < 0) throw new RangeError("sourceEnd out of bounds");
            i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
            let o = i - n;
            return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, i) : Uint8Array.prototype.set.call(e, this.subarray(n, i), t), o
        };
        X.prototype.fill = function(e, t, n, i) {
            if (typeof e == "string") {
                if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string") throw new TypeError("encoding must be a string");
                if (typeof i == "string" && !X.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                if (e.length === 1) {
                    let a = e.charCodeAt(0);
                    (i === "utf8" && a < 128 || i === "latin1") && (e = a)
                }
            } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
            if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
            if (n <= t) return this;
            t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
            let o;
            if (typeof e == "number")
                for (o = t; o < n; ++o) this[o] = e;
            else {
                let a = X.isBuffer(e) ? e : X.from(e, i),
                    y = a.length;
                if (y === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                for (o = 0; o < n - t; ++o) this[o + t] = a[o % y]
            }
            return this
        };
        var _s = {};

        function w0(r, e, t) {
            _s[r] = class extends t {
                constructor() {
                    super(), Object.defineProperty(this, "message", {
                        value: e.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }), this.name = `${this.name} [${r}]`, this.stack, delete this.name
                }
                get code() {
                    return r
                }
                set code(i) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: i,
                        writable: !0
                    })
                }
                toString() {
                    return `${this.name} [${r}]: ${this.message}`
                }
            }
        }
        w0("ERR_BUFFER_OUT_OF_BOUNDS", function(r) {
            return r ? `${r} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
        }, RangeError);
        w0("ERR_INVALID_ARG_TYPE", function(r, e) {
            return `The "${r}" argument must be of type number. Received type ${typeof e}`
        }, TypeError);
        w0("ERR_OUT_OF_RANGE", function(r, e, t) {
            let n = `The value of "${r}" is out of range.`,
                i = t;
            return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? i = cb(String(t)) : typeof t == "bigint" && (i = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (i = cb(i)), i += "n"), n += ` It must be ${e}. Received ${i}`, n
        }, RangeError);

        function cb(r) {
            let e = "",
                t = r.length,
                n = r[0] === "-" ? 1 : 0;
            for (; t >= n + 4; t -= 3) e = `_${r.slice(t-3,t)}${e}`;
            return `${r.slice(0,t)}${e}`
        }

        function N5(r, e, t) {
            Ss(e, "offset"), (r[e] === void 0 || r[e + t] === void 0) && ma(e, r.length - (t + 1))
        }

        function wb(r, e, t, n, i, o) {
            if (r > t || r < e) {
                let a = typeof e == "bigint" ? "n" : "",
                    y;
                throw o > 3 ? e === 0 || e === BigInt(0) ? y = `>= 0${a} and < 2${a} ** ${(o+1)*8}${a}` : y = `>= -(2${a} ** ${(o+1)*8-1}${a}) and < 2 ** ${(o+1)*8-1}${a}` : y = `>= ${e}${a} and <= ${t}${a}`, new _s.ERR_OUT_OF_RANGE("value", y, r)
            }
            N5(n, i, o)
        }

        function Ss(r, e) {
            if (typeof r != "number") throw new _s.ERR_INVALID_ARG_TYPE(e, "number", r)
        }

        function ma(r, e, t) {
            throw Math.floor(r) !== r ? (Ss(r, t), new _s.ERR_OUT_OF_RANGE(t || "offset", "an integer", r)) : e < 0 ? new _s.ERR_BUFFER_OUT_OF_BOUNDS : new _s.ERR_OUT_OF_RANGE(t || "offset", `>= ${t?1:0} and <= ${e}`, r)
        }
        var q5 = /[^+/0-9A-Za-z-_]/g;

        function F5(r) {
            if (r = r.split("=")[0], r = r.trim().replace(q5, ""), r.length < 2) return "";
            for (; r.length % 4 !== 0;) r = r + "=";
            return r
        }

        function b0(r, e) {
            e = e || 1 / 0;
            let t, n = r.length,
                i = null,
                o = [];
            for (let a = 0; a < n; ++a) {
                if (t = r.charCodeAt(a), t > 55295 && t < 57344) {
                    if (!i) {
                        if (t > 56319) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        } else if (a + 1 === n) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        i = t;
                        continue
                    }
                    if (t < 56320) {
                        (e -= 3) > -1 && o.push(239, 191, 189), i = t;
                        continue
                    }
                    t = (i - 55296 << 10 | t - 56320) + 65536
                } else i && (e -= 3) > -1 && o.push(239, 191, 189);
                if (i = null, t < 128) {
                    if ((e -= 1) < 0) break;
                    o.push(t)
                } else if (t < 2048) {
                    if ((e -= 2) < 0) break;
                    o.push(t >> 6 | 192, t & 63 | 128)
                } else if (t < 65536) {
                    if ((e -= 3) < 0) break;
                    o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128)
                } else if (t < 1114112) {
                    if ((e -= 4) < 0) break;
                    o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128)
                } else throw new Error("Invalid code point")
            }
            return o
        }

        function C5(r) {
            let e = [];
            for (let t = 0; t < r.length; ++t) e.push(r.charCodeAt(t) & 255);
            return e
        }

        function O5(r, e) {
            let t, n, i, o = [];
            for (let a = 0; a < r.length && !((e -= 2) < 0); ++a) t = r.charCodeAt(a), n = t >> 8, i = t % 256, o.push(i), o.push(n);
            return o
        }

        function _b(r) {
            return y0.toByteArray(F5(r))
        }

        function Cu(r, e, t, n) {
            let i;
            for (i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i) e[i + t] = r[i];
            return i
        }

        function fi(r, e) {
            return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name
        }

        function _0(r) {
            return r !== r
        }
        var D5 = function() {
            let r = "0123456789abcdef",
                e = new Array(256);
            for (let t = 0; t < 16; ++t) {
                let n = t * 16;
                for (let i = 0; i < 16; ++i) e[n + i] = r[t] + r[i]
            }
            return e
        }();

        function oo(r) {
            return typeof BigInt > "u" ? K5 : r
        }

        function K5() {
            throw new Error("BigInt not supported")
        }
    });
    var Rs = Ue(G => {
        "use strict";
        Object.defineProperty(G, "__esModule", {
            value: !0
        });
        G.s16 = G.s8 = G.nu64be = G.u48be = G.u40be = G.u32be = G.u24be = G.u16be = G.nu64 = G.u48 = G.u40 = G.u32 = G.u24 = G.u16 = G.u8 = G.offset = G.greedy = G.Constant = G.UTF8 = G.CString = G.Blob = G.Boolean = G.BitField = G.BitStructure = G.VariantLayout = G.Union = G.UnionLayoutDiscriminator = G.UnionDiscriminator = G.Structure = G.Sequence = G.DoubleBE = G.Double = G.FloatBE = G.Float = G.NearInt64BE = G.NearInt64 = G.NearUInt64BE = G.NearUInt64 = G.IntBE = G.Int = G.UIntBE = G.UInt = G.OffsetLayout = G.GreedyCount = G.ExternalLayout = G.bindConstructorLayout = G.nameWithProperty = G.Layout = G.uint8ArrayToBuffer = G.checkUint8Array = void 0;
        G.constant = G.utf8 = G.cstr = G.blob = G.unionLayoutDiscriminator = G.union = G.seq = G.bits = G.struct = G.f64be = G.f64 = G.f32be = G.f32 = G.ns64be = G.s48be = G.s40be = G.s32be = G.s24be = G.s16be = G.ns64 = G.s48 = G.s40 = G.s32 = G.s24 = void 0;
        var S0 = Eb();

        function Bs(r) {
            if (!(r instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array")
        }
        G.checkUint8Array = Bs;

        function Vt(r) {
            return Bs(r), S0.Buffer.from(r.buffer, r.byteOffset, r.length)
        }
        G.uint8ArrayToBuffer = Vt;
        var Yt = class {
            constructor(e, t) {
                if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
                this.span = e, this.property = t
            }
            makeDestinationObject() {
                return {}
            }
            getSpan(e, t) {
                if (0 > this.span) throw new RangeError("indeterminate span");
                return this.span
            }
            replicate(e) {
                let t = Object.create(this.constructor.prototype);
                return Object.assign(t, this), t.property = e, t
            }
            fromArray(e) {}
        };
        G.Layout = Yt;

        function M0(r, e) {
            return e.property ? r + "[" + e.property + "]" : r
        }
        G.nameWithProperty = M0;

        function $5(r, e) {
            if (typeof r != "function") throw new TypeError("Class must be constructor");
            if (Object.prototype.hasOwnProperty.call(r, "layout_")) throw new Error("Class is already bound to a layout");
            if (!(e && e instanceof Yt)) throw new TypeError("layout must be a Layout");
            if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
            r.layout_ = e, e.boundConstructor_ = r, e.makeDestinationObject = () => new r, Object.defineProperty(r.prototype, "encode", {
                value(t, n) {
                    return e.encode(this, t, n)
                },
                writable: !0
            }), Object.defineProperty(r, "decode", {
                value(t, n) {
                    return e.decode(t, n)
                },
                writable: !0
            })
        }
        G.bindConstructorLayout = $5;
        var Yr = class extends Yt {
            isCount() {
                throw new Error("ExternalLayout is abstract")
            }
        };
        G.ExternalLayout = Yr;
        var Ou = class extends Yr {
            constructor(e = 1, t) {
                if (!Number.isInteger(e) || 0 >= e) throw new TypeError("elementSpan must be a (positive) integer");
                super(-1, t), this.elementSpan = e
            }
            isCount() {
                return !0
            }
            decode(e, t = 0) {
                Bs(e);
                let n = e.length - t;
                return Math.floor(n / this.elementSpan)
            }
            encode(e, t, n) {
                return 0
            }
        };
        G.GreedyCount = Ou;
        var ga = class extends Yr {
            constructor(e, t = 0, n) {
                if (!(e instanceof Yt)) throw new TypeError("layout must be a Layout");
                if (!Number.isInteger(t)) throw new TypeError("offset must be integer or undefined");
                super(e.span, n || e.property), this.layout = e, this.offset = t
            }
            isCount() {
                return this.layout instanceof yn || this.layout instanceof wn
            }
            decode(e, t = 0) {
                return this.layout.decode(e, t + this.offset)
            }
            encode(e, t, n = 0) {
                return this.layout.encode(e, t, n + this.offset)
            }
        };
        G.OffsetLayout = ga;
        var yn = class extends Yt {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t = 0) {
                return Vt(e).readUIntLE(t, this.span)
            }
            encode(e, t, n = 0) {
                return Vt(t).writeUIntLE(e, n, this.span), this.span
            }
        };
        G.UInt = yn;
        var wn = class extends Yt {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t = 0) {
                return Vt(e).readUIntBE(t, this.span)
            }
            encode(e, t, n = 0) {
                return Vt(t).writeUIntBE(e, n, this.span), this.span
            }
        };
        G.UIntBE = wn;
        var Fi = class extends Yt {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t = 0) {
                return Vt(e).readIntLE(t, this.span)
            }
            encode(e, t, n = 0) {
                return Vt(t).writeIntLE(e, n, this.span), this.span
            }
        };
        G.Int = Fi;
        var so = class extends Yt {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t = 0) {
                return Vt(e).readIntBE(t, this.span)
            }
            encode(e, t, n = 0) {
                return Vt(t).writeIntBE(e, n, this.span), this.span
            }
        };
        G.IntBE = so;
        var E0 = Math.pow(2, 32);

        function nc(r) {
            let e = Math.floor(r / E0),
                t = r - e * E0;
            return {
                hi32: e,
                lo32: t
            }
        }

        function ic(r, e) {
            return r * E0 + e
        }
        var Du = class extends Yt {
            constructor(e) {
                super(8, e)
            }
            decode(e, t = 0) {
                let n = Vt(e),
                    i = n.readUInt32LE(t),
                    o = n.readUInt32LE(t + 4);
                return ic(o, i)
            }
            encode(e, t, n = 0) {
                let i = nc(e),
                    o = Vt(t);
                return o.writeUInt32LE(i.lo32, n), o.writeUInt32LE(i.hi32, n + 4), 8
            }
        };
        G.NearUInt64 = Du;
        var Ku = class extends Yt {
            constructor(e) {
                super(8, e)
            }
            decode(e, t = 0) {
                let n = Vt(e),
                    i = n.readUInt32BE(t),
                    o = n.readUInt32BE(t + 4);
                return ic(i, o)
            }
            encode(e, t, n = 0) {
                let i = nc(e),
                    o = Vt(t);
                return o.writeUInt32BE(i.hi32, n), o.writeUInt32BE(i.lo32, n + 4), 8
            }
        };
        G.NearUInt64BE = Ku;
        var $u = class extends Yt {
            constructor(e) {
                super(8, e)
            }
            decode(e, t = 0) {
                let n = Vt(e),
                    i = n.readUInt32LE(t),
                    o = n.readInt32LE(t + 4);
                return ic(o, i)
            }
            encode(e, t, n = 0) {
                let i = nc(e),
                    o = Vt(t);
                return o.writeUInt32LE(i.lo32, n), o.writeInt32LE(i.hi32, n + 4), 8
            }
        };
        G.NearInt64 = $u;
        var ju = class extends Yt {
            constructor(e) {
                super(8, e)
            }
            decode(e, t = 0) {
                let n = Vt(e),
                    i = n.readInt32BE(t),
                    o = n.readUInt32BE(t + 4);
                return ic(i, o)
            }
            encode(e, t, n = 0) {
                let i = nc(e),
                    o = Vt(t);
                return o.writeInt32BE(i.hi32, n), o.writeUInt32BE(i.lo32, n + 4), 8
            }
        };
        G.NearInt64BE = ju;
        var Wu = class extends Yt {
            constructor(e) {
                super(4, e)
            }
            decode(e, t = 0) {
                return Vt(e).readFloatLE(t)
            }
            encode(e, t, n = 0) {
                return Vt(t).writeFloatLE(e, n), 4
            }
        };
        G.Float = Wu;
        var Hu = class extends Yt {
            constructor(e) {
                super(4, e)
            }
            decode(e, t = 0) {
                return Vt(e).readFloatBE(t)
            }
            encode(e, t, n = 0) {
                return Vt(t).writeFloatBE(e, n), 4
            }
        };
        G.FloatBE = Hu;
        var Vu = class extends Yt {
            constructor(e) {
                super(8, e)
            }
            decode(e, t = 0) {
                return Vt(e).readDoubleLE(t)
            }
            encode(e, t, n = 0) {
                return Vt(t).writeDoubleLE(e, n), 8
            }
        };
        G.Double = Vu;
        var Gu = class extends Yt {
            constructor(e) {
                super(8, e)
            }
            decode(e, t = 0) {
                return Vt(e).readDoubleBE(t)
            }
            encode(e, t, n = 0) {
                return Vt(t).writeDoubleBE(e, n), 8
            }
        };
        G.DoubleBE = Gu;
        var Zu = class extends Yt {
            constructor(e, t, n) {
                if (!(e instanceof Yt)) throw new TypeError("elementLayout must be a Layout");
                if (!(t instanceof Yr && t.isCount() || Number.isInteger(t) && 0 <= t)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
                let i = -1;
                !(t instanceof Yr) && 0 < e.span && (i = t * e.span), super(i, n), this.elementLayout = e, this.count = t
            }
            getSpan(e, t = 0) {
                if (0 <= this.span) return this.span;
                let n = 0,
                    i = this.count;
                if (i instanceof Yr && (i = i.decode(e, t)), 0 < this.elementLayout.span) n = i * this.elementLayout.span;
                else {
                    let o = 0;
                    for (; o < i;) n += this.elementLayout.getSpan(e, t + n), ++o
                }
                return n
            }
            decode(e, t = 0) {
                let n = [],
                    i = 0,
                    o = this.count;
                for (o instanceof Yr && (o = o.decode(e, t)); i < o;) n.push(this.elementLayout.decode(e, t)), t += this.elementLayout.getSpan(e, t), i += 1;
                return n
            }
            encode(e, t, n = 0) {
                let i = this.elementLayout,
                    o = e.reduce((a, y) => a + i.encode(y, t, n + a), 0);
                return this.count instanceof Yr && this.count.encode(e.length, t, n), o
            }
        };
        G.Sequence = Zu;
        var Yu = class extends Yt {
            constructor(e, t, n) {
                if (!(Array.isArray(e) && e.reduce((o, a) => o && a instanceof Yt, !0))) throw new TypeError("fields must be array of Layout instances");
                typeof t == "boolean" && n === void 0 && (n = t, t = void 0);
                for (let o of e)
                    if (0 > o.span && o.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
                let i = -1;
                try {
                    i = e.reduce((o, a) => o + a.getSpan(), 0)
                } catch {}
                super(i, t), this.fields = e, this.decodePrefixes = !!n
            }
            getSpan(e, t = 0) {
                if (0 <= this.span) return this.span;
                let n = 0;
                try {
                    n = this.fields.reduce((i, o) => {
                        let a = o.getSpan(e, t);
                        return t += a, i + a
                    }, 0)
                } catch {
                    throw new RangeError("indeterminate span")
                }
                return n
            }
            decode(e, t = 0) {
                Bs(e);
                let n = this.makeDestinationObject();
                for (let i of this.fields)
                    if (i.property !== void 0 && (n[i.property] = i.decode(e, t)), t += i.getSpan(e, t), this.decodePrefixes && e.length === t) break;
                return n
            }
            encode(e, t, n = 0) {
                let i = n,
                    o = 0,
                    a = 0;
                for (let y of this.fields) {
                    let g = y.span;
                    if (a = 0 < g ? g : 0, y.property !== void 0) {
                        let E = e[y.property];
                        E !== void 0 && (a = y.encode(E, t, n), 0 > g && (g = y.getSpan(t, n)))
                    }
                    o = n, n += g
                }
                return o + a - i
            }
            fromArray(e) {
                let t = this.makeDestinationObject();
                for (let n of this.fields) n.property !== void 0 && 0 < e.length && (t[n.property] = e.shift());
                return t
            }
            layoutFor(e) {
                if (typeof e != "string") throw new TypeError("property must be string");
                for (let t of this.fields)
                    if (t.property === e) return t
            }
            offsetOf(e) {
                if (typeof e != "string") throw new TypeError("property must be string");
                let t = 0;
                for (let n of this.fields) {
                    if (n.property === e) return t;
                    0 > n.span ? t = -1 : 0 <= t && (t += n.span)
                }
            }
        };
        G.Structure = Yu;
        var ba = class {
            constructor(e) {
                this.property = e
            }
            decode(e, t) {
                throw new Error("UnionDiscriminator is abstract")
            }
            encode(e, t, n) {
                throw new Error("UnionDiscriminator is abstract")
            }
        };
        G.UnionDiscriminator = ba;
        var Is = class extends ba {
            constructor(e, t) {
                if (!(e instanceof Yr && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
                super(t || e.property || "variant"), this.layout = e
            }
            decode(e, t) {
                return this.layout.decode(e, t)
            }
            encode(e, t, n) {
                return this.layout.encode(e, t, n)
            }
        };
        G.UnionLayoutDiscriminator = Is;
        var xa = class extends Yt {
            constructor(e, t, n) {
                let i;
                if (e instanceof yn || e instanceof wn) i = new Is(new ga(e));
                else if (e instanceof Yr && e.isCount()) i = new Is(e);
                else if (e instanceof ba) i = e;
                else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                if (t === void 0 && (t = null), !(t === null || t instanceof Yt)) throw new TypeError("defaultLayout must be null or a Layout");
                if (t !== null) {
                    if (0 > t.span) throw new Error("defaultLayout must have constant span");
                    t.property === void 0 && (t = t.replicate("content"))
                }
                let o = -1;
                t && (o = t.span, 0 <= o && (e instanceof yn || e instanceof wn) && (o += i.layout.span)), super(o, n), this.discriminator = i, this.usesPrefixDiscriminator = e instanceof yn || e instanceof wn, this.defaultLayout = t, this.registry = {};
                let a = this.defaultGetSourceVariant.bind(this);
                this.getSourceVariant = function(y) {
                    return a(y)
                }, this.configGetSourceVariant = function(y) {
                    a = y.bind(this)
                }
            }
            getSpan(e, t = 0) {
                if (0 <= this.span) return this.span;
                let n = this.getVariant(e, t);
                if (!n) throw new Error("unable to determine span for unrecognized variant");
                return n.getSpan(e, t)
            }
            defaultGetSourceVariant(e) {
                if (Object.prototype.hasOwnProperty.call(e, this.discriminator.property)) {
                    if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property)) return;
                    let t = this.registry[e[this.discriminator.property]];
                    if (t && (!t.layout || t.property && Object.prototype.hasOwnProperty.call(e, t.property))) return t
                } else
                    for (let t in this.registry) {
                        let n = this.registry[t];
                        if (n.property && Object.prototype.hasOwnProperty.call(e, n.property)) return n
                    }
                throw new Error("unable to infer src variant")
            }
            decode(e, t = 0) {
                let n, i = this.discriminator,
                    o = i.decode(e, t),
                    a = this.registry[o];
                if (a === void 0) {
                    let y = this.defaultLayout,
                        g = 0;
                    this.usesPrefixDiscriminator && (g = i.layout.span), n = this.makeDestinationObject(), n[i.property] = o, n[y.property] = y.decode(e, t + g)
                } else n = a.decode(e, t);
                return n
            }
            encode(e, t, n = 0) {
                let i = this.getSourceVariant(e);
                if (i === void 0) {
                    let o = this.discriminator,
                        a = this.defaultLayout,
                        y = 0;
                    return this.usesPrefixDiscriminator && (y = o.layout.span), o.encode(e[o.property], t, n), y + a.encode(e[a.property], t, n + y)
                }
                return i.encode(e, t, n)
            }
            addVariant(e, t, n) {
                let i = new Ju(this, e, t, n);
                return this.registry[e] = i, i
            }
            getVariant(e, t = 0) {
                let n;
                return e instanceof Uint8Array ? n = this.discriminator.decode(e, t) : n = e, this.registry[n]
            }
        };
        G.Union = xa;
        var Ju = class extends Yt {
            constructor(e, t, n, i) {
                if (!(e instanceof xa)) throw new TypeError("union must be a Union");
                if (!Number.isInteger(t) || 0 > t) throw new TypeError("variant must be a (non-negative) integer");
                if (typeof n == "string" && i === void 0 && (i = n, n = null), n) {
                    if (!(n instanceof Yt)) throw new TypeError("layout must be a Layout");
                    if (e.defaultLayout !== null && 0 <= n.span && n.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                    if (typeof i != "string") throw new TypeError("variant must have a String property")
                }
                let o = e.span;
                0 > e.span && (o = n ? n.span : 0, 0 <= o && e.usesPrefixDiscriminator && (o += e.discriminator.layout.span)), super(o, i), this.union = e, this.variant = t, this.layout = n || null
            }
            getSpan(e, t = 0) {
                if (0 <= this.span) return this.span;
                let n = 0;
                this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span);
                let i = 0;
                return this.layout && (i = this.layout.getSpan(e, t + n)), n + i
            }
            decode(e, t = 0) {
                let n = this.makeDestinationObject();
                if (this !== this.union.getVariant(e, t)) throw new Error("variant mismatch");
                let i = 0;
                return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(e, t + i) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n
            }
            encode(e, t, n = 0) {
                let i = 0;
                if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(e, this.property)) throw new TypeError("variant lacks property " + this.property);
                this.union.discriminator.encode(this.variant, t, n);
                let o = i;
                if (this.layout && (this.layout.encode(e[this.property], t, n + i), o += this.layout.getSpan(t, n + i), 0 <= this.union.span && o > this.union.span)) throw new Error("encoded variant overruns containing union");
                return o
            }
            fromArray(e) {
                if (this.layout) return this.layout.fromArray(e)
            }
        };
        G.VariantLayout = Ju;

        function As(r) {
            return 0 > r && (r += 4294967296), r
        }
        var va = class extends Yt {
            constructor(e, t, n) {
                if (!(e instanceof yn || e instanceof wn)) throw new TypeError("word must be a UInt or UIntBE layout");
                if (typeof t == "string" && n === void 0 && (n = t, t = !1), 4 < e.span) throw new RangeError("word cannot exceed 32 bits");
                super(e.span, n), this.word = e, this.msb = !!t, this.fields = [];
                let i = 0;
                this._packedSetValue = function(o) {
                    return i = As(o), this
                }, this._packedGetValue = function() {
                    return i
                }
            }
            decode(e, t = 0) {
                let n = this.makeDestinationObject(),
                    i = this.word.decode(e, t);
                this._packedSetValue(i);
                for (let o of this.fields) o.property !== void 0 && (n[o.property] = o.decode(e));
                return n
            }
            encode(e, t, n = 0) {
                let i = this.word.decode(t, n);
                this._packedSetValue(i);
                for (let o of this.fields)
                    if (o.property !== void 0) {
                        let a = e[o.property];
                        a !== void 0 && o.encode(a)
                    } return this.word.encode(this._packedGetValue(), t, n)
            }
            addField(e, t) {
                let n = new wa(this, e, t);
                return this.fields.push(n), n
            }
            addBoolean(e) {
                let t = new Xu(this, e);
                return this.fields.push(t), t
            }
            fieldFor(e) {
                if (typeof e != "string") throw new TypeError("property must be string");
                for (let t of this.fields)
                    if (t.property === e) return t
            }
        };
        G.BitStructure = va;
        var wa = class {
            constructor(e, t, n) {
                if (!(e instanceof va)) throw new TypeError("container must be a BitStructure");
                if (!Number.isInteger(t) || 0 >= t) throw new TypeError("bits must be positive integer");
                let i = 8 * e.span,
                    o = e.fields.reduce((a, y) => a + y.bits, 0);
                if (t + o > i) throw new Error("bits too long for span remainder (" + (i - o) + " of " + i + " remain)");
                this.container = e, this.bits = t, this.valueMask = (1 << t) - 1, t === 32 && (this.valueMask = 4294967295), this.start = o, this.container.msb && (this.start = i - o - t), this.wordMask = As(this.valueMask << this.start), this.property = n
            }
            decode(e, t) {
                let n = this.container._packedGetValue();
                return As(n & this.wordMask) >>> this.start
            }
            encode(e) {
                if (typeof e != "number" || !Number.isInteger(e) || e !== As(e & this.valueMask)) throw new TypeError(M0("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
                let t = this.container._packedGetValue(),
                    n = As(e << this.start);
                this.container._packedSetValue(As(t & ~this.wordMask) | n)
            }
        };
        G.BitField = wa;
        var Xu = class extends wa {
            constructor(e, t) {
                super(e, 1, t)
            }
            decode(e, t) {
                return !!super.decode(e, t)
            }
            encode(e) {
                typeof e == "boolean" && (e = +e), super.encode(e)
            }
        };
        G.Boolean = Xu;
        var Qu = class extends Yt {
            constructor(e, t) {
                if (!(e instanceof Yr && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                let n = -1;
                e instanceof Yr || (n = e), super(n, t), this.length = e
            }
            getSpan(e, t) {
                let n = this.span;
                return 0 > n && (n = this.length.decode(e, t)), n
            }
            decode(e, t = 0) {
                let n = this.span;
                return 0 > n && (n = this.length.decode(e, t)), Vt(e).slice(t, t + n)
            }
            encode(e, t, n) {
                let i = this.length;
                if (this.length instanceof Yr && (i = e.length), !(e instanceof Uint8Array && i === e.length)) throw new TypeError(M0("Blob.encode", this) + " requires (length " + i + ") Uint8Array as src");
                if (n + i > t.length) throw new RangeError("encoding overruns Uint8Array");
                let o = Vt(e);
                return Vt(t).write(o.toString("hex"), n, i, "hex"), this.length instanceof Yr && this.length.encode(i, t, n), i
            }
        };
        G.Blob = Qu;
        var ec = class extends Yt {
            constructor(e) {
                super(-1, e)
            }
            getSpan(e, t = 0) {
                Bs(e);
                let n = t;
                for (; n < e.length && e[n] !== 0;) n += 1;
                return 1 + n - t
            }
            decode(e, t = 0) {
                let n = this.getSpan(e, t);
                return Vt(e).slice(t, t + n - 1).toString("utf-8")
            }
            encode(e, t, n = 0) {
                typeof e != "string" && (e = String(e));
                let i = S0.Buffer.from(e, "utf8"),
                    o = i.length;
                if (n + o > t.length) throw new RangeError("encoding overruns Buffer");
                let a = Vt(t);
                return i.copy(a, n), a[n + o] = 0, o + 1
            }
        };
        G.CString = ec;
        var tc = class extends Yt {
            constructor(e, t) {
                if (typeof e == "string" && t === void 0 && (t = e, e = void 0), e === void 0) e = -1;
                else if (!Number.isInteger(e)) throw new TypeError("maxSpan must be an integer");
                super(-1, t), this.maxSpan = e
            }
            getSpan(e, t = 0) {
                return Bs(e), e.length - t
            }
            decode(e, t = 0) {
                let n = this.getSpan(e, t);
                if (0 <= this.maxSpan && this.maxSpan < n) throw new RangeError("text length exceeds maxSpan");
                return Vt(e).slice(t, t + n).toString("utf-8")
            }
            encode(e, t, n = 0) {
                typeof e != "string" && (e = String(e));
                let i = S0.Buffer.from(e, "utf8"),
                    o = i.length;
                if (0 <= this.maxSpan && this.maxSpan < o) throw new RangeError("text length exceeds maxSpan");
                if (n + o > t.length) throw new RangeError("encoding overruns Buffer");
                return i.copy(Vt(t), n), o
            }
        };
        G.UTF8 = tc;
        var rc = class extends Yt {
            constructor(e, t) {
                super(0, t), this.value = e
            }
            decode(e, t) {
                return this.value
            }
            encode(e, t, n) {
                return 0
            }
        };
        G.Constant = rc;
        G.greedy = (r, e) => new Ou(r, e);
        G.offset = (r, e, t) => new ga(r, e, t);
        G.u8 = r => new yn(1, r);
        G.u16 = r => new yn(2, r);
        G.u24 = r => new yn(3, r);
        G.u32 = r => new yn(4, r);
        G.u40 = r => new yn(5, r);
        G.u48 = r => new yn(6, r);
        G.nu64 = r => new Du(r);
        G.u16be = r => new wn(2, r);
        G.u24be = r => new wn(3, r);
        G.u32be = r => new wn(4, r);
        G.u40be = r => new wn(5, r);
        G.u48be = r => new wn(6, r);
        G.nu64be = r => new Ku(r);
        G.s8 = r => new Fi(1, r);
        G.s16 = r => new Fi(2, r);
        G.s24 = r => new Fi(3, r);
        G.s32 = r => new Fi(4, r);
        G.s40 = r => new Fi(5, r);
        G.s48 = r => new Fi(6, r);
        G.ns64 = r => new $u(r);
        G.s16be = r => new so(2, r);
        G.s24be = r => new so(3, r);
        G.s32be = r => new so(4, r);
        G.s40be = r => new so(5, r);
        G.s48be = r => new so(6, r);
        G.ns64be = r => new ju(r);
        G.f32 = r => new Wu(r);
        G.f32be = r => new Hu(r);
        G.f64 = r => new Vu(r);
        G.f64be = r => new Gu(r);
        G.struct = (r, e, t) => new Yu(r, e, t);
        G.bits = (r, e, t) => new va(r, e, t);
        G.seq = (r, e, t) => new Zu(r, e, t);
        G.union = (r, e, t) => new xa(r, e, t);
        G.unionLayoutDiscriminator = (r, e) => new Is(r, e);
        G.blob = (r, e) => new Qu(r, e);
        G.cstr = r => new ec(r);
        G.utf8 = (r, e) => new tc(r, e);
        G.constant = (r, e) => new rc(r, e)
    });
    var sc = Ue((FT, Ea) => {
        function Z5(r) {
            return r && r.__esModule ? r : {
                default: r
            }
        }
        Ea.exports = Z5, Ea.exports.__esModule = !0, Ea.exports.default = Ea.exports
    });
    var ac = Ue((CT, Sa) => {
        function Bb(r, e) {
            for (var t = 0; t < e.length; t++) {
                var n = e[t];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, n.key, n)
            }
        }

        function Y5(r, e, t) {
            return e && Bb(r.prototype, e), t && Bb(r, t), Object.defineProperty(r, "prototype", {
                writable: !1
            }), r
        }
        Sa.exports = Y5, Sa.exports.__esModule = !0, Sa.exports.default = Sa.exports
    });
    var fc = Ue((OT, Ma) => {
        function J5(r, e) {
            if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function")
        }
        Ma.exports = J5, Ma.exports.__esModule = !0, Ma.exports.default = Ma.exports
    });
    var Rb = Ue((DT, Ci) => {
        function k0(r, e) {
            return Ci.exports = k0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
                return n.__proto__ = i, n
            }, Ci.exports.__esModule = !0, Ci.exports.default = Ci.exports, k0(r, e)
        }
        Ci.exports = k0, Ci.exports.__esModule = !0, Ci.exports.default = Ci.exports
    });
    var uc = Ue((KT, Aa) => {
        var X5 = Rb();

        function Q5(r, e) {
            if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
            r.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: r,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(r, "prototype", {
                writable: !1
            }), e && X5(r, e)
        }
        Aa.exports = Q5, Aa.exports.__esModule = !0, Aa.exports.default = Aa.exports
    });
    var cc = Ue(($T, Oi) => {
        function P0(r) {
            return Oi.exports = P0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
                return typeof e
            } : function(e) {
                return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            }, Oi.exports.__esModule = !0, Oi.exports.default = Oi.exports, P0(r)
        }
        Oi.exports = P0, Oi.exports.__esModule = !0, Oi.exports.default = Oi.exports
    });
    var kb = Ue((jT, Ia) => {
        function e7(r) {
            if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r
        }
        Ia.exports = e7, Ia.exports.__esModule = !0, Ia.exports.default = Ia.exports
    });
    var hc = Ue((WT, Ba) => {
        var t7 = cc().default,
            r7 = kb();

        function n7(r, e) {
            if (e && (t7(e) === "object" || typeof e == "function")) return e;
            if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return r7(r)
        }
        Ba.exports = n7, Ba.exports.__esModule = !0, Ba.exports.default = Ba.exports
    });
    var lc = Ue((HT, Di) => {
        function T0(r) {
            return Di.exports = T0 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, Di.exports.__esModule = !0, Di.exports.default = Di.exports, T0(r)
        }
        Di.exports = T0, Di.exports.__esModule = !0, Di.exports.default = Di.exports
    });
    var Tb = Ue(L0 => {
        "use strict";
        var Ra = sc();
        Object.defineProperty(L0, "__esModule", {
            value: !0
        });
        L0.default = l7;
        var i7 = Ra(fc()),
            o7 = Ra(ac()),
            s7 = Ra(uc()),
            a7 = Ra(hc()),
            Pb = Ra(lc()),
            f7 = pa();

        function u7(r) {
            var e = c7();
            return function() {
                var n = (0, Pb.default)(r),
                    i;
                if (e) {
                    var o = (0, Pb.default)(this).constructor;
                    i = Reflect.construct(n, arguments, o)
                } else i = n.apply(this, arguments);
                return (0, a7.default)(this, i)
            }
        }

        function c7() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
            if (typeof Proxy == "function") return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
            } catch {
                return !1
            }
        }
        var h7 = function(r) {
            (0, s7.default)(t, r);
            var e = u7(t);

            function t(n, i, o) {
                var a;
                return (0, i7.default)(this, t), a = e.call(this), a.socket = new window.WebSocket(n, o), a.socket.onopen = function() {
                    return a.emit("open")
                }, a.socket.onmessage = function(y) {
                    return a.emit("message", y.data)
                }, a.socket.onerror = function(y) {
                    return a.emit("error", y)
                }, a.socket.onclose = function(y) {
                    a.emit("close", y.code, y.reason)
                }, a
            }
            return (0, o7.default)(t, [{
                key: "send",
                value: function(i, o, a) {
                    var y = a || o;
                    try {
                        this.socket.send(i), y()
                    } catch (g) {
                        y(g)
                    }
                }
            }, {
                key: "close",
                value: function(i, o) {
                    this.socket.close(i, o)
                }
            }, {
                key: "addEventListener",
                value: function(i, o, a) {
                    this.socket.addEventListener(i, o, a)
                }
            }]), t
        }(f7.EventEmitter);

        function l7(r, e) {
            return new h7(r, e)
        }
    });
    var zb = Ue((GT, Ki) => {
        var d7 = cc().default;

        function Lb() {
            "use strict";
            Ki.exports = Lb = function() {
                return r
            }, Ki.exports.__esModule = !0, Ki.exports.default = Ki.exports;
            var r = {},
                e = Object.prototype,
                t = e.hasOwnProperty,
                n = typeof Symbol == "function" ? Symbol : {},
                i = n.iterator || "@@iterator",
                o = n.asyncIterator || "@@asyncIterator",
                a = n.toStringTag || "@@toStringTag";

            function y(T, m, w) {
                return Object.defineProperty(T, m, {
                    value: w,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), T[m]
            }
            try {
                y({}, "")
            } catch {
                y = function(w, l, s) {
                    return w[l] = s
                }
            }

            function g(T, m, w, l) {
                var s = m && m.prototype instanceof I ? m : I,
                    f = Object.create(s.prototype),
                    h = new we(l || []);
                return f._invoke = function(p, d, c) {
                    var x = "suspendedStart";
                    return function(v, u) {
                        if (x === "executing") throw new Error("Generator is already running");
                        if (x === "completed") {
                            if (v === "throw") throw u;
                            return gt()
                        }
                        for (c.method = v, c.arg = u;;) {
                            var _ = c.delegate;
                            if (_) {
                                var F = ie(_, c);
                                if (F) {
                                    if (F === A) continue;
                                    return F
                                }
                            }
                            if (c.method === "next") c.sent = c._sent = c.arg;
                            else if (c.method === "throw") {
                                if (x === "suspendedStart") throw x = "completed", c.arg;
                                c.dispatchException(c.arg)
                            } else c.method === "return" && c.abrupt("return", c.arg);
                            x = "executing";
                            var S = E(p, d, c);
                            if (S.type === "normal") {
                                if (x = c.done ? "completed" : "suspendedYield", S.arg === A) continue;
                                return {
                                    value: S.arg,
                                    done: c.done
                                }
                            }
                            S.type === "throw" && (x = "completed", c.method = "throw", c.arg = S.arg)
                        }
                    }
                }(T, w, h), f
            }

            function E(T, m, w) {
                try {
                    return {
                        type: "normal",
                        arg: T.call(m, w)
                    }
                } catch (l) {
                    return {
                        type: "throw",
                        arg: l
                    }
                }
            }
            r.wrap = g;
            var A = {};

            function I() {}

            function q() {}

            function L() {}
            var O = {};
            y(O, i, function() {
                return this
            });
            var Z = Object.getPrototypeOf,
                ge = Z && Z(Z(he([])));
            ge && ge !== e && t.call(ge, i) && (O = ge);
            var ce = L.prototype = I.prototype = Object.create(O);

            function Xe(T) {
                ["next", "throw", "return"].forEach(function(m) {
                    y(T, m, function(w) {
                        return this._invoke(m, w)
                    })
                })
            }

            function xe(T, m) {
                function w(s, f, h, p) {
                    var d = E(T[s], T, f);
                    if (d.type !== "throw") {
                        var c = d.arg,
                            x = c.value;
                        return x && d7(x) == "object" && t.call(x, "__await") ? m.resolve(x.__await).then(function(v) {
                            w("next", v, h, p)
                        }, function(v) {
                            w("throw", v, h, p)
                        }) : m.resolve(x).then(function(v) {
                            c.value = v, h(c)
                        }, function(v) {
                            return w("throw", v, h, p)
                        })
                    }
                    p(d.arg)
                }
                var l;
                this._invoke = function(s, f) {
                    function h() {
                        return new m(function(p, d) {
                            w(s, f, p, d)
                        })
                    }
                    return l = l ? l.then(h, h) : h()
                }
            }

            function ie(T, m) {
                var w = T.iterator[m.method];
                if (w === void 0) {
                    if (m.delegate = null, m.method === "throw") {
                        if (T.iterator.return && (m.method = "return", m.arg = void 0, ie(T, m), m.method === "throw")) return A;
                        m.method = "throw", m.arg = new TypeError("The iterator does not provide a 'throw' method")
                    }
                    return A
                }
                var l = E(w, T.iterator, m.arg);
                if (l.type === "throw") return m.method = "throw", m.arg = l.arg, m.delegate = null, A;
                var s = l.arg;
                return s ? s.done ? (m[T.resultName] = s.value, m.next = T.nextLoc, m.method !== "return" && (m.method = "next", m.arg = void 0), m.delegate = null, A) : s : (m.method = "throw", m.arg = new TypeError("iterator result is not an object"), m.delegate = null, A)
            }

            function ae(T) {
                var m = {
                    tryLoc: T[0]
                };
                1 in T && (m.catchLoc = T[1]), 2 in T && (m.finallyLoc = T[2], m.afterLoc = T[3]), this.tryEntries.push(m)
            }

            function be(T) {
                var m = T.completion || {};
                m.type = "normal", delete m.arg, T.completion = m
            }

            function we(T) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], T.forEach(ae, this), this.reset(!0)
            }

            function he(T) {
                if (T) {
                    var m = T[i];
                    if (m) return m.call(T);
                    if (typeof T.next == "function") return T;
                    if (!isNaN(T.length)) {
                        var w = -1,
                            l = function s() {
                                for (; ++w < T.length;)
                                    if (t.call(T, w)) return s.value = T[w], s.done = !1, s;
                                return s.value = void 0, s.done = !0, s
                            };
                        return l.next = l
                    }
                }
                return {
                    next: gt
                }
            }

            function gt() {
                return {
                    value: void 0,
                    done: !0
                }
            }
            return q.prototype = L, y(ce, "constructor", L), y(L, "constructor", q), q.displayName = y(L, a, "GeneratorFunction"), r.isGeneratorFunction = function(T) {
                var m = typeof T == "function" && T.constructor;
                return !!m && (m === q || (m.displayName || m.name) === "GeneratorFunction")
            }, r.mark = function(T) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(T, L) : (T.__proto__ = L, y(T, a, "GeneratorFunction")), T.prototype = Object.create(ce), T
            }, r.awrap = function(T) {
                return {
                    __await: T
                }
            }, Xe(xe.prototype), y(xe.prototype, o, function() {
                return this
            }), r.AsyncIterator = xe, r.async = function(T, m, w, l, s) {
                s === void 0 && (s = Promise);
                var f = new xe(g(T, m, w, l), s);
                return r.isGeneratorFunction(m) ? f : f.next().then(function(h) {
                    return h.done ? h.value : f.next()
                })
            }, Xe(ce), y(ce, a, "Generator"), y(ce, i, function() {
                return this
            }), y(ce, "toString", function() {
                return "[object Generator]"
            }), r.keys = function(T) {
                var m = [];
                for (var w in T) m.push(w);
                return m.reverse(),
                    function l() {
                        for (; m.length;) {
                            var s = m.pop();
                            if (s in T) return l.value = s, l.done = !1, l
                        }
                        return l.done = !0, l
                    }
            }, r.values = he, we.prototype = {
                constructor: we,
                reset: function(m) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(be), !m)
                        for (var w in this) w.charAt(0) === "t" && t.call(this, w) && !isNaN(+w.slice(1)) && (this[w] = void 0)
                },
                stop: function() {
                    this.done = !0;
                    var m = this.tryEntries[0].completion;
                    if (m.type === "throw") throw m.arg;
                    return this.rval
                },
                dispatchException: function(m) {
                    if (this.done) throw m;
                    var w = this;

                    function l(c, x) {
                        return h.type = "throw", h.arg = m, w.next = c, x && (w.method = "next", w.arg = void 0), !!x
                    }
                    for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                        var f = this.tryEntries[s],
                            h = f.completion;
                        if (f.tryLoc === "root") return l("end");
                        if (f.tryLoc <= this.prev) {
                            var p = t.call(f, "catchLoc"),
                                d = t.call(f, "finallyLoc");
                            if (p && d) {
                                if (this.prev < f.catchLoc) return l(f.catchLoc, !0);
                                if (this.prev < f.finallyLoc) return l(f.finallyLoc)
                            } else if (p) {
                                if (this.prev < f.catchLoc) return l(f.catchLoc, !0)
                            } else {
                                if (!d) throw new Error("try statement without catch or finally");
                                if (this.prev < f.finallyLoc) return l(f.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function(m, w) {
                    for (var l = this.tryEntries.length - 1; l >= 0; --l) {
                        var s = this.tryEntries[l];
                        if (s.tryLoc <= this.prev && t.call(s, "finallyLoc") && this.prev < s.finallyLoc) {
                            var f = s;
                            break
                        }
                    }
                    f && (m === "break" || m === "continue") && f.tryLoc <= w && w <= f.finallyLoc && (f = null);
                    var h = f ? f.completion : {};
                    return h.type = m, h.arg = w, f ? (this.method = "next", this.next = f.finallyLoc, A) : this.complete(h)
                },
                complete: function(m, w) {
                    if (m.type === "throw") throw m.arg;
                    return m.type === "break" || m.type === "continue" ? this.next = m.arg : m.type === "return" ? (this.rval = this.arg = m.arg, this.method = "return", this.next = "end") : m.type === "normal" && w && (this.next = w), A
                },
                finish: function(m) {
                    for (var w = this.tryEntries.length - 1; w >= 0; --w) {
                        var l = this.tryEntries[w];
                        if (l.finallyLoc === m) return this.complete(l.completion, l.afterLoc), be(l), A
                    }
                },
                catch: function(m) {
                    for (var w = this.tryEntries.length - 1; w >= 0; --w) {
                        var l = this.tryEntries[w];
                        if (l.tryLoc === m) {
                            var s = l.completion;
                            if (s.type === "throw") {
                                var f = s.arg;
                                be(l)
                            }
                            return f
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function(m, w, l) {
                    return this.delegate = {
                        iterator: he(m),
                        resultName: w,
                        nextLoc: l
                    }, this.method === "next" && (this.arg = void 0), A
                }
            }, r
        }
        Ki.exports = Lb, Ki.exports.__esModule = !0, Ki.exports.default = Ki.exports
    });
    var Nb = Ue((ZT, Ub) => {
        var dc = zb()();
        Ub.exports = dc;
        try {
            regeneratorRuntime = dc
        } catch {
            typeof globalThis == "object" ? globalThis.regeneratorRuntime = dc : Function("r", "regeneratorRuntime = r")(dc)
        }
    });
    var Fb = Ue((YT, ka) => {
        function qb(r, e, t, n, i, o, a) {
            try {
                var y = r[o](a),
                    g = y.value
            } catch (E) {
                t(E);
                return
            }
            y.done ? e(g) : Promise.resolve(g).then(n, i)
        }

        function p7(r) {
            return function() {
                var e = this,
                    t = arguments;
                return new Promise(function(n, i) {
                    var o = r.apply(e, t);

                    function a(g) {
                        qb(o, n, i, a, y, "next", g)
                    }

                    function y(g) {
                        qb(o, n, i, a, y, "throw", g)
                    }
                    a(void 0)
                })
            }
        }
        ka.exports = p7, ka.exports.__esModule = !0, ka.exports.default = ka.exports
    });
    var Ob = Ue(yc => {
        "use strict";
        var uo = sc();
        Object.defineProperty(yc, "__esModule", {
            value: !0
        });
        yc.default = void 0;
        var fo = uo(Nb()),
            pc = uo(Fb()),
            y7 = uo(cc()),
            m7 = uo(fc()),
            g7 = uo(ac()),
            b7 = uo(uc()),
            x7 = uo(hc()),
            Cb = uo(lc()),
            v7 = pa();

        function w7(r) {
            var e = _7();
            return function() {
                var n = (0, Cb.default)(r),
                    i;
                if (e) {
                    var o = (0, Cb.default)(this).constructor;
                    i = Reflect.construct(n, arguments, o)
                } else i = n.apply(this, arguments);
                return (0, x7.default)(this, i)
            }
        }

        function _7() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
            if (typeof Proxy == "function") return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
            } catch {
                return !1
            }
        }
        var E7 = function(r, e) {
                var t = {};
                for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]);
                if (r != null && typeof Object.getOwnPropertySymbols == "function")
                    for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]);
                return t
            },
            S7 = function(r) {
                (0, b7.default)(t, r);
                var e = w7(t);

                function t(n) {
                    var i, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080",
                        a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                        y = arguments.length > 3 ? arguments[3] : void 0;
                    (0, m7.default)(this, t);
                    var g = a.autoconnect,
                        E = g === void 0 ? !0 : g,
                        A = a.reconnect,
                        I = A === void 0 ? !0 : A,
                        q = a.reconnect_interval,
                        L = q === void 0 ? 1e3 : q,
                        O = a.max_reconnects,
                        Z = O === void 0 ? 5 : O,
                        ge = E7(a, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
                    return i = e.call(this), i.webSocketFactory = n, i.queue = {}, i.rpc_id = 0, i.address = o, i.autoconnect = E, i.ready = !1, i.reconnect = I, i.reconnect_interval = L, i.max_reconnects = Z, i.rest_options = ge, i.current_reconnects = 0, i.generate_request_id = y || function() {
                        return ++i.rpc_id
                    }, i.autoconnect && i._connect(i.address, Object.assign({
                        autoconnect: i.autoconnect,
                        reconnect: i.reconnect,
                        reconnect_interval: i.reconnect_interval,
                        max_reconnects: i.max_reconnects
                    }, i.rest_options)), i
                }
                return (0, g7.default)(t, [{
                    key: "connect",
                    value: function() {
                        this.socket || this._connect(this.address, Object.assign({
                            autoconnect: this.autoconnect,
                            reconnect: this.reconnect,
                            reconnect_interval: this.reconnect_interval,
                            max_reconnects: this.max_reconnects
                        }, this.rest_options))
                    }
                }, {
                    key: "call",
                    value: function(i, o, a, y) {
                        var g = this;
                        return !y && (0, y7.default)(a) === "object" && (y = a, a = null), new Promise(function(E, A) {
                            if (!g.ready) return A(new Error("socket not ready"));
                            var I = g.generate_request_id(i, o),
                                q = {
                                    jsonrpc: "2.0",
                                    method: i,
                                    params: o || null,
                                    id: I
                                };
                            g.socket.send(JSON.stringify(q), y, function(L) {
                                if (L) return A(L);
                                g.queue[I] = {
                                    promise: [E, A]
                                }, a && (g.queue[I].timeout = setTimeout(function() {
                                    delete g.queue[I], A(new Error("reply timeout"))
                                }, a))
                            })
                        })
                    }
                }, {
                    key: "login",
                    value: function() {
                        var n = (0, pc.default)(fo.default.mark(function o(a) {
                            var y;
                            return fo.default.wrap(function(E) {
                                for (;;) switch (E.prev = E.next) {
                                    case 0:
                                        return E.next = 2, this.call("rpc.login", a);
                                    case 2:
                                        if (y = E.sent, y) {
                                            E.next = 5;
                                            break
                                        }
                                        throw new Error("authentication failed");
                                    case 5:
                                        return E.abrupt("return", y);
                                    case 6:
                                    case "end":
                                        return E.stop()
                                }
                            }, o, this)
                        }));

                        function i(o) {
                            return n.apply(this, arguments)
                        }
                        return i
                    }()
                }, {
                    key: "listMethods",
                    value: function() {
                        var n = (0, pc.default)(fo.default.mark(function o() {
                            return fo.default.wrap(function(y) {
                                for (;;) switch (y.prev = y.next) {
                                    case 0:
                                        return y.next = 2, this.call("__listMethods");
                                    case 2:
                                        return y.abrupt("return", y.sent);
                                    case 3:
                                    case "end":
                                        return y.stop()
                                }
                            }, o, this)
                        }));

                        function i() {
                            return n.apply(this, arguments)
                        }
                        return i
                    }()
                }, {
                    key: "notify",
                    value: function(i, o) {
                        var a = this;
                        return new Promise(function(y, g) {
                            if (!a.ready) return g(new Error("socket not ready"));
                            var E = {
                                jsonrpc: "2.0",
                                method: i,
                                params: o || null
                            };
                            a.socket.send(JSON.stringify(E), function(A) {
                                if (A) return g(A);
                                y()
                            })
                        })
                    }
                }, {
                    key: "subscribe",
                    value: function() {
                        var n = (0, pc.default)(fo.default.mark(function o(a) {
                            var y;
                            return fo.default.wrap(function(E) {
                                for (;;) switch (E.prev = E.next) {
                                    case 0:
                                        return typeof a == "string" && (a = [a]), E.next = 3, this.call("rpc.on", a);
                                    case 3:
                                        if (y = E.sent, !(typeof a == "string" && y[a] !== "ok")) {
                                            E.next = 6;
                                            break
                                        }
                                        throw new Error("Failed subscribing to an event '" + a + "' with: " + y[a]);
                                    case 6:
                                        return E.abrupt("return", y);
                                    case 7:
                                    case "end":
                                        return E.stop()
                                }
                            }, o, this)
                        }));

                        function i(o) {
                            return n.apply(this, arguments)
                        }
                        return i
                    }()
                }, {
                    key: "unsubscribe",
                    value: function() {
                        var n = (0, pc.default)(fo.default.mark(function o(a) {
                            var y;
                            return fo.default.wrap(function(E) {
                                for (;;) switch (E.prev = E.next) {
                                    case 0:
                                        return typeof a == "string" && (a = [a]), E.next = 3, this.call("rpc.off", a);
                                    case 3:
                                        if (y = E.sent, !(typeof a == "string" && y[a] !== "ok")) {
                                            E.next = 6;
                                            break
                                        }
                                        throw new Error("Failed unsubscribing from an event with: " + y);
                                    case 6:
                                        return E.abrupt("return", y);
                                    case 7:
                                    case "end":
                                        return E.stop()
                                }
                            }, o, this)
                        }));

                        function i(o) {
                            return n.apply(this, arguments)
                        }
                        return i
                    }()
                }, {
                    key: "close",
                    value: function(i, o) {
                        this.socket.close(i || 1e3, o)
                    }
                }, {
                    key: "_connect",
                    value: function(i, o) {
                        var a = this;
                        this.socket = this.webSocketFactory(i, o), this.socket.addEventListener("open", function() {
                            a.ready = !0, a.emit("open"), a.current_reconnects = 0
                        }), this.socket.addEventListener("message", function(y) {
                            var g = y.data;
                            g instanceof ArrayBuffer && (g = Buffer.from(g).toString());
                            try {
                                g = JSON.parse(g)
                            } catch {
                                return
                            }
                            if (g.notification && a.listeners(g.notification).length) {
                                if (!Object.keys(g.params).length) return a.emit(g.notification);
                                var E = [g.notification];
                                if (g.params.constructor === Object) E.push(g.params);
                                else
                                    for (var A = 0; A < g.params.length; A++) E.push(g.params[A]);
                                return Promise.resolve().then(function() {
                                    a.emit.apply(a, E)
                                })
                            }
                            if (!a.queue[g.id]) return g.method && g.params ? Promise.resolve().then(function() {
                                a.emit(g.method, g.params)
                            }) : void 0;
                            "error" in g == "result" in g && a.queue[g.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), a.queue[g.id].timeout && clearTimeout(a.queue[g.id].timeout), g.error ? a.queue[g.id].promise[1](g.error) : a.queue[g.id].promise[0](g.result), delete a.queue[g.id]
                        }), this.socket.addEventListener("error", function(y) {
                            return a.emit("error", y)
                        }), this.socket.addEventListener("close", function(y) {
                            var g = y.code,
                                E = y.reason;
                            a.ready && setTimeout(function() {
                                return a.emit("close", g, E)
                            }, 0), a.ready = !1, a.socket = void 0, g !== 1e3 && (a.current_reconnects++, a.reconnect && (a.max_reconnects > a.current_reconnects || a.max_reconnects === 0) && setTimeout(function() {
                                return a._connect(i, o)
                            }, a.reconnect_interval))
                        })
                    }
                }]), t
            }(v7.EventEmitter);
        yc.default = S7
    });
    var Kb = Ue(mc => {
        "use strict";
        var Co = sc();
        Object.defineProperty(mc, "__esModule", {
            value: !0
        });
        mc.Client = void 0;
        var M7 = Co(ac()),
            A7 = Co(fc()),
            I7 = Co(uc()),
            B7 = Co(hc()),
            Db = Co(lc()),
            R7 = Co(Tb()),
            k7 = Co(Ob());

        function P7(r) {
            var e = T7();
            return function() {
                var n = (0, Db.default)(r),
                    i;
                if (e) {
                    var o = (0, Db.default)(this).constructor;
                    i = Reflect.construct(n, arguments, o)
                } else i = n.apply(this, arguments);
                return (0, B7.default)(this, i)
            }
        }

        function T7() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
            if (typeof Proxy == "function") return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
            } catch {
                return !1
            }
        }
        var L7 = function(r) {
            (0, I7.default)(t, r);
            var e = P7(t);

            function t() {
                var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ws://localhost:8080",
                    i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                    o = i.autoconnect,
                    a = o === void 0 ? !0 : o,
                    y = i.reconnect,
                    g = y === void 0 ? !0 : y,
                    E = i.reconnect_interval,
                    A = E === void 0 ? 1e3 : E,
                    I = i.max_reconnects,
                    q = I === void 0 ? 5 : I,
                    L = arguments.length > 2 ? arguments[2] : void 0;
                return (0, A7.default)(this, t), e.call(this, R7.default, n, {
                    autoconnect: a,
                    reconnect: g,
                    reconnect_interval: A,
                    max_reconnects: q
                }, L)
            }
            return (0, M7.default)(t)
        }(k7.default);
        mc.Client = L7
    });

    function Pa() {
        if (!gc && (gc = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !gc)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return gc(z7)
    }
    var gc, z7, z0 = on(() => {
        z7 = new Uint8Array(16)
    });
    var $b, jb = on(() => {
        $b = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
    });

    function U7(r) {
        return typeof r == "string" && $b.test(r)
    }
    var co, Ta = on(() => {
        jb();
        co = U7
    });

    function N7(r) {
        var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
            t = (Or[r[e + 0]] + Or[r[e + 1]] + Or[r[e + 2]] + Or[r[e + 3]] + "-" + Or[r[e + 4]] + Or[r[e + 5]] + "-" + Or[r[e + 6]] + Or[r[e + 7]] + "-" + Or[r[e + 8]] + Or[r[e + 9]] + "-" + Or[r[e + 10]] + Or[r[e + 11]] + Or[r[e + 12]] + Or[r[e + 13]] + Or[r[e + 14]] + Or[r[e + 15]]).toLowerCase();
        if (!co(t)) throw TypeError("Stringified UUID is invalid");
        return t
    }
    var Or, bc, ho, La = on(() => {
        Ta();
        Or = [];
        for (bc = 0; bc < 256; ++bc) Or.push((bc + 256).toString(16).substr(1));
        ho = N7
    });

    function q7(r, e, t) {
        var n = e && t || 0,
            i = e || new Array(16);
        r = r || {};
        var o = r.node || Wb,
            a = r.clockseq !== void 0 ? r.clockseq : U0;
        if (o == null || a == null) {
            var y = r.random || (r.rng || Pa)();
            o == null && (o = Wb = [y[0] | 1, y[1], y[2], y[3], y[4], y[5]]), a == null && (a = U0 = (y[6] << 8 | y[7]) & 16383)
        }
        var g = r.msecs !== void 0 ? r.msecs : Date.now(),
            E = r.nsecs !== void 0 ? r.nsecs : q0 + 1,
            A = g - N0 + (E - q0) / 1e4;
        if (A < 0 && r.clockseq === void 0 && (a = a + 1 & 16383), (A < 0 || g > N0) && r.nsecs === void 0 && (E = 0), E >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        N0 = g, q0 = E, U0 = a, g += 122192928e5;
        var I = ((g & 268435455) * 1e4 + E) % 4294967296;
        i[n++] = I >>> 24 & 255, i[n++] = I >>> 16 & 255, i[n++] = I >>> 8 & 255, i[n++] = I & 255;
        var q = g / 4294967296 * 1e4 & 268435455;
        i[n++] = q >>> 8 & 255, i[n++] = q & 255, i[n++] = q >>> 24 & 15 | 16, i[n++] = q >>> 16 & 255, i[n++] = a >>> 8 | 128, i[n++] = a & 255;
        for (var L = 0; L < 6; ++L) i[n + L] = o[L];
        return e || ho(i)
    }
    var Wb, U0, N0, q0, Hb, Vb = on(() => {
        z0();
        La();
        N0 = 0, q0 = 0;
        Hb = q7
    });

    function F7(r) {
        if (!co(r)) throw TypeError("Invalid UUID");
        var e, t = new Uint8Array(16);
        return t[0] = (e = parseInt(r.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(r.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(r.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(r.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t
    }
    var xc, F0 = on(() => {
        Ta();
        xc = F7
    });

    function C7(r) {
        r = unescape(encodeURIComponent(r));
        for (var e = [], t = 0; t < r.length; ++t) e.push(r.charCodeAt(t));
        return e
    }

    function vc(r, e, t) {
        function n(i, o, a, y) {
            if (typeof i == "string" && (i = C7(i)), typeof o == "string" && (o = xc(o)), o.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
            var g = new Uint8Array(16 + i.length);
            if (g.set(o), g.set(i, o.length), g = t(g), g[6] = g[6] & 15 | e, g[8] = g[8] & 63 | 128, a) {
                y = y || 0;
                for (var E = 0; E < 16; ++E) a[y + E] = g[E];
                return a
            }
            return ho(g)
        }
        try {
            n.name = r
        } catch {}
        return n.DNS = O7, n.URL = D7, n
    }
    var O7, D7, C0 = on(() => {
        La();
        F0();
        O7 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", D7 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"
    });

    function K7(r) {
        if (typeof r == "string") {
            var e = unescape(encodeURIComponent(r));
            r = new Uint8Array(e.length);
            for (var t = 0; t < e.length; ++t) r[t] = e.charCodeAt(t)
        }
        return $7(j7(W7(r), r.length * 8))
    }

    function $7(r) {
        for (var e = [], t = r.length * 32, n = "0123456789abcdef", i = 0; i < t; i += 8) {
            var o = r[i >> 5] >>> i % 32 & 255,
                a = parseInt(n.charAt(o >>> 4 & 15) + n.charAt(o & 15), 16);
            e.push(a)
        }
        return e
    }

    function Gb(r) {
        return (r + 64 >>> 9 << 4) + 14 + 1
    }

    function j7(r, e) {
        r[e >> 5] |= 128 << e % 32, r[Gb(e) - 1] = e;
        for (var t = 1732584193, n = -271733879, i = -1732584194, o = 271733878, a = 0; a < r.length; a += 16) {
            var y = t,
                g = n,
                E = i,
                A = o;
            t = Jr(t, n, i, o, r[a], 7, -680876936), o = Jr(o, t, n, i, r[a + 1], 12, -389564586), i = Jr(i, o, t, n, r[a + 2], 17, 606105819), n = Jr(n, i, o, t, r[a + 3], 22, -1044525330), t = Jr(t, n, i, o, r[a + 4], 7, -176418897), o = Jr(o, t, n, i, r[a + 5], 12, 1200080426), i = Jr(i, o, t, n, r[a + 6], 17, -1473231341), n = Jr(n, i, o, t, r[a + 7], 22, -45705983), t = Jr(t, n, i, o, r[a + 8], 7, 1770035416), o = Jr(o, t, n, i, r[a + 9], 12, -1958414417), i = Jr(i, o, t, n, r[a + 10], 17, -42063), n = Jr(n, i, o, t, r[a + 11], 22, -1990404162), t = Jr(t, n, i, o, r[a + 12], 7, 1804603682), o = Jr(o, t, n, i, r[a + 13], 12, -40341101), i = Jr(i, o, t, n, r[a + 14], 17, -1502002290), n = Jr(n, i, o, t, r[a + 15], 22, 1236535329), t = Xr(t, n, i, o, r[a + 1], 5, -165796510), o = Xr(o, t, n, i, r[a + 6], 9, -1069501632), i = Xr(i, o, t, n, r[a + 11], 14, 643717713), n = Xr(n, i, o, t, r[a], 20, -373897302), t = Xr(t, n, i, o, r[a + 5], 5, -701558691), o = Xr(o, t, n, i, r[a + 10], 9, 38016083), i = Xr(i, o, t, n, r[a + 15], 14, -660478335), n = Xr(n, i, o, t, r[a + 4], 20, -405537848), t = Xr(t, n, i, o, r[a + 9], 5, 568446438), o = Xr(o, t, n, i, r[a + 14], 9, -1019803690), i = Xr(i, o, t, n, r[a + 3], 14, -187363961), n = Xr(n, i, o, t, r[a + 8], 20, 1163531501), t = Xr(t, n, i, o, r[a + 13], 5, -1444681467), o = Xr(o, t, n, i, r[a + 2], 9, -51403784), i = Xr(i, o, t, n, r[a + 7], 14, 1735328473), n = Xr(n, i, o, t, r[a + 12], 20, -1926607734), t = Qr(t, n, i, o, r[a + 5], 4, -378558), o = Qr(o, t, n, i, r[a + 8], 11, -2022574463), i = Qr(i, o, t, n, r[a + 11], 16, 1839030562), n = Qr(n, i, o, t, r[a + 14], 23, -35309556), t = Qr(t, n, i, o, r[a + 1], 4, -1530992060), o = Qr(o, t, n, i, r[a + 4], 11, 1272893353), i = Qr(i, o, t, n, r[a + 7], 16, -155497632), n = Qr(n, i, o, t, r[a + 10], 23, -1094730640), t = Qr(t, n, i, o, r[a + 13], 4, 681279174), o = Qr(o, t, n, i, r[a], 11, -358537222), i = Qr(i, o, t, n, r[a + 3], 16, -722521979), n = Qr(n, i, o, t, r[a + 6], 23, 76029189), t = Qr(t, n, i, o, r[a + 9], 4, -640364487), o = Qr(o, t, n, i, r[a + 12], 11, -421815835), i = Qr(i, o, t, n, r[a + 15], 16, 530742520), n = Qr(n, i, o, t, r[a + 2], 23, -995338651), t = en(t, n, i, o, r[a], 6, -198630844), o = en(o, t, n, i, r[a + 7], 10, 1126891415), i = en(i, o, t, n, r[a + 14], 15, -1416354905), n = en(n, i, o, t, r[a + 5], 21, -57434055), t = en(t, n, i, o, r[a + 12], 6, 1700485571), o = en(o, t, n, i, r[a + 3], 10, -1894986606), i = en(i, o, t, n, r[a + 10], 15, -1051523), n = en(n, i, o, t, r[a + 1], 21, -2054922799), t = en(t, n, i, o, r[a + 8], 6, 1873313359), o = en(o, t, n, i, r[a + 15], 10, -30611744), i = en(i, o, t, n, r[a + 6], 15, -1560198380), n = en(n, i, o, t, r[a + 13], 21, 1309151649), t = en(t, n, i, o, r[a + 4], 6, -145523070), o = en(o, t, n, i, r[a + 11], 10, -1120210379), i = en(i, o, t, n, r[a + 2], 15, 718787259), n = en(n, i, o, t, r[a + 9], 21, -343485551), t = lo(t, y), n = lo(n, g), i = lo(i, E), o = lo(o, A)
        }
        return [t, n, i, o]
    }

    function W7(r) {
        if (r.length === 0) return [];
        for (var e = r.length * 8, t = new Uint32Array(Gb(e)), n = 0; n < e; n += 8) t[n >> 5] |= (r[n / 8] & 255) << n % 32;
        return t
    }

    function lo(r, e) {
        var t = (r & 65535) + (e & 65535),
            n = (r >> 16) + (e >> 16) + (t >> 16);
        return n << 16 | t & 65535
    }

    function H7(r, e) {
        return r << e | r >>> 32 - e
    }

    function wc(r, e, t, n, i, o) {
        return lo(H7(lo(lo(e, r), lo(n, o)), i), t)
    }

    function Jr(r, e, t, n, i, o, a) {
        return wc(e & t | ~e & n, r, e, i, o, a)
    }

    function Xr(r, e, t, n, i, o, a) {
        return wc(e & n | t & ~n, r, e, i, o, a)
    }

    function Qr(r, e, t, n, i, o, a) {
        return wc(e ^ t ^ n, r, e, i, o, a)
    }

    function en(r, e, t, n, i, o, a) {
        return wc(t ^ (e | ~n), r, e, i, o, a)
    }
    var Zb, Yb = on(() => {
        Zb = K7
    });
    var V7, Jb, Xb = on(() => {
        C0();
        Yb();
        V7 = vc("v3", 48, Zb), Jb = V7
    });

    function G7(r, e, t) {
        r = r || {};
        var n = r.random || (r.rng || Pa)();
        if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, e) {
            t = t || 0;
            for (var i = 0; i < 16; ++i) e[t + i] = n[i];
            return e
        }
        return ho(n)
    }
    var Qb, ex = on(() => {
        z0();
        La();
        Qb = G7
    });

    function Z7(r, e, t, n) {
        switch (r) {
            case 0:
                return e & t ^ ~e & n;
            case 1:
                return e ^ t ^ n;
            case 2:
                return e & t ^ e & n ^ t & n;
            case 3:
                return e ^ t ^ n
        }
    }

    function O0(r, e) {
        return r << e | r >>> 32 - e
    }

    function Y7(r) {
        var e = [1518500249, 1859775393, 2400959708, 3395469782],
            t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        if (typeof r == "string") {
            var n = unescape(encodeURIComponent(r));
            r = [];
            for (var i = 0; i < n.length; ++i) r.push(n.charCodeAt(i))
        } else Array.isArray(r) || (r = Array.prototype.slice.call(r));
        r.push(128);
        for (var o = r.length / 4 + 2, a = Math.ceil(o / 16), y = new Array(a), g = 0; g < a; ++g) {
            for (var E = new Uint32Array(16), A = 0; A < 16; ++A) E[A] = r[g * 64 + A * 4] << 24 | r[g * 64 + A * 4 + 1] << 16 | r[g * 64 + A * 4 + 2] << 8 | r[g * 64 + A * 4 + 3];
            y[g] = E
        }
        y[a - 1][14] = (r.length - 1) * 8 / Math.pow(2, 32), y[a - 1][14] = Math.floor(y[a - 1][14]), y[a - 1][15] = (r.length - 1) * 8 & 4294967295;
        for (var I = 0; I < a; ++I) {
            for (var q = new Uint32Array(80), L = 0; L < 16; ++L) q[L] = y[I][L];
            for (var O = 16; O < 80; ++O) q[O] = O0(q[O - 3] ^ q[O - 8] ^ q[O - 14] ^ q[O - 16], 1);
            for (var Z = t[0], ge = t[1], ce = t[2], Xe = t[3], xe = t[4], ie = 0; ie < 80; ++ie) {
                var ae = Math.floor(ie / 20),
                    be = O0(Z, 5) + Z7(ae, ge, ce, Xe) + xe + e[ae] + q[ie] >>> 0;
                xe = Xe, Xe = ce, ce = O0(ge, 30) >>> 0, ge = Z, Z = be
            }
            t[0] = t[0] + Z >>> 0, t[1] = t[1] + ge >>> 0, t[2] = t[2] + ce >>> 0, t[3] = t[3] + Xe >>> 0, t[4] = t[4] + xe >>> 0
        }
        return [t[0] >> 24 & 255, t[0] >> 16 & 255, t[0] >> 8 & 255, t[0] & 255, t[1] >> 24 & 255, t[1] >> 16 & 255, t[1] >> 8 & 255, t[1] & 255, t[2] >> 24 & 255, t[2] >> 16 & 255, t[2] >> 8 & 255, t[2] & 255, t[3] >> 24 & 255, t[3] >> 16 & 255, t[3] >> 8 & 255, t[3] & 255, t[4] >> 24 & 255, t[4] >> 16 & 255, t[4] >> 8 & 255, t[4] & 255]
    }
    var tx, rx = on(() => {
        tx = Y7
    });
    var J7, nx, ix = on(() => {
        C0();
        rx();
        J7 = vc("v5", 80, tx), nx = J7
    });
    var ox, sx = on(() => {
        ox = "00000000-0000-0000-0000-000000000000"
    });

    function X7(r) {
        if (!co(r)) throw TypeError("Invalid UUID");
        return parseInt(r.substr(14, 1), 16)
    }
    var ax, fx = on(() => {
        Ta();
        ax = X7
    });
    var D0 = {};
    ct(D0, {
        NIL: () => ox,
        parse: () => xc,
        stringify: () => ho,
        v1: () => Hb,
        v3: () => Jb,
        v4: () => Qb,
        v5: () => nx,
        validate: () => co,
        version: () => ax
    });
    var K0 = on(() => {
        Vb();
        Xb();
        ex();
        ix();
        sx();
        fx();
        Ta();
        La();
        F0()
    });
    var cx = Ue((NL, ux) => {
        "use strict";
        var Q7 = (K0(), od(D0)).v4,
            e_ = function(r, e, t, n) {
                if (typeof r != "string") throw new TypeError(r + " must be a string");
                n = n || {};
                let i = typeof n.version == "number" ? n.version : 2;
                if (i !== 1 && i !== 2) throw new TypeError(i + " must be 1 or 2");
                let o = {
                    method: r
                };
                if (i === 2 && (o.jsonrpc = "2.0"), e) {
                    if (typeof e != "object" && !Array.isArray(e)) throw new TypeError(e + " must be an object, array or omitted");
                    o.params = e
                }
                if (typeof t > "u") {
                    let a = typeof n.generator == "function" ? n.generator : function() {
                        return Q7()
                    };
                    o.id = a(o, n)
                } else i === 2 && t === null ? n.notificationIdNull && (o.id = null) : o.id = t;
                return o
            };
        ux.exports = e_
    });
    var lx = Ue((qL, hx) => {
        "use strict";
        var t_ = (K0(), od(D0)).v4,
            r_ = cx(),
            za = function(r, e) {
                if (!(this instanceof za)) return new za(r, e);
                e || (e = {}), this.options = {
                    reviver: typeof e.reviver < "u" ? e.reviver : null,
                    replacer: typeof e.replacer < "u" ? e.replacer : null,
                    generator: typeof e.generator < "u" ? e.generator : function() {
                        return t_()
                    },
                    version: typeof e.version < "u" ? e.version : 2,
                    notificationIdNull: typeof e.notificationIdNull == "boolean" ? e.notificationIdNull : !1
                }, this.callServer = r
            };
        hx.exports = za;
        za.prototype.request = function(r, e, t, n) {
            let i = this,
                o = null,
                a = Array.isArray(r) && typeof e == "function";
            if (this.options.version === 1 && a) throw new TypeError("JSON-RPC 1.0 does not support batching");
            if (a || !a && r && typeof r == "object" && typeof e == "function") n = e, o = r;
            else {
                typeof t == "function" && (n = t, t = void 0);
                let E = typeof n == "function";
                try {
                    o = r_(r, e, t, {
                        generator: this.options.generator,
                        version: this.options.version,
                        notificationIdNull: this.options.notificationIdNull
                    })
                } catch (A) {
                    if (E) return n(A);
                    throw A
                }
                if (!E) return o
            }
            let g;
            try {
                g = JSON.stringify(o, this.options.replacer)
            } catch (E) {
                return n(E)
            }
            return this.callServer(g, function(E, A) {
                i._parseResponse(E, A, n)
            }), o
        };
        za.prototype._parseResponse = function(r, e, t) {
            if (r) {
                t(r);
                return
            }
            if (!e) return t();
            let n;
            try {
                n = JSON.parse(e, this.options.reviver)
            } catch (i) {
                return t(i)
            }
            if (t.length === 3)
                if (Array.isArray(n)) {
                    let i = function(a) {
                            return typeof a.error < "u"
                        },
                        o = function(a) {
                            return !i(a)
                        };
                    return t(null, n.filter(i), n.filter(o))
                } else return t(null, n.error, n.result);
            t(null, n)
        }
    });
    var px = Ue((FL, dx) => {
        var Gt = {
            IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
            TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
            TWEAK_MUL: "The tweak was out of range or equal to zero",
            CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
            SECKEY_INVALID: "Private Key is invalid",
            PUBKEY_PARSE: "Public Key could not be parsed",
            PUBKEY_SERIALIZE: "Public Key serialization error",
            PUBKEY_COMBINE: "The sum of the public keys is not valid",
            SIG_PARSE: "Signature could not be parsed",
            SIGN: "The nonce generation function failed, or the private key was invalid",
            RECOVER: "Public key could not be recover",
            ECDH: "Scalar was invalid (zero or overflow)"
        };

        function Ln(r, e) {
            if (!r) throw new Error(e)
        }

        function Dt(r, e, t) {
            if (Ln(e instanceof Uint8Array, `Expected ${r} to be an Uint8Array`), t !== void 0)
                if (Array.isArray(t)) {
                    let n = t.join(", "),
                        i = `Expected ${r} to be an Uint8Array with length [${n}]`;
                    Ln(t.includes(e.length), i)
                } else {
                    let n = `Expected ${r} to be an Uint8Array with length ${t}`;
                    Ln(e.length === t, n)
                }
        }

        function Oo(r) {
            Ln(Ls(r) === "Boolean", "Expected compressed to be a Boolean")
        }

        function jn(r = t => new Uint8Array(t), e) {
            return typeof r == "function" && (r = r(e)), Dt("output", r, e), r
        }

        function Ls(r) {
            return Object.prototype.toString.call(r).slice(8, -1)
        }
        dx.exports = r => ({
            contextRandomize(e) {
                switch (Ln(e === null || e instanceof Uint8Array, "Expected seed to be an Uint8Array or null"), e !== null && Dt("seed", e, 32), r.contextRandomize(e)) {
                    case 1:
                        throw new Error(Gt.CONTEXT_RANDOMIZE_UNKNOW)
                }
            },
            privateKeyVerify(e) {
                return Dt("private key", e, 32), r.privateKeyVerify(e) === 0
            },
            privateKeyNegate(e) {
                switch (Dt("private key", e, 32), r.privateKeyNegate(e)) {
                    case 0:
                        return e;
                    case 1:
                        throw new Error(Gt.IMPOSSIBLE_CASE)
                }
            },
            privateKeyTweakAdd(e, t) {
                switch (Dt("private key", e, 32), Dt("tweak", t, 32), r.privateKeyTweakAdd(e, t)) {
                    case 0:
                        return e;
                    case 1:
                        throw new Error(Gt.TWEAK_ADD)
                }
            },
            privateKeyTweakMul(e, t) {
                switch (Dt("private key", e, 32), Dt("tweak", t, 32), r.privateKeyTweakMul(e, t)) {
                    case 0:
                        return e;
                    case 1:
                        throw new Error(Gt.TWEAK_MUL)
                }
            },
            publicKeyVerify(e) {
                return Dt("public key", e, [33, 65]), r.publicKeyVerify(e) === 0
            },
            publicKeyCreate(e, t = !0, n) {
                switch (Dt("private key", e, 32), Oo(t), n = jn(n, t ? 33 : 65), r.publicKeyCreate(n, e)) {
                    case 0:
                        return n;
                    case 1:
                        throw new Error(Gt.SECKEY_INVALID);
                    case 2:
                        throw new Error(Gt.PUBKEY_SERIALIZE)
                }
            },
            publicKeyConvert(e, t = !0, n) {
                switch (Dt("public key", e, [33, 65]), Oo(t), n = jn(n, t ? 33 : 65), r.publicKeyConvert(n, e)) {
                    case 0:
                        return n;
                    case 1:
                        throw new Error(Gt.PUBKEY_PARSE);
                    case 2:
                        throw new Error(Gt.PUBKEY_SERIALIZE)
                }
            },
            publicKeyNegate(e, t = !0, n) {
                switch (Dt("public key", e, [33, 65]), Oo(t), n = jn(n, t ? 33 : 65), r.publicKeyNegate(n, e)) {
                    case 0:
                        return n;
                    case 1:
                        throw new Error(Gt.PUBKEY_PARSE);
                    case 2:
                        throw new Error(Gt.IMPOSSIBLE_CASE);
                    case 3:
                        throw new Error(Gt.PUBKEY_SERIALIZE)
                }
            },
            publicKeyCombine(e, t = !0, n) {
                Ln(Array.isArray(e), "Expected public keys to be an Array"), Ln(e.length > 0, "Expected public keys array will have more than zero items");
                for (let i of e) Dt("public key", i, [33, 65]);
                switch (Oo(t), n = jn(n, t ? 33 : 65), r.publicKeyCombine(n, e)) {
                    case 0:
                        return n;
                    case 1:
                        throw new Error(Gt.PUBKEY_PARSE);
                    case 2:
                        throw new Error(Gt.PUBKEY_COMBINE);
                    case 3:
                        throw new Error(Gt.PUBKEY_SERIALIZE)
                }
            },
            publicKeyTweakAdd(e, t, n = !0, i) {
                switch (Dt("public key", e, [33, 65]), Dt("tweak", t, 32), Oo(n), i = jn(i, n ? 33 : 65), r.publicKeyTweakAdd(i, e, t)) {
                    case 0:
                        return i;
                    case 1:
                        throw new Error(Gt.PUBKEY_PARSE);
                    case 2:
                        throw new Error(Gt.TWEAK_ADD)
                }
            },
            publicKeyTweakMul(e, t, n = !0, i) {
                switch (Dt("public key", e, [33, 65]), Dt("tweak", t, 32), Oo(n), i = jn(i, n ? 33 : 65), r.publicKeyTweakMul(i, e, t)) {
                    case 0:
                        return i;
                    case 1:
                        throw new Error(Gt.PUBKEY_PARSE);
                    case 2:
                        throw new Error(Gt.TWEAK_MUL)
                }
            },
            signatureNormalize(e) {
                switch (Dt("signature", e, 64), r.signatureNormalize(e)) {
                    case 0:
                        return e;
                    case 1:
                        throw new Error(Gt.SIG_PARSE)
                }
            },
            signatureExport(e, t) {
                Dt("signature", e, 64), t = jn(t, 72);
                let n = {
                    output: t,
                    outputlen: 72
                };
                switch (r.signatureExport(n, e)) {
                    case 0:
                        return t.slice(0, n.outputlen);
                    case 1:
                        throw new Error(Gt.SIG_PARSE);
                    case 2:
                        throw new Error(Gt.IMPOSSIBLE_CASE)
                }
            },
            signatureImport(e, t) {
                switch (Dt("signature", e), t = jn(t, 64), r.signatureImport(t, e)) {
                    case 0:
                        return t;
                    case 1:
                        throw new Error(Gt.SIG_PARSE);
                    case 2:
                        throw new Error(Gt.IMPOSSIBLE_CASE)
                }
            },
            ecdsaSign(e, t, n = {}, i) {
                Dt("message", e, 32), Dt("private key", t, 32), Ln(Ls(n) === "Object", "Expected options to be an Object"), n.data !== void 0 && Dt("options.data", n.data), n.noncefn !== void 0 && Ln(Ls(n.noncefn) === "Function", "Expected options.noncefn to be a Function"), i = jn(i, 64);
                let o = {
                    signature: i,
                    recid: null
                };
                switch (r.ecdsaSign(o, e, t, n.data, n.noncefn)) {
                    case 0:
                        return o;
                    case 1:
                        throw new Error(Gt.SIGN);
                    case 2:
                        throw new Error(Gt.IMPOSSIBLE_CASE)
                }
            },
            ecdsaVerify(e, t, n) {
                switch (Dt("signature", e, 64), Dt("message", t, 32), Dt("public key", n, [33, 65]), r.ecdsaVerify(e, t, n)) {
                    case 0:
                        return !0;
                    case 3:
                        return !1;
                    case 1:
                        throw new Error(Gt.SIG_PARSE);
                    case 2:
                        throw new Error(Gt.PUBKEY_PARSE)
                }
            },
            ecdsaRecover(e, t, n, i = !0, o) {
                switch (Dt("signature", e, 64), Ln(Ls(t) === "Number" && t >= 0 && t <= 3, "Expected recovery id to be a Number within interval [0, 3]"), Dt("message", n, 32), Oo(i), o = jn(o, i ? 33 : 65), r.ecdsaRecover(o, e, t, n)) {
                    case 0:
                        return o;
                    case 1:
                        throw new Error(Gt.SIG_PARSE);
                    case 2:
                        throw new Error(Gt.RECOVER);
                    case 3:
                        throw new Error(Gt.IMPOSSIBLE_CASE)
                }
            },
            ecdh(e, t, n = {}, i) {
                switch (Dt("public key", e, [33, 65]), Dt("private key", t, 32), Ln(Ls(n) === "Object", "Expected options to be an Object"), n.data !== void 0 && Dt("options.data", n.data), n.hashfn !== void 0 ? (Ln(Ls(n.hashfn) === "Function", "Expected options.hashfn to be a Function"), n.xbuf !== void 0 && Dt("options.xbuf", n.xbuf, 32), n.ybuf !== void 0 && Dt("options.ybuf", n.ybuf, 32), Dt("output", i)) : i = jn(i, 32), r.ecdh(i, e, t, n.data, n.hashfn, n.xbuf, n.ybuf)) {
                    case 0:
                        return i;
                    case 1:
                        throw new Error(Gt.PUBKEY_PARSE);
                    case 2:
                        throw new Error(Gt.ECDH)
                }
            }
        })
    });
    var yx = Ue((CL, n_) => {
        n_.exports = {
            name: "elliptic",
            version: "6.5.4",
            description: "EC cryptography",
            main: "lib/elliptic.js",
            files: ["lib"],
            scripts: {
                lint: "eslint lib test",
                "lint:fix": "npm run lint -- --fix",
                unit: "istanbul test _mocha --reporter=spec test/index.js",
                test: "npm run lint && npm run unit",
                version: "grunt dist && git add dist/"
            },
            repository: {
                type: "git",
                url: "git@github.com:indutny/elliptic"
            },
            keywords: ["EC", "Elliptic", "curve", "Cryptography"],
            author: "Fedor Indutny <fedor@indutny.com>",
            license: "MIT",
            bugs: {
                url: "https://github.com/indutny/elliptic/issues"
            },
            homepage: "https://github.com/indutny/elliptic",
            devDependencies: {
                brfs: "^2.0.2",
                coveralls: "^3.1.0",
                eslint: "^7.6.0",
                grunt: "^1.2.1",
                "grunt-browserify": "^5.3.0",
                "grunt-cli": "^1.3.2",
                "grunt-contrib-connect": "^3.0.0",
                "grunt-contrib-copy": "^1.0.0",
                "grunt-contrib-uglify": "^5.0.0",
                "grunt-mocha-istanbul": "^5.0.2",
                "grunt-saucelabs": "^9.0.1",
                istanbul: "^0.4.5",
                mocha: "^8.0.1"
            },
            dependencies: {
                "bn.js": "^4.11.9",
                brorand: "^1.1.0",
                "hash.js": "^1.0.0",
                "hmac-drbg": "^1.0.1",
                inherits: "^2.0.4",
                "minimalistic-assert": "^1.0.1",
                "minimalistic-crypto-utils": "^1.0.1"
            }
        }
    });
    var ci = Ue((mx, $0) => {
        (function(r, e) {
            "use strict";

            function t(T, m) {
                if (!T) throw new Error(m || "Assertion failed")
            }

            function n(T, m) {
                T.super_ = m;
                var w = function() {};
                w.prototype = m.prototype, T.prototype = new w, T.prototype.constructor = T
            }

            function i(T, m, w) {
                if (i.isBN(T)) return T;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, T !== null && ((m === "le" || m === "be") && (w = m, m = 10), this._init(T || 0, m || 10, w || "be"))
            }
            typeof r == "object" ? r.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
            var o;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = ff().Buffer
            } catch {}
            i.isBN = function(m) {
                return m instanceof i ? !0 : m !== null && typeof m == "object" && m.constructor.wordSize === i.wordSize && Array.isArray(m.words)
            }, i.max = function(m, w) {
                return m.cmp(w) > 0 ? m : w
            }, i.min = function(m, w) {
                return m.cmp(w) < 0 ? m : w
            }, i.prototype._init = function(m, w, l) {
                if (typeof m == "number") return this._initNumber(m, w, l);
                if (typeof m == "object") return this._initArray(m, w, l);
                w === "hex" && (w = 16), t(w === (w | 0) && w >= 2 && w <= 36), m = m.toString().replace(/\s+/g, "");
                var s = 0;
                m[0] === "-" && (s++, this.negative = 1), s < m.length && (w === 16 ? this._parseHex(m, s, l) : (this._parseBase(m, w, s), l === "le" && this._initArray(this.toArray(), w, l)))
            }, i.prototype._initNumber = function(m, w, l) {
                m < 0 && (this.negative = 1, m = -m), m < 67108864 ? (this.words = [m & 67108863], this.length = 1) : m < 4503599627370496 ? (this.words = [m & 67108863, m / 67108864 & 67108863], this.length = 2) : (t(m < 9007199254740992), this.words = [m & 67108863, m / 67108864 & 67108863, 1], this.length = 3), l === "le" && this._initArray(this.toArray(), w, l)
            }, i.prototype._initArray = function(m, w, l) {
                if (t(typeof m.length == "number"), m.length <= 0) return this.words = [0], this.length = 1, this;
                this.length = Math.ceil(m.length / 3), this.words = new Array(this.length);
                for (var s = 0; s < this.length; s++) this.words[s] = 0;
                var f, h, p = 0;
                if (l === "be")
                    for (s = m.length - 1, f = 0; s >= 0; s -= 3) h = m[s] | m[s - 1] << 8 | m[s - 2] << 16, this.words[f] |= h << p & 67108863, this.words[f + 1] = h >>> 26 - p & 67108863, p += 24, p >= 26 && (p -= 26, f++);
                else if (l === "le")
                    for (s = 0, f = 0; s < m.length; s += 3) h = m[s] | m[s + 1] << 8 | m[s + 2] << 16, this.words[f] |= h << p & 67108863, this.words[f + 1] = h >>> 26 - p & 67108863, p += 24, p >= 26 && (p -= 26, f++);
                return this.strip()
            };

            function a(T, m) {
                var w = T.charCodeAt(m);
                return w >= 65 && w <= 70 ? w - 55 : w >= 97 && w <= 102 ? w - 87 : w - 48 & 15
            }

            function y(T, m, w) {
                var l = a(T, w);
                return w - 1 >= m && (l |= a(T, w - 1) << 4), l
            }
            i.prototype._parseHex = function(m, w, l) {
                this.length = Math.ceil((m.length - w) / 6), this.words = new Array(this.length);
                for (var s = 0; s < this.length; s++) this.words[s] = 0;
                var f = 0,
                    h = 0,
                    p;
                if (l === "be")
                    for (s = m.length - 1; s >= w; s -= 2) p = y(m, w, s) << f, this.words[h] |= p & 67108863, f >= 18 ? (f -= 18, h += 1, this.words[h] |= p >>> 26) : f += 8;
                else {
                    var d = m.length - w;
                    for (s = d % 2 === 0 ? w + 1 : w; s < m.length; s += 2) p = y(m, w, s) << f, this.words[h] |= p & 67108863, f >= 18 ? (f -= 18, h += 1, this.words[h] |= p >>> 26) : f += 8
                }
                this.strip()
            };

            function g(T, m, w, l) {
                for (var s = 0, f = Math.min(T.length, w), h = m; h < f; h++) {
                    var p = T.charCodeAt(h) - 48;
                    s *= l, p >= 49 ? s += p - 49 + 10 : p >= 17 ? s += p - 17 + 10 : s += p
                }
                return s
            }
            i.prototype._parseBase = function(m, w, l) {
                this.words = [0], this.length = 1;
                for (var s = 0, f = 1; f <= 67108863; f *= w) s++;
                s--, f = f / w | 0;
                for (var h = m.length - l, p = h % s, d = Math.min(h, h - p) + l, c = 0, x = l; x < d; x += s) c = g(m, x, x + s, w), this.imuln(f), this.words[0] + c < 67108864 ? this.words[0] += c : this._iaddn(c);
                if (p !== 0) {
                    var v = 1;
                    for (c = g(m, x, m.length, w), x = 0; x < p; x++) v *= w;
                    this.imuln(v), this.words[0] + c < 67108864 ? this.words[0] += c : this._iaddn(c)
                }
                this.strip()
            }, i.prototype.copy = function(m) {
                m.words = new Array(this.length);
                for (var w = 0; w < this.length; w++) m.words[w] = this.words[w];
                m.length = this.length, m.negative = this.negative, m.red = this.red
            }, i.prototype.clone = function() {
                var m = new i(null);
                return this.copy(m), m
            }, i.prototype._expand = function(m) {
                for (; this.length < m;) this.words[this.length++] = 0;
                return this
            }, i.prototype.strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
                return this._normSign()
            }, i.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }, i.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            };
            var E = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                A = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                I = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            i.prototype.toString = function(m, w) {
                m = m || 10, w = w | 0 || 1;
                var l;
                if (m === 16 || m === "hex") {
                    l = "";
                    for (var s = 0, f = 0, h = 0; h < this.length; h++) {
                        var p = this.words[h],
                            d = ((p << s | f) & 16777215).toString(16);
                        f = p >>> 24 - s & 16777215, f !== 0 || h !== this.length - 1 ? l = E[6 - d.length] + d + l : l = d + l, s += 2, s >= 26 && (s -= 26, h--)
                    }
                    for (f !== 0 && (l = f.toString(16) + l); l.length % w !== 0;) l = "0" + l;
                    return this.negative !== 0 && (l = "-" + l), l
                }
                if (m === (m | 0) && m >= 2 && m <= 36) {
                    var c = A[m],
                        x = I[m];
                    l = "";
                    var v = this.clone();
                    for (v.negative = 0; !v.isZero();) {
                        var u = v.modn(x).toString(m);
                        v = v.idivn(x), v.isZero() ? l = u + l : l = E[c - u.length] + u + l
                    }
                    for (this.isZero() && (l = "0" + l); l.length % w !== 0;) l = "0" + l;
                    return this.negative !== 0 && (l = "-" + l), l
                }
                t(!1, "Base should be between 2 and 36")
            }, i.prototype.toNumber = function() {
                var m = this.words[0];
                return this.length === 2 ? m += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? m += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && t(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -m : m
            }, i.prototype.toJSON = function() {
                return this.toString(16)
            }, i.prototype.toBuffer = function(m, w) {
                return t(typeof o < "u"), this.toArrayLike(o, m, w)
            }, i.prototype.toArray = function(m, w) {
                return this.toArrayLike(Array, m, w)
            }, i.prototype.toArrayLike = function(m, w, l) {
                var s = this.byteLength(),
                    f = l || Math.max(1, s);
                t(s <= f, "byte array longer than desired length"), t(f > 0, "Requested array length <= 0"), this.strip();
                var h = w === "le",
                    p = new m(f),
                    d, c, x = this.clone();
                if (h) {
                    for (c = 0; !x.isZero(); c++) d = x.andln(255), x.iushrn(8), p[c] = d;
                    for (; c < f; c++) p[c] = 0
                } else {
                    for (c = 0; c < f - s; c++) p[c] = 0;
                    for (c = 0; !x.isZero(); c++) d = x.andln(255), x.iushrn(8), p[f - c - 1] = d
                }
                return p
            }, Math.clz32 ? i.prototype._countBits = function(m) {
                return 32 - Math.clz32(m)
            } : i.prototype._countBits = function(m) {
                var w = m,
                    l = 0;
                return w >= 4096 && (l += 13, w >>>= 13), w >= 64 && (l += 7, w >>>= 7), w >= 8 && (l += 4, w >>>= 4), w >= 2 && (l += 2, w >>>= 2), l + w
            }, i.prototype._zeroBits = function(m) {
                if (m === 0) return 26;
                var w = m,
                    l = 0;
                return (w & 8191) === 0 && (l += 13, w >>>= 13), (w & 127) === 0 && (l += 7, w >>>= 7), (w & 15) === 0 && (l += 4, w >>>= 4), (w & 3) === 0 && (l += 2, w >>>= 2), (w & 1) === 0 && l++, l
            }, i.prototype.bitLength = function() {
                var m = this.words[this.length - 1],
                    w = this._countBits(m);
                return (this.length - 1) * 26 + w
            };

            function q(T) {
                for (var m = new Array(T.bitLength()), w = 0; w < m.length; w++) {
                    var l = w / 26 | 0,
                        s = w % 26;
                    m[w] = (T.words[l] & 1 << s) >>> s
                }
                return m
            }
            i.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for (var m = 0, w = 0; w < this.length; w++) {
                    var l = this._zeroBits(this.words[w]);
                    if (m += l, l !== 26) break
                }
                return m
            }, i.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }, i.prototype.toTwos = function(m) {
                return this.negative !== 0 ? this.abs().inotn(m).iaddn(1) : this.clone()
            }, i.prototype.fromTwos = function(m) {
                return this.testn(m - 1) ? this.notn(m).iaddn(1).ineg() : this.clone()
            }, i.prototype.isNeg = function() {
                return this.negative !== 0
            }, i.prototype.neg = function() {
                return this.clone().ineg()
            }, i.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this
            }, i.prototype.iuor = function(m) {
                for (; this.length < m.length;) this.words[this.length++] = 0;
                for (var w = 0; w < m.length; w++) this.words[w] = this.words[w] | m.words[w];
                return this.strip()
            }, i.prototype.ior = function(m) {
                return t((this.negative | m.negative) === 0), this.iuor(m)
            }, i.prototype.or = function(m) {
                return this.length > m.length ? this.clone().ior(m) : m.clone().ior(this)
            }, i.prototype.uor = function(m) {
                return this.length > m.length ? this.clone().iuor(m) : m.clone().iuor(this)
            }, i.prototype.iuand = function(m) {
                var w;
                this.length > m.length ? w = m : w = this;
                for (var l = 0; l < w.length; l++) this.words[l] = this.words[l] & m.words[l];
                return this.length = w.length, this.strip()
            }, i.prototype.iand = function(m) {
                return t((this.negative | m.negative) === 0), this.iuand(m)
            }, i.prototype.and = function(m) {
                return this.length > m.length ? this.clone().iand(m) : m.clone().iand(this)
            }, i.prototype.uand = function(m) {
                return this.length > m.length ? this.clone().iuand(m) : m.clone().iuand(this)
            }, i.prototype.iuxor = function(m) {
                var w, l;
                this.length > m.length ? (w = this, l = m) : (w = m, l = this);
                for (var s = 0; s < l.length; s++) this.words[s] = w.words[s] ^ l.words[s];
                if (this !== w)
                    for (; s < w.length; s++) this.words[s] = w.words[s];
                return this.length = w.length, this.strip()
            }, i.prototype.ixor = function(m) {
                return t((this.negative | m.negative) === 0), this.iuxor(m)
            }, i.prototype.xor = function(m) {
                return this.length > m.length ? this.clone().ixor(m) : m.clone().ixor(this)
            }, i.prototype.uxor = function(m) {
                return this.length > m.length ? this.clone().iuxor(m) : m.clone().iuxor(this)
            }, i.prototype.inotn = function(m) {
                t(typeof m == "number" && m >= 0);
                var w = Math.ceil(m / 26) | 0,
                    l = m % 26;
                this._expand(w), l > 0 && w--;
                for (var s = 0; s < w; s++) this.words[s] = ~this.words[s] & 67108863;
                return l > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - l), this.strip()
            }, i.prototype.notn = function(m) {
                return this.clone().inotn(m)
            }, i.prototype.setn = function(m, w) {
                t(typeof m == "number" && m >= 0);
                var l = m / 26 | 0,
                    s = m % 26;
                return this._expand(l + 1), w ? this.words[l] = this.words[l] | 1 << s : this.words[l] = this.words[l] & ~(1 << s), this.strip()
            }, i.prototype.iadd = function(m) {
                var w;
                if (this.negative !== 0 && m.negative === 0) return this.negative = 0, w = this.isub(m), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && m.negative !== 0) return m.negative = 0, w = this.isub(m), m.negative = 1, w._normSign();
                var l, s;
                this.length > m.length ? (l = this, s = m) : (l = m, s = this);
                for (var f = 0, h = 0; h < s.length; h++) w = (l.words[h] | 0) + (s.words[h] | 0) + f, this.words[h] = w & 67108863, f = w >>> 26;
                for (; f !== 0 && h < l.length; h++) w = (l.words[h] | 0) + f, this.words[h] = w & 67108863, f = w >>> 26;
                if (this.length = l.length, f !== 0) this.words[this.length] = f, this.length++;
                else if (l !== this)
                    for (; h < l.length; h++) this.words[h] = l.words[h];
                return this
            }, i.prototype.add = function(m) {
                var w;
                return m.negative !== 0 && this.negative === 0 ? (m.negative = 0, w = this.sub(m), m.negative ^= 1, w) : m.negative === 0 && this.negative !== 0 ? (this.negative = 0, w = m.sub(this), this.negative = 1, w) : this.length > m.length ? this.clone().iadd(m) : m.clone().iadd(this)
            }, i.prototype.isub = function(m) {
                if (m.negative !== 0) {
                    m.negative = 0;
                    var w = this.iadd(m);
                    return m.negative = 1, w._normSign()
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(m), this.negative = 1, this._normSign();
                var l = this.cmp(m);
                if (l === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var s, f;
                l > 0 ? (s = this, f = m) : (s = m, f = this);
                for (var h = 0, p = 0; p < f.length; p++) w = (s.words[p] | 0) - (f.words[p] | 0) + h, h = w >> 26, this.words[p] = w & 67108863;
                for (; h !== 0 && p < s.length; p++) w = (s.words[p] | 0) + h, h = w >> 26, this.words[p] = w & 67108863;
                if (h === 0 && p < s.length && s !== this)
                    for (; p < s.length; p++) this.words[p] = s.words[p];
                return this.length = Math.max(this.length, p), s !== this && (this.negative = 1), this.strip()
            }, i.prototype.sub = function(m) {
                return this.clone().isub(m)
            };

            function L(T, m, w) {
                w.negative = m.negative ^ T.negative;
                var l = T.length + m.length | 0;
                w.length = l, l = l - 1 | 0;
                var s = T.words[0] | 0,
                    f = m.words[0] | 0,
                    h = s * f,
                    p = h & 67108863,
                    d = h / 67108864 | 0;
                w.words[0] = p;
                for (var c = 1; c < l; c++) {
                    for (var x = d >>> 26, v = d & 67108863, u = Math.min(c, m.length - 1), _ = Math.max(0, c - T.length + 1); _ <= u; _++) {
                        var F = c - _ | 0;
                        s = T.words[F] | 0, f = m.words[_] | 0, h = s * f + v, x += h / 67108864 | 0, v = h & 67108863
                    }
                    w.words[c] = v | 0, d = x | 0
                }
                return d !== 0 ? w.words[c] = d | 0 : w.length--, w.strip()
            }
            var O = function(m, w, l) {
                var s = m.words,
                    f = w.words,
                    h = l.words,
                    p = 0,
                    d, c, x, v = s[0] | 0,
                    u = v & 8191,
                    _ = v >>> 13,
                    F = s[1] | 0,
                    S = F & 8191,
                    z = F >>> 13,
                    C = s[2] | 0,
                    D = C & 8191,
                    Y = C >>> 13,
                    Re = s[3] | 0,
                    ee = Re & 8191,
                    re = Re >>> 13,
                    Zt = s[4] | 0,
                    me = Zt & 8191,
                    Ee = Zt >>> 13,
                    $r = s[5] | 0,
                    Qe = $r & 8191,
                    Le = $r >>> 13,
                    Ar = s[6] | 0,
                    et = Ar & 8191,
                    je = Ar >>> 13,
                    Ur = s[7] | 0,
                    De = Ur & 8191,
                    We = Ur >>> 13,
                    Ir = s[8] | 0,
                    He = Ir & 8191,
                    Ve = Ir >>> 13,
                    jr = s[9] | 0,
                    it = jr & 8191,
                    Ge = jr >>> 13,
                    Nr = f[0] | 0,
                    Ke = Nr & 8191,
                    Fe = Nr >>> 13,
                    vr = f[1] | 0,
                    Ce = vr & 8191,
                    $e = vr >>> 13,
                    _r = f[2] | 0,
                    Oe = _r & 8191,
                    Ze = _r >>> 13,
                    Wr = f[3] | 0,
                    ot = Wr & 8191,
                    st = Wr >>> 13,
                    dr = f[4] | 0,
                    ze = dr & 8191,
                    Ne = dr >>> 13,
                    qr = f[5] | 0,
                    Ye = qr & 8191,
                    tt = qr >>> 13,
                    nn = f[6] | 0,
                    Be = nn & 8191,
                    rt = nn >>> 13,
                    M = f[7] | 0,
                    k = M & 8191,
                    R = M >>> 13,
                    b = f[8] | 0,
                    P = b & 8191,
                    U = b >>> 13,
                    j = f[9] | 0,
                    K = j & 8191,
                    W = j >>> 13;
                l.negative = m.negative ^ w.negative, l.length = 19, d = Math.imul(u, Ke), c = Math.imul(u, Fe), c = c + Math.imul(_, Ke) | 0, x = Math.imul(_, Fe);
                var Pe = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, d = Math.imul(S, Ke), c = Math.imul(S, Fe), c = c + Math.imul(z, Ke) | 0, x = Math.imul(z, Fe), d = d + Math.imul(u, Ce) | 0, c = c + Math.imul(u, $e) | 0, c = c + Math.imul(_, Ce) | 0, x = x + Math.imul(_, $e) | 0;
                var ne = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (ne >>> 26) | 0, ne &= 67108863, d = Math.imul(D, Ke), c = Math.imul(D, Fe), c = c + Math.imul(Y, Ke) | 0, x = Math.imul(Y, Fe), d = d + Math.imul(S, Ce) | 0, c = c + Math.imul(S, $e) | 0, c = c + Math.imul(z, Ce) | 0, x = x + Math.imul(z, $e) | 0, d = d + Math.imul(u, Oe) | 0, c = c + Math.imul(u, Ze) | 0, c = c + Math.imul(_, Oe) | 0, x = x + Math.imul(_, Ze) | 0;
                var Me = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, d = Math.imul(ee, Ke), c = Math.imul(ee, Fe), c = c + Math.imul(re, Ke) | 0, x = Math.imul(re, Fe), d = d + Math.imul(D, Ce) | 0, c = c + Math.imul(D, $e) | 0, c = c + Math.imul(Y, Ce) | 0, x = x + Math.imul(Y, $e) | 0, d = d + Math.imul(S, Oe) | 0, c = c + Math.imul(S, Ze) | 0, c = c + Math.imul(z, Oe) | 0, x = x + Math.imul(z, Ze) | 0, d = d + Math.imul(u, ot) | 0, c = c + Math.imul(u, st) | 0, c = c + Math.imul(_, ot) | 0, x = x + Math.imul(_, st) | 0;
                var Ae = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, d = Math.imul(me, Ke), c = Math.imul(me, Fe), c = c + Math.imul(Ee, Ke) | 0, x = Math.imul(Ee, Fe), d = d + Math.imul(ee, Ce) | 0, c = c + Math.imul(ee, $e) | 0, c = c + Math.imul(re, Ce) | 0, x = x + Math.imul(re, $e) | 0, d = d + Math.imul(D, Oe) | 0, c = c + Math.imul(D, Ze) | 0, c = c + Math.imul(Y, Oe) | 0, x = x + Math.imul(Y, Ze) | 0, d = d + Math.imul(S, ot) | 0, c = c + Math.imul(S, st) | 0, c = c + Math.imul(z, ot) | 0, x = x + Math.imul(z, st) | 0, d = d + Math.imul(u, ze) | 0, c = c + Math.imul(u, Ne) | 0, c = c + Math.imul(_, ze) | 0, x = x + Math.imul(_, Ne) | 0;
                var ut = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, d = Math.imul(Qe, Ke), c = Math.imul(Qe, Fe), c = c + Math.imul(Le, Ke) | 0, x = Math.imul(Le, Fe), d = d + Math.imul(me, Ce) | 0, c = c + Math.imul(me, $e) | 0, c = c + Math.imul(Ee, Ce) | 0, x = x + Math.imul(Ee, $e) | 0, d = d + Math.imul(ee, Oe) | 0, c = c + Math.imul(ee, Ze) | 0, c = c + Math.imul(re, Oe) | 0, x = x + Math.imul(re, Ze) | 0, d = d + Math.imul(D, ot) | 0, c = c + Math.imul(D, st) | 0, c = c + Math.imul(Y, ot) | 0, x = x + Math.imul(Y, st) | 0, d = d + Math.imul(S, ze) | 0, c = c + Math.imul(S, Ne) | 0, c = c + Math.imul(z, ze) | 0, x = x + Math.imul(z, Ne) | 0, d = d + Math.imul(u, Ye) | 0, c = c + Math.imul(u, tt) | 0, c = c + Math.imul(_, Ye) | 0, x = x + Math.imul(_, tt) | 0;
                var ht = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, d = Math.imul(et, Ke), c = Math.imul(et, Fe), c = c + Math.imul(je, Ke) | 0, x = Math.imul(je, Fe), d = d + Math.imul(Qe, Ce) | 0, c = c + Math.imul(Qe, $e) | 0, c = c + Math.imul(Le, Ce) | 0, x = x + Math.imul(Le, $e) | 0, d = d + Math.imul(me, Oe) | 0, c = c + Math.imul(me, Ze) | 0, c = c + Math.imul(Ee, Oe) | 0, x = x + Math.imul(Ee, Ze) | 0, d = d + Math.imul(ee, ot) | 0, c = c + Math.imul(ee, st) | 0, c = c + Math.imul(re, ot) | 0, x = x + Math.imul(re, st) | 0, d = d + Math.imul(D, ze) | 0, c = c + Math.imul(D, Ne) | 0, c = c + Math.imul(Y, ze) | 0, x = x + Math.imul(Y, Ne) | 0, d = d + Math.imul(S, Ye) | 0, c = c + Math.imul(S, tt) | 0, c = c + Math.imul(z, Ye) | 0, x = x + Math.imul(z, tt) | 0, d = d + Math.imul(u, Be) | 0, c = c + Math.imul(u, rt) | 0, c = c + Math.imul(_, Be) | 0, x = x + Math.imul(_, rt) | 0;
                var pt = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, d = Math.imul(De, Ke), c = Math.imul(De, Fe), c = c + Math.imul(We, Ke) | 0, x = Math.imul(We, Fe), d = d + Math.imul(et, Ce) | 0, c = c + Math.imul(et, $e) | 0, c = c + Math.imul(je, Ce) | 0, x = x + Math.imul(je, $e) | 0, d = d + Math.imul(Qe, Oe) | 0, c = c + Math.imul(Qe, Ze) | 0, c = c + Math.imul(Le, Oe) | 0, x = x + Math.imul(Le, Ze) | 0, d = d + Math.imul(me, ot) | 0, c = c + Math.imul(me, st) | 0, c = c + Math.imul(Ee, ot) | 0, x = x + Math.imul(Ee, st) | 0, d = d + Math.imul(ee, ze) | 0, c = c + Math.imul(ee, Ne) | 0, c = c + Math.imul(re, ze) | 0, x = x + Math.imul(re, Ne) | 0, d = d + Math.imul(D, Ye) | 0, c = c + Math.imul(D, tt) | 0, c = c + Math.imul(Y, Ye) | 0, x = x + Math.imul(Y, tt) | 0, d = d + Math.imul(S, Be) | 0, c = c + Math.imul(S, rt) | 0, c = c + Math.imul(z, Be) | 0, x = x + Math.imul(z, rt) | 0, d = d + Math.imul(u, k) | 0, c = c + Math.imul(u, R) | 0, c = c + Math.imul(_, k) | 0, x = x + Math.imul(_, R) | 0;
                var dt = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, d = Math.imul(He, Ke), c = Math.imul(He, Fe), c = c + Math.imul(Ve, Ke) | 0, x = Math.imul(Ve, Fe), d = d + Math.imul(De, Ce) | 0, c = c + Math.imul(De, $e) | 0, c = c + Math.imul(We, Ce) | 0, x = x + Math.imul(We, $e) | 0, d = d + Math.imul(et, Oe) | 0, c = c + Math.imul(et, Ze) | 0, c = c + Math.imul(je, Oe) | 0, x = x + Math.imul(je, Ze) | 0, d = d + Math.imul(Qe, ot) | 0, c = c + Math.imul(Qe, st) | 0, c = c + Math.imul(Le, ot) | 0, x = x + Math.imul(Le, st) | 0, d = d + Math.imul(me, ze) | 0, c = c + Math.imul(me, Ne) | 0, c = c + Math.imul(Ee, ze) | 0, x = x + Math.imul(Ee, Ne) | 0, d = d + Math.imul(ee, Ye) | 0, c = c + Math.imul(ee, tt) | 0, c = c + Math.imul(re, Ye) | 0, x = x + Math.imul(re, tt) | 0, d = d + Math.imul(D, Be) | 0, c = c + Math.imul(D, rt) | 0, c = c + Math.imul(Y, Be) | 0, x = x + Math.imul(Y, rt) | 0, d = d + Math.imul(S, k) | 0, c = c + Math.imul(S, R) | 0, c = c + Math.imul(z, k) | 0, x = x + Math.imul(z, R) | 0, d = d + Math.imul(u, P) | 0, c = c + Math.imul(u, U) | 0, c = c + Math.imul(_, P) | 0, x = x + Math.imul(_, U) | 0;
                var yt = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, d = Math.imul(it, Ke), c = Math.imul(it, Fe), c = c + Math.imul(Ge, Ke) | 0, x = Math.imul(Ge, Fe), d = d + Math.imul(He, Ce) | 0, c = c + Math.imul(He, $e) | 0, c = c + Math.imul(Ve, Ce) | 0, x = x + Math.imul(Ve, $e) | 0, d = d + Math.imul(De, Oe) | 0, c = c + Math.imul(De, Ze) | 0, c = c + Math.imul(We, Oe) | 0, x = x + Math.imul(We, Ze) | 0, d = d + Math.imul(et, ot) | 0, c = c + Math.imul(et, st) | 0, c = c + Math.imul(je, ot) | 0, x = x + Math.imul(je, st) | 0, d = d + Math.imul(Qe, ze) | 0, c = c + Math.imul(Qe, Ne) | 0, c = c + Math.imul(Le, ze) | 0, x = x + Math.imul(Le, Ne) | 0, d = d + Math.imul(me, Ye) | 0, c = c + Math.imul(me, tt) | 0, c = c + Math.imul(Ee, Ye) | 0, x = x + Math.imul(Ee, tt) | 0, d = d + Math.imul(ee, Be) | 0, c = c + Math.imul(ee, rt) | 0, c = c + Math.imul(re, Be) | 0, x = x + Math.imul(re, rt) | 0, d = d + Math.imul(D, k) | 0, c = c + Math.imul(D, R) | 0, c = c + Math.imul(Y, k) | 0, x = x + Math.imul(Y, R) | 0, d = d + Math.imul(S, P) | 0, c = c + Math.imul(S, U) | 0, c = c + Math.imul(z, P) | 0, x = x + Math.imul(z, U) | 0, d = d + Math.imul(u, K) | 0, c = c + Math.imul(u, W) | 0, c = c + Math.imul(_, K) | 0, x = x + Math.imul(_, W) | 0;
                var bt = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, d = Math.imul(it, Ce), c = Math.imul(it, $e), c = c + Math.imul(Ge, Ce) | 0, x = Math.imul(Ge, $e), d = d + Math.imul(He, Oe) | 0, c = c + Math.imul(He, Ze) | 0, c = c + Math.imul(Ve, Oe) | 0, x = x + Math.imul(Ve, Ze) | 0, d = d + Math.imul(De, ot) | 0, c = c + Math.imul(De, st) | 0, c = c + Math.imul(We, ot) | 0, x = x + Math.imul(We, st) | 0, d = d + Math.imul(et, ze) | 0, c = c + Math.imul(et, Ne) | 0, c = c + Math.imul(je, ze) | 0, x = x + Math.imul(je, Ne) | 0, d = d + Math.imul(Qe, Ye) | 0, c = c + Math.imul(Qe, tt) | 0, c = c + Math.imul(Le, Ye) | 0, x = x + Math.imul(Le, tt) | 0, d = d + Math.imul(me, Be) | 0, c = c + Math.imul(me, rt) | 0, c = c + Math.imul(Ee, Be) | 0, x = x + Math.imul(Ee, rt) | 0, d = d + Math.imul(ee, k) | 0, c = c + Math.imul(ee, R) | 0, c = c + Math.imul(re, k) | 0, x = x + Math.imul(re, R) | 0, d = d + Math.imul(D, P) | 0, c = c + Math.imul(D, U) | 0, c = c + Math.imul(Y, P) | 0, x = x + Math.imul(Y, U) | 0, d = d + Math.imul(S, K) | 0, c = c + Math.imul(S, W) | 0, c = c + Math.imul(z, K) | 0, x = x + Math.imul(z, W) | 0;
                var mt = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, d = Math.imul(it, Oe), c = Math.imul(it, Ze), c = c + Math.imul(Ge, Oe) | 0, x = Math.imul(Ge, Ze), d = d + Math.imul(He, ot) | 0, c = c + Math.imul(He, st) | 0, c = c + Math.imul(Ve, ot) | 0, x = x + Math.imul(Ve, st) | 0, d = d + Math.imul(De, ze) | 0, c = c + Math.imul(De, Ne) | 0, c = c + Math.imul(We, ze) | 0, x = x + Math.imul(We, Ne) | 0, d = d + Math.imul(et, Ye) | 0, c = c + Math.imul(et, tt) | 0, c = c + Math.imul(je, Ye) | 0, x = x + Math.imul(je, tt) | 0, d = d + Math.imul(Qe, Be) | 0, c = c + Math.imul(Qe, rt) | 0, c = c + Math.imul(Le, Be) | 0, x = x + Math.imul(Le, rt) | 0, d = d + Math.imul(me, k) | 0, c = c + Math.imul(me, R) | 0, c = c + Math.imul(Ee, k) | 0, x = x + Math.imul(Ee, R) | 0, d = d + Math.imul(ee, P) | 0, c = c + Math.imul(ee, U) | 0, c = c + Math.imul(re, P) | 0, x = x + Math.imul(re, U) | 0, d = d + Math.imul(D, K) | 0, c = c + Math.imul(D, W) | 0, c = c + Math.imul(Y, K) | 0, x = x + Math.imul(Y, W) | 0;
                var ke = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, d = Math.imul(it, ot), c = Math.imul(it, st), c = c + Math.imul(Ge, ot) | 0, x = Math.imul(Ge, st), d = d + Math.imul(He, ze) | 0, c = c + Math.imul(He, Ne) | 0, c = c + Math.imul(Ve, ze) | 0, x = x + Math.imul(Ve, Ne) | 0, d = d + Math.imul(De, Ye) | 0, c = c + Math.imul(De, tt) | 0, c = c + Math.imul(We, Ye) | 0, x = x + Math.imul(We, tt) | 0, d = d + Math.imul(et, Be) | 0, c = c + Math.imul(et, rt) | 0, c = c + Math.imul(je, Be) | 0, x = x + Math.imul(je, rt) | 0, d = d + Math.imul(Qe, k) | 0, c = c + Math.imul(Qe, R) | 0, c = c + Math.imul(Le, k) | 0, x = x + Math.imul(Le, R) | 0, d = d + Math.imul(me, P) | 0, c = c + Math.imul(me, U) | 0, c = c + Math.imul(Ee, P) | 0, x = x + Math.imul(Ee, U) | 0, d = d + Math.imul(ee, K) | 0, c = c + Math.imul(ee, W) | 0, c = c + Math.imul(re, K) | 0, x = x + Math.imul(re, W) | 0;
                var at = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, d = Math.imul(it, ze), c = Math.imul(it, Ne), c = c + Math.imul(Ge, ze) | 0, x = Math.imul(Ge, Ne), d = d + Math.imul(He, Ye) | 0, c = c + Math.imul(He, tt) | 0, c = c + Math.imul(Ve, Ye) | 0, x = x + Math.imul(Ve, tt) | 0, d = d + Math.imul(De, Be) | 0, c = c + Math.imul(De, rt) | 0, c = c + Math.imul(We, Be) | 0, x = x + Math.imul(We, rt) | 0, d = d + Math.imul(et, k) | 0, c = c + Math.imul(et, R) | 0, c = c + Math.imul(je, k) | 0, x = x + Math.imul(je, R) | 0, d = d + Math.imul(Qe, P) | 0, c = c + Math.imul(Qe, U) | 0, c = c + Math.imul(Le, P) | 0, x = x + Math.imul(Le, U) | 0, d = d + Math.imul(me, K) | 0, c = c + Math.imul(me, W) | 0, c = c + Math.imul(Ee, K) | 0, x = x + Math.imul(Ee, W) | 0;
                var Ie = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, d = Math.imul(it, Ye), c = Math.imul(it, tt), c = c + Math.imul(Ge, Ye) | 0, x = Math.imul(Ge, tt), d = d + Math.imul(He, Be) | 0, c = c + Math.imul(He, rt) | 0, c = c + Math.imul(Ve, Be) | 0, x = x + Math.imul(Ve, rt) | 0, d = d + Math.imul(De, k) | 0, c = c + Math.imul(De, R) | 0, c = c + Math.imul(We, k) | 0, x = x + Math.imul(We, R) | 0, d = d + Math.imul(et, P) | 0, c = c + Math.imul(et, U) | 0, c = c + Math.imul(je, P) | 0, x = x + Math.imul(je, U) | 0, d = d + Math.imul(Qe, K) | 0, c = c + Math.imul(Qe, W) | 0, c = c + Math.imul(Le, K) | 0, x = x + Math.imul(Le, W) | 0;
                var Te = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, d = Math.imul(it, Be), c = Math.imul(it, rt), c = c + Math.imul(Ge, Be) | 0, x = Math.imul(Ge, rt), d = d + Math.imul(He, k) | 0, c = c + Math.imul(He, R) | 0, c = c + Math.imul(Ve, k) | 0, x = x + Math.imul(Ve, R) | 0, d = d + Math.imul(De, P) | 0, c = c + Math.imul(De, U) | 0, c = c + Math.imul(We, P) | 0, x = x + Math.imul(We, U) | 0, d = d + Math.imul(et, K) | 0, c = c + Math.imul(et, W) | 0, c = c + Math.imul(je, K) | 0, x = x + Math.imul(je, W) | 0;
                var qe = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, d = Math.imul(it, k), c = Math.imul(it, R), c = c + Math.imul(Ge, k) | 0, x = Math.imul(Ge, R), d = d + Math.imul(He, P) | 0, c = c + Math.imul(He, U) | 0, c = c + Math.imul(Ve, P) | 0, x = x + Math.imul(Ve, U) | 0, d = d + Math.imul(De, K) | 0, c = c + Math.imul(De, W) | 0, c = c + Math.imul(We, K) | 0, x = x + Math.imul(We, W) | 0;
                var Se = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, d = Math.imul(it, P), c = Math.imul(it, U), c = c + Math.imul(Ge, P) | 0, x = Math.imul(Ge, U), d = d + Math.imul(He, K) | 0, c = c + Math.imul(He, W) | 0, c = c + Math.imul(Ve, K) | 0, x = x + Math.imul(Ve, W) | 0;
                var H = (p + d | 0) + ((c & 8191) << 13) | 0;
                p = (x + (c >>> 13) | 0) + (H >>> 26) | 0, H &= 67108863, d = Math.imul(it, K), c = Math.imul(it, W), c = c + Math.imul(Ge, K) | 0, x = Math.imul(Ge, W);
                var V = (p + d | 0) + ((c & 8191) << 13) | 0;
                return p = (x + (c >>> 13) | 0) + (V >>> 26) | 0, V &= 67108863, h[0] = Pe, h[1] = ne, h[2] = Me, h[3] = Ae, h[4] = ut, h[5] = ht, h[6] = pt, h[7] = dt, h[8] = yt, h[9] = bt, h[10] = mt, h[11] = ke, h[12] = at, h[13] = Ie, h[14] = Te, h[15] = qe, h[16] = Se, h[17] = H, h[18] = V, p !== 0 && (h[19] = p, l.length++), l
            };
            Math.imul || (O = L);

            function Z(T, m, w) {
                w.negative = m.negative ^ T.negative, w.length = T.length + m.length;
                for (var l = 0, s = 0, f = 0; f < w.length - 1; f++) {
                    var h = s;
                    s = 0;
                    for (var p = l & 67108863, d = Math.min(f, m.length - 1), c = Math.max(0, f - T.length + 1); c <= d; c++) {
                        var x = f - c,
                            v = T.words[x] | 0,
                            u = m.words[c] | 0,
                            _ = v * u,
                            F = _ & 67108863;
                        h = h + (_ / 67108864 | 0) | 0, F = F + p | 0, p = F & 67108863, h = h + (F >>> 26) | 0, s += h >>> 26, h &= 67108863
                    }
                    w.words[f] = p, l = h, h = s
                }
                return l !== 0 ? w.words[f] = l : w.length--, w.strip()
            }

            function ge(T, m, w) {
                var l = new ce;
                return l.mulp(T, m, w)
            }
            i.prototype.mulTo = function(m, w) {
                var l, s = this.length + m.length;
                return this.length === 10 && m.length === 10 ? l = O(this, m, w) : s < 63 ? l = L(this, m, w) : s < 1024 ? l = Z(this, m, w) : l = ge(this, m, w), l
            };

            function ce(T, m) {
                this.x = T, this.y = m
            }
            ce.prototype.makeRBT = function(m) {
                for (var w = new Array(m), l = i.prototype._countBits(m) - 1, s = 0; s < m; s++) w[s] = this.revBin(s, l, m);
                return w
            }, ce.prototype.revBin = function(m, w, l) {
                if (m === 0 || m === l - 1) return m;
                for (var s = 0, f = 0; f < w; f++) s |= (m & 1) << w - f - 1, m >>= 1;
                return s
            }, ce.prototype.permute = function(m, w, l, s, f, h) {
                for (var p = 0; p < h; p++) s[p] = w[m[p]], f[p] = l[m[p]]
            }, ce.prototype.transform = function(m, w, l, s, f, h) {
                this.permute(h, m, w, l, s, f);
                for (var p = 1; p < f; p <<= 1)
                    for (var d = p << 1, c = Math.cos(2 * Math.PI / d), x = Math.sin(2 * Math.PI / d), v = 0; v < f; v += d)
                        for (var u = c, _ = x, F = 0; F < p; F++) {
                            var S = l[v + F],
                                z = s[v + F],
                                C = l[v + F + p],
                                D = s[v + F + p],
                                Y = u * C - _ * D;
                            D = u * D + _ * C, C = Y, l[v + F] = S + C, s[v + F] = z + D, l[v + F + p] = S - C, s[v + F + p] = z - D, F !== d && (Y = c * u - x * _, _ = c * _ + x * u, u = Y)
                        }
            }, ce.prototype.guessLen13b = function(m, w) {
                var l = Math.max(w, m) | 1,
                    s = l & 1,
                    f = 0;
                for (l = l / 2 | 0; l; l = l >>> 1) f++;
                return 1 << f + 1 + s
            }, ce.prototype.conjugate = function(m, w, l) {
                if (!(l <= 1))
                    for (var s = 0; s < l / 2; s++) {
                        var f = m[s];
                        m[s] = m[l - s - 1], m[l - s - 1] = f, f = w[s], w[s] = -w[l - s - 1], w[l - s - 1] = -f
                    }
            }, ce.prototype.normalize13b = function(m, w) {
                for (var l = 0, s = 0; s < w / 2; s++) {
                    var f = Math.round(m[2 * s + 1] / w) * 8192 + Math.round(m[2 * s] / w) + l;
                    m[s] = f & 67108863, f < 67108864 ? l = 0 : l = f / 67108864 | 0
                }
                return m
            }, ce.prototype.convert13b = function(m, w, l, s) {
                for (var f = 0, h = 0; h < w; h++) f = f + (m[h] | 0), l[2 * h] = f & 8191, f = f >>> 13, l[2 * h + 1] = f & 8191, f = f >>> 13;
                for (h = 2 * w; h < s; ++h) l[h] = 0;
                t(f === 0), t((f & -8192) === 0)
            }, ce.prototype.stub = function(m) {
                for (var w = new Array(m), l = 0; l < m; l++) w[l] = 0;
                return w
            }, ce.prototype.mulp = function(m, w, l) {
                var s = 2 * this.guessLen13b(m.length, w.length),
                    f = this.makeRBT(s),
                    h = this.stub(s),
                    p = new Array(s),
                    d = new Array(s),
                    c = new Array(s),
                    x = new Array(s),
                    v = new Array(s),
                    u = new Array(s),
                    _ = l.words;
                _.length = s, this.convert13b(m.words, m.length, p, s), this.convert13b(w.words, w.length, x, s), this.transform(p, h, d, c, s, f), this.transform(x, h, v, u, s, f);
                for (var F = 0; F < s; F++) {
                    var S = d[F] * v[F] - c[F] * u[F];
                    c[F] = d[F] * u[F] + c[F] * v[F], d[F] = S
                }
                return this.conjugate(d, c, s), this.transform(d, c, _, h, s, f), this.conjugate(_, h, s), this.normalize13b(_, s), l.negative = m.negative ^ w.negative, l.length = m.length + w.length, l.strip()
            }, i.prototype.mul = function(m) {
                var w = new i(null);
                return w.words = new Array(this.length + m.length), this.mulTo(m, w)
            }, i.prototype.mulf = function(m) {
                var w = new i(null);
                return w.words = new Array(this.length + m.length), ge(this, m, w)
            }, i.prototype.imul = function(m) {
                return this.clone().mulTo(m, this)
            }, i.prototype.imuln = function(m) {
                t(typeof m == "number"), t(m < 67108864);
                for (var w = 0, l = 0; l < this.length; l++) {
                    var s = (this.words[l] | 0) * m,
                        f = (s & 67108863) + (w & 67108863);
                    w >>= 26, w += s / 67108864 | 0, w += f >>> 26, this.words[l] = f & 67108863
                }
                return w !== 0 && (this.words[l] = w, this.length++), this
            }, i.prototype.muln = function(m) {
                return this.clone().imuln(m)
            }, i.prototype.sqr = function() {
                return this.mul(this)
            }, i.prototype.isqr = function() {
                return this.imul(this.clone())
            }, i.prototype.pow = function(m) {
                var w = q(m);
                if (w.length === 0) return new i(1);
                for (var l = this, s = 0; s < w.length && w[s] === 0; s++, l = l.sqr());
                if (++s < w.length)
                    for (var f = l.sqr(); s < w.length; s++, f = f.sqr()) w[s] !== 0 && (l = l.mul(f));
                return l
            }, i.prototype.iushln = function(m) {
                t(typeof m == "number" && m >= 0);
                var w = m % 26,
                    l = (m - w) / 26,
                    s = 67108863 >>> 26 - w << 26 - w,
                    f;
                if (w !== 0) {
                    var h = 0;
                    for (f = 0; f < this.length; f++) {
                        var p = this.words[f] & s,
                            d = (this.words[f] | 0) - p << w;
                        this.words[f] = d | h, h = p >>> 26 - w
                    }
                    h && (this.words[f] = h, this.length++)
                }
                if (l !== 0) {
                    for (f = this.length - 1; f >= 0; f--) this.words[f + l] = this.words[f];
                    for (f = 0; f < l; f++) this.words[f] = 0;
                    this.length += l
                }
                return this.strip()
            }, i.prototype.ishln = function(m) {
                return t(this.negative === 0), this.iushln(m)
            }, i.prototype.iushrn = function(m, w, l) {
                t(typeof m == "number" && m >= 0);
                var s;
                w ? s = (w - w % 26) / 26 : s = 0;
                var f = m % 26,
                    h = Math.min((m - f) / 26, this.length),
                    p = 67108863 ^ 67108863 >>> f << f,
                    d = l;
                if (s -= h, s = Math.max(0, s), d) {
                    for (var c = 0; c < h; c++) d.words[c] = this.words[c];
                    d.length = h
                }
                if (h !== 0)
                    if (this.length > h)
                        for (this.length -= h, c = 0; c < this.length; c++) this.words[c] = this.words[c + h];
                    else this.words[0] = 0, this.length = 1;
                var x = 0;
                for (c = this.length - 1; c >= 0 && (x !== 0 || c >= s); c--) {
                    var v = this.words[c] | 0;
                    this.words[c] = x << 26 - f | v >>> f, x = v & p
                }
                return d && x !== 0 && (d.words[d.length++] = x), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip()
            }, i.prototype.ishrn = function(m, w, l) {
                return t(this.negative === 0), this.iushrn(m, w, l)
            }, i.prototype.shln = function(m) {
                return this.clone().ishln(m)
            }, i.prototype.ushln = function(m) {
                return this.clone().iushln(m)
            }, i.prototype.shrn = function(m) {
                return this.clone().ishrn(m)
            }, i.prototype.ushrn = function(m) {
                return this.clone().iushrn(m)
            }, i.prototype.testn = function(m) {
                t(typeof m == "number" && m >= 0);
                var w = m % 26,
                    l = (m - w) / 26,
                    s = 1 << w;
                if (this.length <= l) return !1;
                var f = this.words[l];
                return !!(f & s)
            }, i.prototype.imaskn = function(m) {
                t(typeof m == "number" && m >= 0);
                var w = m % 26,
                    l = (m - w) / 26;
                if (t(this.negative === 0, "imaskn works only with positive numbers"), this.length <= l) return this;
                if (w !== 0 && l++, this.length = Math.min(l, this.length), w !== 0) {
                    var s = 67108863 ^ 67108863 >>> w << w;
                    this.words[this.length - 1] &= s
                }
                return this.strip()
            }, i.prototype.maskn = function(m) {
                return this.clone().imaskn(m)
            }, i.prototype.iaddn = function(m) {
                return t(typeof m == "number"), t(m < 67108864), m < 0 ? this.isubn(-m) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < m ? (this.words[0] = m - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(m), this.negative = 1, this) : this._iaddn(m)
            }, i.prototype._iaddn = function(m) {
                this.words[0] += m;
                for (var w = 0; w < this.length && this.words[w] >= 67108864; w++) this.words[w] -= 67108864, w === this.length - 1 ? this.words[w + 1] = 1 : this.words[w + 1]++;
                return this.length = Math.max(this.length, w + 1), this
            }, i.prototype.isubn = function(m) {
                if (t(typeof m == "number"), t(m < 67108864), m < 0) return this.iaddn(-m);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(m), this.negative = 1, this;
                if (this.words[0] -= m, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else
                    for (var w = 0; w < this.length && this.words[w] < 0; w++) this.words[w] += 67108864, this.words[w + 1] -= 1;
                return this.strip()
            }, i.prototype.addn = function(m) {
                return this.clone().iaddn(m)
            }, i.prototype.subn = function(m) {
                return this.clone().isubn(m)
            }, i.prototype.iabs = function() {
                return this.negative = 0, this
            }, i.prototype.abs = function() {
                return this.clone().iabs()
            }, i.prototype._ishlnsubmul = function(m, w, l) {
                var s = m.length + l,
                    f;
                this._expand(s);
                var h, p = 0;
                for (f = 0; f < m.length; f++) {
                    h = (this.words[f + l] | 0) + p;
                    var d = (m.words[f] | 0) * w;
                    h -= d & 67108863, p = (h >> 26) - (d / 67108864 | 0), this.words[f + l] = h & 67108863
                }
                for (; f < this.length - l; f++) h = (this.words[f + l] | 0) + p, p = h >> 26, this.words[f + l] = h & 67108863;
                if (p === 0) return this.strip();
                for (t(p === -1), p = 0, f = 0; f < this.length; f++) h = -(this.words[f] | 0) + p, p = h >> 26, this.words[f] = h & 67108863;
                return this.negative = 1, this.strip()
            }, i.prototype._wordDiv = function(m, w) {
                var l = this.length - m.length,
                    s = this.clone(),
                    f = m,
                    h = f.words[f.length - 1] | 0,
                    p = this._countBits(h);
                l = 26 - p, l !== 0 && (f = f.ushln(l), s.iushln(l), h = f.words[f.length - 1] | 0);
                var d = s.length - f.length,
                    c;
                if (w !== "mod") {
                    c = new i(null), c.length = d + 1, c.words = new Array(c.length);
                    for (var x = 0; x < c.length; x++) c.words[x] = 0
                }
                var v = s.clone()._ishlnsubmul(f, 1, d);
                v.negative === 0 && (s = v, c && (c.words[d] = 1));
                for (var u = d - 1; u >= 0; u--) {
                    var _ = (s.words[f.length + u] | 0) * 67108864 + (s.words[f.length + u - 1] | 0);
                    for (_ = Math.min(_ / h | 0, 67108863), s._ishlnsubmul(f, _, u); s.negative !== 0;) _--, s.negative = 0, s._ishlnsubmul(f, 1, u), s.isZero() || (s.negative ^= 1);
                    c && (c.words[u] = _)
                }
                return c && c.strip(), s.strip(), w !== "div" && l !== 0 && s.iushrn(l), {
                    div: c || null,
                    mod: s
                }
            }, i.prototype.divmod = function(m, w, l) {
                if (t(!m.isZero()), this.isZero()) return {
                    div: new i(0),
                    mod: new i(0)
                };
                var s, f, h;
                return this.negative !== 0 && m.negative === 0 ? (h = this.neg().divmod(m, w), w !== "mod" && (s = h.div.neg()), w !== "div" && (f = h.mod.neg(), l && f.negative !== 0 && f.iadd(m)), {
                    div: s,
                    mod: f
                }) : this.negative === 0 && m.negative !== 0 ? (h = this.divmod(m.neg(), w), w !== "mod" && (s = h.div.neg()), {
                    div: s,
                    mod: h.mod
                }) : (this.negative & m.negative) !== 0 ? (h = this.neg().divmod(m.neg(), w), w !== "div" && (f = h.mod.neg(), l && f.negative !== 0 && f.isub(m)), {
                    div: h.div,
                    mod: f
                }) : m.length > this.length || this.cmp(m) < 0 ? {
                    div: new i(0),
                    mod: this
                } : m.length === 1 ? w === "div" ? {
                    div: this.divn(m.words[0]),
                    mod: null
                } : w === "mod" ? {
                    div: null,
                    mod: new i(this.modn(m.words[0]))
                } : {
                    div: this.divn(m.words[0]),
                    mod: new i(this.modn(m.words[0]))
                } : this._wordDiv(m, w)
            }, i.prototype.div = function(m) {
                return this.divmod(m, "div", !1).div
            }, i.prototype.mod = function(m) {
                return this.divmod(m, "mod", !1).mod
            }, i.prototype.umod = function(m) {
                return this.divmod(m, "mod", !0).mod
            }, i.prototype.divRound = function(m) {
                var w = this.divmod(m);
                if (w.mod.isZero()) return w.div;
                var l = w.div.negative !== 0 ? w.mod.isub(m) : w.mod,
                    s = m.ushrn(1),
                    f = m.andln(1),
                    h = l.cmp(s);
                return h < 0 || f === 1 && h === 0 ? w.div : w.div.negative !== 0 ? w.div.isubn(1) : w.div.iaddn(1)
            }, i.prototype.modn = function(m) {
                t(m <= 67108863);
                for (var w = (1 << 26) % m, l = 0, s = this.length - 1; s >= 0; s--) l = (w * l + (this.words[s] | 0)) % m;
                return l
            }, i.prototype.idivn = function(m) {
                t(m <= 67108863);
                for (var w = 0, l = this.length - 1; l >= 0; l--) {
                    var s = (this.words[l] | 0) + w * 67108864;
                    this.words[l] = s / m | 0, w = s % m
                }
                return this.strip()
            }, i.prototype.divn = function(m) {
                return this.clone().idivn(m)
            }, i.prototype.egcd = function(m) {
                t(m.negative === 0), t(!m.isZero());
                var w = this,
                    l = m.clone();
                w.negative !== 0 ? w = w.umod(m) : w = w.clone();
                for (var s = new i(1), f = new i(0), h = new i(0), p = new i(1), d = 0; w.isEven() && l.isEven();) w.iushrn(1), l.iushrn(1), ++d;
                for (var c = l.clone(), x = w.clone(); !w.isZero();) {
                    for (var v = 0, u = 1;
                        (w.words[0] & u) === 0 && v < 26; ++v, u <<= 1);
                    if (v > 0)
                        for (w.iushrn(v); v-- > 0;)(s.isOdd() || f.isOdd()) && (s.iadd(c), f.isub(x)), s.iushrn(1), f.iushrn(1);
                    for (var _ = 0, F = 1;
                        (l.words[0] & F) === 0 && _ < 26; ++_, F <<= 1);
                    if (_ > 0)
                        for (l.iushrn(_); _-- > 0;)(h.isOdd() || p.isOdd()) && (h.iadd(c), p.isub(x)), h.iushrn(1), p.iushrn(1);
                    w.cmp(l) >= 0 ? (w.isub(l), s.isub(h), f.isub(p)) : (l.isub(w), h.isub(s), p.isub(f))
                }
                return {
                    a: h,
                    b: p,
                    gcd: l.iushln(d)
                }
            }, i.prototype._invmp = function(m) {
                t(m.negative === 0), t(!m.isZero());
                var w = this,
                    l = m.clone();
                w.negative !== 0 ? w = w.umod(m) : w = w.clone();
                for (var s = new i(1), f = new i(0), h = l.clone(); w.cmpn(1) > 0 && l.cmpn(1) > 0;) {
                    for (var p = 0, d = 1;
                        (w.words[0] & d) === 0 && p < 26; ++p, d <<= 1);
                    if (p > 0)
                        for (w.iushrn(p); p-- > 0;) s.isOdd() && s.iadd(h), s.iushrn(1);
                    for (var c = 0, x = 1;
                        (l.words[0] & x) === 0 && c < 26; ++c, x <<= 1);
                    if (c > 0)
                        for (l.iushrn(c); c-- > 0;) f.isOdd() && f.iadd(h), f.iushrn(1);
                    w.cmp(l) >= 0 ? (w.isub(l), s.isub(f)) : (l.isub(w), f.isub(s))
                }
                var v;
                return w.cmpn(1) === 0 ? v = s : v = f, v.cmpn(0) < 0 && v.iadd(m), v
            }, i.prototype.gcd = function(m) {
                if (this.isZero()) return m.abs();
                if (m.isZero()) return this.abs();
                var w = this.clone(),
                    l = m.clone();
                w.negative = 0, l.negative = 0;
                for (var s = 0; w.isEven() && l.isEven(); s++) w.iushrn(1), l.iushrn(1);
                do {
                    for (; w.isEven();) w.iushrn(1);
                    for (; l.isEven();) l.iushrn(1);
                    var f = w.cmp(l);
                    if (f < 0) {
                        var h = w;
                        w = l, l = h
                    } else if (f === 0 || l.cmpn(1) === 0) break;
                    w.isub(l)
                } while (!0);
                return l.iushln(s)
            }, i.prototype.invm = function(m) {
                return this.egcd(m).a.umod(m)
            }, i.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }, i.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }, i.prototype.andln = function(m) {
                return this.words[0] & m
            }, i.prototype.bincn = function(m) {
                t(typeof m == "number");
                var w = m % 26,
                    l = (m - w) / 26,
                    s = 1 << w;
                if (this.length <= l) return this._expand(l + 1), this.words[l] |= s, this;
                for (var f = s, h = l; f !== 0 && h < this.length; h++) {
                    var p = this.words[h] | 0;
                    p += f, f = p >>> 26, p &= 67108863, this.words[h] = p
                }
                return f !== 0 && (this.words[h] = f, this.length++), this
            }, i.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }, i.prototype.cmpn = function(m) {
                var w = m < 0;
                if (this.negative !== 0 && !w) return -1;
                if (this.negative === 0 && w) return 1;
                this.strip();
                var l;
                if (this.length > 1) l = 1;
                else {
                    w && (m = -m), t(m <= 67108863, "Number is too big");
                    var s = this.words[0] | 0;
                    l = s === m ? 0 : s < m ? -1 : 1
                }
                return this.negative !== 0 ? -l | 0 : l
            }, i.prototype.cmp = function(m) {
                if (this.negative !== 0 && m.negative === 0) return -1;
                if (this.negative === 0 && m.negative !== 0) return 1;
                var w = this.ucmp(m);
                return this.negative !== 0 ? -w | 0 : w
            }, i.prototype.ucmp = function(m) {
                if (this.length > m.length) return 1;
                if (this.length < m.length) return -1;
                for (var w = 0, l = this.length - 1; l >= 0; l--) {
                    var s = this.words[l] | 0,
                        f = m.words[l] | 0;
                    if (s !== f) {
                        s < f ? w = -1 : s > f && (w = 1);
                        break
                    }
                }
                return w
            }, i.prototype.gtn = function(m) {
                return this.cmpn(m) === 1
            }, i.prototype.gt = function(m) {
                return this.cmp(m) === 1
            }, i.prototype.gten = function(m) {
                return this.cmpn(m) >= 0
            }, i.prototype.gte = function(m) {
                return this.cmp(m) >= 0
            }, i.prototype.ltn = function(m) {
                return this.cmpn(m) === -1
            }, i.prototype.lt = function(m) {
                return this.cmp(m) === -1
            }, i.prototype.lten = function(m) {
                return this.cmpn(m) <= 0
            }, i.prototype.lte = function(m) {
                return this.cmp(m) <= 0
            }, i.prototype.eqn = function(m) {
                return this.cmpn(m) === 0
            }, i.prototype.eq = function(m) {
                return this.cmp(m) === 0
            }, i.red = function(m) {
                return new he(m)
            }, i.prototype.toRed = function(m) {
                return t(!this.red, "Already a number in reduction context"), t(this.negative === 0, "red works only with positives"), m.convertTo(this)._forceRed(m)
            }, i.prototype.fromRed = function() {
                return t(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }, i.prototype._forceRed = function(m) {
                return this.red = m, this
            }, i.prototype.forceRed = function(m) {
                return t(!this.red, "Already a number in reduction context"), this._forceRed(m)
            }, i.prototype.redAdd = function(m) {
                return t(this.red, "redAdd works only with red numbers"), this.red.add(this, m)
            }, i.prototype.redIAdd = function(m) {
                return t(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, m)
            }, i.prototype.redSub = function(m) {
                return t(this.red, "redSub works only with red numbers"), this.red.sub(this, m)
            }, i.prototype.redISub = function(m) {
                return t(this.red, "redISub works only with red numbers"), this.red.isub(this, m)
            }, i.prototype.redShl = function(m) {
                return t(this.red, "redShl works only with red numbers"), this.red.shl(this, m)
            }, i.prototype.redMul = function(m) {
                return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.mul(this, m)
            }, i.prototype.redIMul = function(m) {
                return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.imul(this, m)
            }, i.prototype.redSqr = function() {
                return t(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }, i.prototype.redISqr = function() {
                return t(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }, i.prototype.redSqrt = function() {
                return t(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }, i.prototype.redInvm = function() {
                return t(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }, i.prototype.redNeg = function() {
                return t(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }, i.prototype.redPow = function(m) {
                return t(this.red && !m.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, m)
            };
            var Xe = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };

            function xe(T, m) {
                this.name = T, this.p = new i(m, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
            }
            xe.prototype._tmp = function() {
                var m = new i(null);
                return m.words = new Array(Math.ceil(this.n / 13)), m
            }, xe.prototype.ireduce = function(m) {
                var w = m,
                    l;
                do this.split(w, this.tmp), w = this.imulK(w), w = w.iadd(this.tmp), l = w.bitLength(); while (l > this.n);
                var s = l < this.n ? -1 : w.ucmp(this.p);
                return s === 0 ? (w.words[0] = 0, w.length = 1) : s > 0 ? w.isub(this.p) : w.strip !== void 0 ? w.strip() : w._strip(), w
            }, xe.prototype.split = function(m, w) {
                m.iushrn(this.n, 0, w)
            }, xe.prototype.imulK = function(m) {
                return m.imul(this.k)
            };

            function ie() {
                xe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            n(ie, xe), ie.prototype.split = function(m, w) {
                for (var l = 4194303, s = Math.min(m.length, 9), f = 0; f < s; f++) w.words[f] = m.words[f];
                if (w.length = s, m.length <= 9) {
                    m.words[0] = 0, m.length = 1;
                    return
                }
                var h = m.words[9];
                for (w.words[w.length++] = h & l, f = 10; f < m.length; f++) {
                    var p = m.words[f] | 0;
                    m.words[f - 10] = (p & l) << 4 | h >>> 22, h = p
                }
                h >>>= 22, m.words[f - 10] = h, h === 0 && m.length > 10 ? m.length -= 10 : m.length -= 9
            }, ie.prototype.imulK = function(m) {
                m.words[m.length] = 0, m.words[m.length + 1] = 0, m.length += 2;
                for (var w = 0, l = 0; l < m.length; l++) {
                    var s = m.words[l] | 0;
                    w += s * 977, m.words[l] = w & 67108863, w = s * 64 + (w / 67108864 | 0)
                }
                return m.words[m.length - 1] === 0 && (m.length--, m.words[m.length - 1] === 0 && m.length--), m
            };

            function ae() {
                xe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            n(ae, xe);

            function be() {
                xe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            n(be, xe);

            function we() {
                xe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            n(we, xe), we.prototype.imulK = function(m) {
                for (var w = 0, l = 0; l < m.length; l++) {
                    var s = (m.words[l] | 0) * 19 + w,
                        f = s & 67108863;
                    s >>>= 26, m.words[l] = f, w = s
                }
                return w !== 0 && (m.words[m.length++] = w), m
            }, i._prime = function(m) {
                if (Xe[m]) return Xe[m];
                var w;
                if (m === "k256") w = new ie;
                else if (m === "p224") w = new ae;
                else if (m === "p192") w = new be;
                else if (m === "p25519") w = new we;
                else throw new Error("Unknown prime " + m);
                return Xe[m] = w, w
            };

            function he(T) {
                if (typeof T == "string") {
                    var m = i._prime(T);
                    this.m = m.p, this.prime = m
                } else t(T.gtn(1), "modulus must be greater than 1"), this.m = T, this.prime = null
            }
            he.prototype._verify1 = function(m) {
                t(m.negative === 0, "red works only with positives"), t(m.red, "red works only with red numbers")
            }, he.prototype._verify2 = function(m, w) {
                t((m.negative | w.negative) === 0, "red works only with positives"), t(m.red && m.red === w.red, "red works only with red numbers")
            }, he.prototype.imod = function(m) {
                return this.prime ? this.prime.ireduce(m)._forceRed(this) : m.umod(this.m)._forceRed(this)
            }, he.prototype.neg = function(m) {
                return m.isZero() ? m.clone() : this.m.sub(m)._forceRed(this)
            }, he.prototype.add = function(m, w) {
                this._verify2(m, w);
                var l = m.add(w);
                return l.cmp(this.m) >= 0 && l.isub(this.m), l._forceRed(this)
            }, he.prototype.iadd = function(m, w) {
                this._verify2(m, w);
                var l = m.iadd(w);
                return l.cmp(this.m) >= 0 && l.isub(this.m), l
            }, he.prototype.sub = function(m, w) {
                this._verify2(m, w);
                var l = m.sub(w);
                return l.cmpn(0) < 0 && l.iadd(this.m), l._forceRed(this)
            }, he.prototype.isub = function(m, w) {
                this._verify2(m, w);
                var l = m.isub(w);
                return l.cmpn(0) < 0 && l.iadd(this.m), l
            }, he.prototype.shl = function(m, w) {
                return this._verify1(m), this.imod(m.ushln(w))
            }, he.prototype.imul = function(m, w) {
                return this._verify2(m, w), this.imod(m.imul(w))
            }, he.prototype.mul = function(m, w) {
                return this._verify2(m, w), this.imod(m.mul(w))
            }, he.prototype.isqr = function(m) {
                return this.imul(m, m.clone())
            }, he.prototype.sqr = function(m) {
                return this.mul(m, m)
            }, he.prototype.sqrt = function(m) {
                if (m.isZero()) return m.clone();
                var w = this.m.andln(3);
                if (t(w % 2 === 1), w === 3) {
                    var l = this.m.add(new i(1)).iushrn(2);
                    return this.pow(m, l)
                }
                for (var s = this.m.subn(1), f = 0; !s.isZero() && s.andln(1) === 0;) f++, s.iushrn(1);
                t(!s.isZero());
                var h = new i(1).toRed(this),
                    p = h.redNeg(),
                    d = this.m.subn(1).iushrn(1),
                    c = this.m.bitLength();
                for (c = new i(2 * c * c).toRed(this); this.pow(c, d).cmp(p) !== 0;) c.redIAdd(p);
                for (var x = this.pow(c, s), v = this.pow(m, s.addn(1).iushrn(1)), u = this.pow(m, s), _ = f; u.cmp(h) !== 0;) {
                    for (var F = u, S = 0; F.cmp(h) !== 0; S++) F = F.redSqr();
                    t(S < _);
                    var z = this.pow(x, new i(1).iushln(_ - S - 1));
                    v = v.redMul(z), x = z.redSqr(), u = u.redMul(x), _ = S
                }
                return v
            }, he.prototype.invm = function(m) {
                var w = m._invmp(this.m);
                return w.negative !== 0 ? (w.negative = 0, this.imod(w).redNeg()) : this.imod(w)
            }, he.prototype.pow = function(m, w) {
                if (w.isZero()) return new i(1).toRed(this);
                if (w.cmpn(1) === 0) return m.clone();
                var l = 4,
                    s = new Array(1 << l);
                s[0] = new i(1).toRed(this), s[1] = m;
                for (var f = 2; f < s.length; f++) s[f] = this.mul(s[f - 1], m);
                var h = s[0],
                    p = 0,
                    d = 0,
                    c = w.bitLength() % 26;
                for (c === 0 && (c = 26), f = w.length - 1; f >= 0; f--) {
                    for (var x = w.words[f], v = c - 1; v >= 0; v--) {
                        var u = x >> v & 1;
                        if (h !== s[0] && (h = this.sqr(h)), u === 0 && p === 0) {
                            d = 0;
                            continue
                        }
                        p <<= 1, p |= u, d++, !(d !== l && (f !== 0 || v !== 0)) && (h = this.mul(h, s[p]), d = 0, p = 0)
                    }
                    c = 26
                }
                return h
            }, he.prototype.convertTo = function(m) {
                var w = m.umod(this.m);
                return w === m ? w.clone() : w
            }, he.prototype.convertFrom = function(m) {
                var w = m.clone();
                return w.red = null, w
            }, i.mont = function(m) {
                return new gt(m)
            };

            function gt(T) {
                he.call(this, T), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
            }
            n(gt, he), gt.prototype.convertTo = function(m) {
                return this.imod(m.ushln(this.shift))
            }, gt.prototype.convertFrom = function(m) {
                var w = this.imod(m.mul(this.rinv));
                return w.red = null, w
            }, gt.prototype.imul = function(m, w) {
                if (m.isZero() || w.isZero()) return m.words[0] = 0, m.length = 1, m;
                var l = m.imul(w),
                    s = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    f = l.isub(s).iushrn(this.shift),
                    h = f;
                return f.cmp(this.m) >= 0 ? h = f.isub(this.m) : f.cmpn(0) < 0 && (h = f.iadd(this.m)), h._forceRed(this)
            }, gt.prototype.mul = function(m, w) {
                if (m.isZero() || w.isZero()) return new i(0)._forceRed(this);
                var l = m.mul(w),
                    s = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    f = l.isub(s).iushrn(this.shift),
                    h = f;
                return f.cmp(this.m) >= 0 ? h = f.isub(this.m) : f.cmpn(0) < 0 && (h = f.iadd(this.m)), h._forceRed(this)
            }, gt.prototype.invm = function(m) {
                var w = this.imod(m._invmp(this.m).mul(this.r2));
                return w._forceRed(this)
            }
        })(typeof $0 > "u" || $0, mx)
    });
    var po = Ue((OL, bx) => {
        bx.exports = gx;

        function gx(r, e) {
            if (!r) throw new Error(e || "Assertion failed")
        }
        gx.equal = function(e, t, n) {
            if (e != t) throw new Error(n || "Assertion failed: " + e + " != " + t)
        }
    });
    var j0 = Ue(wx => {
        "use strict";
        var _c = wx;

        function i_(r, e) {
            if (Array.isArray(r)) return r.slice();
            if (!r) return [];
            var t = [];
            if (typeof r != "string") {
                for (var n = 0; n < r.length; n++) t[n] = r[n] | 0;
                return t
            }
            if (e === "hex") {
                r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 !== 0 && (r = "0" + r);
                for (var n = 0; n < r.length; n += 2) t.push(parseInt(r[n] + r[n + 1], 16))
            } else
                for (var n = 0; n < r.length; n++) {
                    var i = r.charCodeAt(n),
                        o = i >> 8,
                        a = i & 255;
                    o ? t.push(o, a) : t.push(a)
                }
            return t
        }
        _c.toArray = i_;

        function xx(r) {
            return r.length === 1 ? "0" + r : r
        }
        _c.zero2 = xx;

        function vx(r) {
            for (var e = "", t = 0; t < r.length; t++) e += xx(r[t].toString(16));
            return e
        }
        _c.toHex = vx;
        _c.encode = function(e, t) {
            return t === "hex" ? vx(e) : e
        }
    });
    var En = Ue(_x => {
        "use strict";
        var Wn = _x,
            o_ = ci(),
            s_ = po(),
            Ec = j0();
        Wn.assert = s_;
        Wn.toArray = Ec.toArray;
        Wn.zero2 = Ec.zero2;
        Wn.toHex = Ec.toHex;
        Wn.encode = Ec.encode;

        function a_(r, e, t) {
            var n = new Array(Math.max(r.bitLength(), t) + 1);
            n.fill(0);
            for (var i = 1 << e + 1, o = r.clone(), a = 0; a < n.length; a++) {
                var y, g = o.andln(i - 1);
                o.isOdd() ? (g > (i >> 1) - 1 ? y = (i >> 1) - g : y = g, o.isubn(y)) : y = 0, n[a] = y, o.iushrn(1)
            }
            return n
        }
        Wn.getNAF = a_;

        function f_(r, e) {
            var t = [
                [],
                []
            ];
            r = r.clone(), e = e.clone();
            for (var n = 0, i = 0, o; r.cmpn(-n) > 0 || e.cmpn(-i) > 0;) {
                var a = r.andln(3) + n & 3,
                    y = e.andln(3) + i & 3;
                a === 3 && (a = -1), y === 3 && (y = -1);
                var g;
                (a & 1) === 0 ? g = 0 : (o = r.andln(7) + n & 7, (o === 3 || o === 5) && y === 2 ? g = -a : g = a), t[0].push(g);
                var E;
                (y & 1) === 0 ? E = 0 : (o = e.andln(7) + i & 7, (o === 3 || o === 5) && a === 2 ? E = -y : E = y), t[1].push(E), 2 * n === g + 1 && (n = 1 - n), 2 * i === E + 1 && (i = 1 - i), r.iushrn(1), e.iushrn(1)
            }
            return t
        }
        Wn.getJSF = f_;

        function u_(r, e, t) {
            var n = "_" + e;
            r.prototype[e] = function() {
                return this[n] !== void 0 ? this[n] : this[n] = t.call(this)
            }
        }
        Wn.cachedProperty = u_;

        function c_(r) {
            return typeof r == "string" ? Wn.toArray(r, "hex") : r
        }
        Wn.parseBytes = c_;

        function h_(r) {
            return new o_(r, "hex", "le")
        }
        Wn.intFromLE = h_
    });
    var G0 = Ue(($L, V0) => {
        var W0;
        V0.exports = function(e) {
            return W0 || (W0 = new yo(null)), W0.generate(e)
        };

        function yo(r) {
            this.rand = r
        }
        V0.exports.Rand = yo;
        yo.prototype.generate = function(e) {
            return this._rand(e)
        };
        yo.prototype._rand = function(e) {
            if (this.rand.getBytes) return this.rand.getBytes(e);
            for (var t = new Uint8Array(e), n = 0; n < t.length; n++) t[n] = this.rand.getByte();
            return t
        };
        if (typeof self == "object") self.crypto && self.crypto.getRandomValues ? yo.prototype._rand = function(e) {
            var t = new Uint8Array(e);
            return self.crypto.getRandomValues(t), t
        } : self.msCrypto && self.msCrypto.getRandomValues ? yo.prototype._rand = function(e) {
            var t = new Uint8Array(e);
            return self.msCrypto.getRandomValues(t), t
        } : typeof window == "object" && (yo.prototype._rand = function() {
            throw new Error("Not implemented yet")
        });
        else try {
            if (H0 = Jh(), typeof H0.randomBytes != "function") throw new Error("Not supported");
            yo.prototype._rand = function(e) {
                return H0.randomBytes(e)
            }
        } catch {}
        var H0
    });
    var Na = Ue((jL, Ex) => {
        "use strict";
        var Do = ci(),
            Ua = En(),
            Sc = Ua.getNAF,
            l_ = Ua.getJSF,
            Mc = Ua.assert;

        function mo(r, e) {
            this.type = r, this.p = new Do(e.p, 16), this.red = e.prime ? Do.red(e.prime) : Do.mont(this.p), this.zero = new Do(0).toRed(this.red), this.one = new Do(1).toRed(this.red), this.two = new Do(2).toRed(this.red), this.n = e.n && new Do(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
            var t = this.n && this.p.div(this.n);
            !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
        }
        Ex.exports = mo;
        mo.prototype.point = function() {
            throw new Error("Not implemented")
        };
        mo.prototype.validate = function() {
            throw new Error("Not implemented")
        };
        mo.prototype._fixedNafMul = function(e, t) {
            Mc(e.precomputed);
            var n = e._getDoubles(),
                i = Sc(t, 1, this._bitLength),
                o = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
            o /= 3;
            var a = [],
                y, g;
            for (y = 0; y < i.length; y += n.step) {
                g = 0;
                for (var E = y + n.step - 1; E >= y; E--) g = (g << 1) + i[E];
                a.push(g)
            }
            for (var A = this.jpoint(null, null, null), I = this.jpoint(null, null, null), q = o; q > 0; q--) {
                for (y = 0; y < a.length; y++) g = a[y], g === q ? I = I.mixedAdd(n.points[y]) : g === -q && (I = I.mixedAdd(n.points[y].neg()));
                A = A.add(I)
            }
            return A.toP()
        };
        mo.prototype._wnafMul = function(e, t) {
            var n = 4,
                i = e._getNAFPoints(n);
            n = i.wnd;
            for (var o = i.points, a = Sc(t, n, this._bitLength), y = this.jpoint(null, null, null), g = a.length - 1; g >= 0; g--) {
                for (var E = 0; g >= 0 && a[g] === 0; g--) E++;
                if (g >= 0 && E++, y = y.dblp(E), g < 0) break;
                var A = a[g];
                Mc(A !== 0), e.type === "affine" ? A > 0 ? y = y.mixedAdd(o[A - 1 >> 1]) : y = y.mixedAdd(o[-A - 1 >> 1].neg()) : A > 0 ? y = y.add(o[A - 1 >> 1]) : y = y.add(o[-A - 1 >> 1].neg())
            }
            return e.type === "affine" ? y.toP() : y
        };
        mo.prototype._wnafMulAdd = function(e, t, n, i, o) {
            var a = this._wnafT1,
                y = this._wnafT2,
                g = this._wnafT3,
                E = 0,
                A, I, q;
            for (A = 0; A < i; A++) {
                q = t[A];
                var L = q._getNAFPoints(e);
                a[A] = L.wnd, y[A] = L.points
            }
            for (A = i - 1; A >= 1; A -= 2) {
                var O = A - 1,
                    Z = A;
                if (a[O] !== 1 || a[Z] !== 1) {
                    g[O] = Sc(n[O], a[O], this._bitLength), g[Z] = Sc(n[Z], a[Z], this._bitLength), E = Math.max(g[O].length, E), E = Math.max(g[Z].length, E);
                    continue
                }
                var ge = [t[O], null, null, t[Z]];
                t[O].y.cmp(t[Z].y) === 0 ? (ge[1] = t[O].add(t[Z]), ge[2] = t[O].toJ().mixedAdd(t[Z].neg())) : t[O].y.cmp(t[Z].y.redNeg()) === 0 ? (ge[1] = t[O].toJ().mixedAdd(t[Z]), ge[2] = t[O].add(t[Z].neg())) : (ge[1] = t[O].toJ().mixedAdd(t[Z]), ge[2] = t[O].toJ().mixedAdd(t[Z].neg()));
                var ce = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
                    Xe = l_(n[O], n[Z]);
                for (E = Math.max(Xe[0].length, E), g[O] = new Array(E), g[Z] = new Array(E), I = 0; I < E; I++) {
                    var xe = Xe[0][I] | 0,
                        ie = Xe[1][I] | 0;
                    g[O][I] = ce[(xe + 1) * 3 + (ie + 1)], g[Z][I] = 0, y[O] = ge
                }
            }
            var ae = this.jpoint(null, null, null),
                be = this._wnafT4;
            for (A = E; A >= 0; A--) {
                for (var we = 0; A >= 0;) {
                    var he = !0;
                    for (I = 0; I < i; I++) be[I] = g[I][A] | 0, be[I] !== 0 && (he = !1);
                    if (!he) break;
                    we++, A--
                }
                if (A >= 0 && we++, ae = ae.dblp(we), A < 0) break;
                for (I = 0; I < i; I++) {
                    var gt = be[I];
                    gt !== 0 && (gt > 0 ? q = y[I][gt - 1 >> 1] : gt < 0 && (q = y[I][-gt - 1 >> 1].neg()), q.type === "affine" ? ae = ae.mixedAdd(q) : ae = ae.add(q))
                }
            }
            for (A = 0; A < i; A++) y[A] = null;
            return o ? ae : ae.toP()
        };

        function zn(r, e) {
            this.curve = r, this.type = e, this.precomputed = null
        }
        mo.BasePoint = zn;
        zn.prototype.eq = function() {
            throw new Error("Not implemented")
        };
        zn.prototype.validate = function() {
            return this.curve.validate(this)
        };
        mo.prototype.decodePoint = function(e, t) {
            e = Ua.toArray(e, t);
            var n = this.p.byteLength();
            if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
                e[0] === 6 ? Mc(e[e.length - 1] % 2 === 0) : e[0] === 7 && Mc(e[e.length - 1] % 2 === 1);
                var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
                return i
            } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n) return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
            throw new Error("Unknown point format")
        };
        zn.prototype.encodeCompressed = function(e) {
            return this.encode(e, !0)
        };
        zn.prototype._encode = function(e) {
            var t = this.curve.p.byteLength(),
                n = this.getX().toArray("be", t);
            return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", t))
        };
        zn.prototype.encode = function(e, t) {
            return Ua.encode(this._encode(t), e)
        };
        zn.prototype.precompute = function(e) {
            if (this.precomputed) return this;
            var t = {
                doubles: null,
                naf: null,
                beta: null
            };
            return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this
        };
        zn.prototype._hasDoubles = function(e) {
            if (!this.precomputed) return !1;
            var t = this.precomputed.doubles;
            return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1
        };
        zn.prototype._getDoubles = function(e, t) {
            if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
            for (var n = [this], i = this, o = 0; o < t; o += e) {
                for (var a = 0; a < e; a++) i = i.dbl();
                n.push(i)
            }
            return {
                step: e,
                points: n
            }
        };
        zn.prototype._getNAFPoints = function(e) {
            if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
            for (var t = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), o = 1; o < n; o++) t[o] = t[o - 1].add(i);
            return {
                wnd: e,
                points: t
            }
        };
        zn.prototype._getBeta = function() {
            return null
        };
        zn.prototype.dblp = function(e) {
            for (var t = this, n = 0; n < e; n++) t = t.dbl();
            return t
        }
    });
    var qa = Ue((WL, Z0) => {
        typeof Object.create == "function" ? Z0.exports = function(e, t) {
            t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }))
        } : Z0.exports = function(e, t) {
            if (t) {
                e.super_ = t;
                var n = function() {};
                n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
            }
        }
    });
    var Mx = Ue((HL, Sx) => {
        "use strict";
        var d_ = En(),
            gr = ci(),
            Y0 = qa(),
            zs = Na(),
            p_ = d_.assert;

        function Un(r) {
            zs.call(this, "short", r), this.a = new gr(r.a, 16).toRed(this.red), this.b = new gr(r.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(r), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
        }
        Y0(Un, zs);
        Sx.exports = Un;
        Un.prototype._getEndomorphism = function(e) {
            if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
                var t, n;
                if (e.beta) t = new gr(e.beta, 16).toRed(this.red);
                else {
                    var i = this._getEndoRoots(this.p);
                    t = i[0].cmp(i[1]) < 0 ? i[0] : i[1], t = t.toRed(this.red)
                }
                if (e.lambda) n = new gr(e.lambda, 16);
                else {
                    var o = this._getEndoRoots(this.n);
                    this.g.mul(o[0]).x.cmp(this.g.x.redMul(t)) === 0 ? n = o[0] : (n = o[1], p_(this.g.mul(n).x.cmp(this.g.x.redMul(t)) === 0))
                }
                var a;
                return e.basis ? a = e.basis.map(function(y) {
                    return {
                        a: new gr(y.a, 16),
                        b: new gr(y.b, 16)
                    }
                }) : a = this._getEndoBasis(n), {
                    beta: t,
                    lambda: n,
                    basis: a
                }
            }
        };
        Un.prototype._getEndoRoots = function(e) {
            var t = e === this.p ? this.red : gr.mont(e),
                n = new gr(2).toRed(t).redInvm(),
                i = n.redNeg(),
                o = new gr(3).toRed(t).redNeg().redSqrt().redMul(n),
                a = i.redAdd(o).fromRed(),
                y = i.redSub(o).fromRed();
            return [a, y]
        };
        Un.prototype._getEndoBasis = function(e) {
            for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), o = new gr(1), a = new gr(0), y = new gr(0), g = new gr(1), E, A, I, q, L, O, Z, ge = 0, ce, Xe; n.cmpn(0) !== 0;) {
                var xe = i.div(n);
                ce = i.sub(xe.mul(n)), Xe = y.sub(xe.mul(o));
                var ie = g.sub(xe.mul(a));
                if (!I && ce.cmp(t) < 0) E = Z.neg(), A = o, I = ce.neg(), q = Xe;
                else if (I && ++ge === 2) break;
                Z = ce, i = n, n = ce, y = o, o = Xe, g = a, a = ie
            }
            L = ce.neg(), O = Xe;
            var ae = I.sqr().add(q.sqr()),
                be = L.sqr().add(O.sqr());
            return be.cmp(ae) >= 0 && (L = E, O = A), I.negative && (I = I.neg(), q = q.neg()), L.negative && (L = L.neg(), O = O.neg()), [{
                a: I,
                b: q
            }, {
                a: L,
                b: O
            }]
        };
        Un.prototype._endoSplit = function(e) {
            var t = this.endo.basis,
                n = t[0],
                i = t[1],
                o = i.b.mul(e).divRound(this.n),
                a = n.b.neg().mul(e).divRound(this.n),
                y = o.mul(n.a),
                g = a.mul(i.a),
                E = o.mul(n.b),
                A = a.mul(i.b),
                I = e.sub(y).sub(g),
                q = E.add(A).neg();
            return {
                k1: I,
                k2: q
            }
        };
        Un.prototype.pointFromX = function(e, t) {
            e = new gr(e, 16), e.red || (e = e.toRed(this.red));
            var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
                i = n.redSqrt();
            if (i.redSqr().redSub(n).cmp(this.zero) !== 0) throw new Error("invalid point");
            var o = i.fromRed().isOdd();
            return (t && !o || !t && o) && (i = i.redNeg()), this.point(e, i)
        };
        Un.prototype.validate = function(e) {
            if (e.inf) return !0;
            var t = e.x,
                n = e.y,
                i = this.a.redMul(t),
                o = t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);
            return n.redSqr().redISub(o).cmpn(0) === 0
        };
        Un.prototype._endoWnafMulAdd = function(e, t, n) {
            for (var i = this._endoWnafT1, o = this._endoWnafT2, a = 0; a < e.length; a++) {
                var y = this._endoSplit(t[a]),
                    g = e[a],
                    E = g._getBeta();
                y.k1.negative && (y.k1.ineg(), g = g.neg(!0)), y.k2.negative && (y.k2.ineg(), E = E.neg(!0)), i[a * 2] = g, i[a * 2 + 1] = E, o[a * 2] = y.k1, o[a * 2 + 1] = y.k2
            }
            for (var A = this._wnafMulAdd(1, i, o, a * 2, n), I = 0; I < a * 2; I++) i[I] = null, o[I] = null;
            return A
        };

        function Pr(r, e, t, n) {
            zs.BasePoint.call(this, r, "affine"), e === null && t === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new gr(e, 16), this.y = new gr(t, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
        }
        Y0(Pr, zs.BasePoint);
        Un.prototype.point = function(e, t, n) {
            return new Pr(this, e, t, n)
        };
        Un.prototype.pointFromJSON = function(e, t) {
            return Pr.fromJSON(this, e, t)
        };
        Pr.prototype._getBeta = function() {
            if (!!this.curve.endo) {
                var e = this.precomputed;
                if (e && e.beta) return e.beta;
                var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                if (e) {
                    var n = this.curve,
                        i = function(o) {
                            return n.point(o.x.redMul(n.endo.beta), o.y)
                        };
                    e.beta = t, t.precomputed = {
                        beta: null,
                        naf: e.naf && {
                            wnd: e.naf.wnd,
                            points: e.naf.points.map(i)
                        },
                        doubles: e.doubles && {
                            step: e.doubles.step,
                            points: e.doubles.points.map(i)
                        }
                    }
                }
                return t
            }
        };
        Pr.prototype.toJSON = function() {
            return this.precomputed ? [this.x, this.y, this.precomputed && {
                doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                }
            }] : [this.x, this.y]
        };
        Pr.fromJSON = function(e, t, n) {
            typeof t == "string" && (t = JSON.parse(t));
            var i = e.point(t[0], t[1], n);
            if (!t[2]) return i;

            function o(y) {
                return e.point(y[0], y[1], n)
            }
            var a = t[2];
            return i.precomputed = {
                beta: null,
                doubles: a.doubles && {
                    step: a.doubles.step,
                    points: [i].concat(a.doubles.points.map(o))
                },
                naf: a.naf && {
                    wnd: a.naf.wnd,
                    points: [i].concat(a.naf.points.map(o))
                }
            }, i
        };
        Pr.prototype.inspect = function() {
            return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
        };
        Pr.prototype.isInfinity = function() {
            return this.inf
        };
        Pr.prototype.add = function(e) {
            if (this.inf) return e;
            if (e.inf) return this;
            if (this.eq(e)) return this.dbl();
            if (this.neg().eq(e)) return this.curve.point(null, null);
            if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
            var t = this.y.redSub(e.y);
            t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
            var n = t.redSqr().redISub(this.x).redISub(e.x),
                i = t.redMul(this.x.redSub(n)).redISub(this.y);
            return this.curve.point(n, i)
        };
        Pr.prototype.dbl = function() {
            if (this.inf) return this;
            var e = this.y.redAdd(this.y);
            if (e.cmpn(0) === 0) return this.curve.point(null, null);
            var t = this.curve.a,
                n = this.x.redSqr(),
                i = e.redInvm(),
                o = n.redAdd(n).redIAdd(n).redIAdd(t).redMul(i),
                a = o.redSqr().redISub(this.x.redAdd(this.x)),
                y = o.redMul(this.x.redSub(a)).redISub(this.y);
            return this.curve.point(a, y)
        };
        Pr.prototype.getX = function() {
            return this.x.fromRed()
        };
        Pr.prototype.getY = function() {
            return this.y.fromRed()
        };
        Pr.prototype.mul = function(e) {
            return e = new gr(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
        };
        Pr.prototype.mulAdd = function(e, t, n) {
            var i = [this, t],
                o = [e, n];
            return this.curve.endo ? this.curve._endoWnafMulAdd(i, o) : this.curve._wnafMulAdd(1, i, o, 2)
        };
        Pr.prototype.jmulAdd = function(e, t, n) {
            var i = [this, t],
                o = [e, n];
            return this.curve.endo ? this.curve._endoWnafMulAdd(i, o, !0) : this.curve._wnafMulAdd(1, i, o, 2, !0)
        };
        Pr.prototype.eq = function(e) {
            return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)
        };
        Pr.prototype.neg = function(e) {
            if (this.inf) return this;
            var t = this.curve.point(this.x, this.y.redNeg());
            if (e && this.precomputed) {
                var n = this.precomputed,
                    i = function(o) {
                        return o.neg()
                    };
                t.precomputed = {
                    naf: n.naf && {
                        wnd: n.naf.wnd,
                        points: n.naf.points.map(i)
                    },
                    doubles: n.doubles && {
                        step: n.doubles.step,
                        points: n.doubles.points.map(i)
                    }
                }
            }
            return t
        };
        Pr.prototype.toJ = function() {
            if (this.inf) return this.curve.jpoint(null, null, null);
            var e = this.curve.jpoint(this.x, this.y, this.curve.one);
            return e
        };

        function Dr(r, e, t, n) {
            zs.BasePoint.call(this, r, "jacobian"), e === null && t === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new gr(0)) : (this.x = new gr(e, 16), this.y = new gr(t, 16), this.z = new gr(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
        }
        Y0(Dr, zs.BasePoint);
        Un.prototype.jpoint = function(e, t, n) {
            return new Dr(this, e, t, n)
        };
        Dr.prototype.toP = function() {
            if (this.isInfinity()) return this.curve.point(null, null);
            var e = this.z.redInvm(),
                t = e.redSqr(),
                n = this.x.redMul(t),
                i = this.y.redMul(t).redMul(e);
            return this.curve.point(n, i)
        };
        Dr.prototype.neg = function() {
            return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
        };
        Dr.prototype.add = function(e) {
            if (this.isInfinity()) return e;
            if (e.isInfinity()) return this;
            var t = e.z.redSqr(),
                n = this.z.redSqr(),
                i = this.x.redMul(t),
                o = e.x.redMul(n),
                a = this.y.redMul(t.redMul(e.z)),
                y = e.y.redMul(n.redMul(this.z)),
                g = i.redSub(o),
                E = a.redSub(y);
            if (g.cmpn(0) === 0) return E.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
            var A = g.redSqr(),
                I = A.redMul(g),
                q = i.redMul(A),
                L = E.redSqr().redIAdd(I).redISub(q).redISub(q),
                O = E.redMul(q.redISub(L)).redISub(a.redMul(I)),
                Z = this.z.redMul(e.z).redMul(g);
            return this.curve.jpoint(L, O, Z)
        };
        Dr.prototype.mixedAdd = function(e) {
            if (this.isInfinity()) return e.toJ();
            if (e.isInfinity()) return this;
            var t = this.z.redSqr(),
                n = this.x,
                i = e.x.redMul(t),
                o = this.y,
                a = e.y.redMul(t).redMul(this.z),
                y = n.redSub(i),
                g = o.redSub(a);
            if (y.cmpn(0) === 0) return g.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
            var E = y.redSqr(),
                A = E.redMul(y),
                I = n.redMul(E),
                q = g.redSqr().redIAdd(A).redISub(I).redISub(I),
                L = g.redMul(I.redISub(q)).redISub(o.redMul(A)),
                O = this.z.redMul(y);
            return this.curve.jpoint(q, L, O)
        };
        Dr.prototype.dblp = function(e) {
            if (e === 0) return this;
            if (this.isInfinity()) return this;
            if (!e) return this.dbl();
            var t;
            if (this.curve.zeroA || this.curve.threeA) {
                var n = this;
                for (t = 0; t < e; t++) n = n.dbl();
                return n
            }
            var i = this.curve.a,
                o = this.curve.tinv,
                a = this.x,
                y = this.y,
                g = this.z,
                E = g.redSqr().redSqr(),
                A = y.redAdd(y);
            for (t = 0; t < e; t++) {
                var I = a.redSqr(),
                    q = A.redSqr(),
                    L = q.redSqr(),
                    O = I.redAdd(I).redIAdd(I).redIAdd(i.redMul(E)),
                    Z = a.redMul(q),
                    ge = O.redSqr().redISub(Z.redAdd(Z)),
                    ce = Z.redISub(ge),
                    Xe = O.redMul(ce);
                Xe = Xe.redIAdd(Xe).redISub(L);
                var xe = A.redMul(g);
                t + 1 < e && (E = E.redMul(L)), a = ge, g = xe, A = Xe
            }
            return this.curve.jpoint(a, A.redMul(o), g)
        };
        Dr.prototype.dbl = function() {
            return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
        };
        Dr.prototype._zeroDbl = function() {
            var e, t, n;
            if (this.zOne) {
                var i = this.x.redSqr(),
                    o = this.y.redSqr(),
                    a = o.redSqr(),
                    y = this.x.redAdd(o).redSqr().redISub(i).redISub(a);
                y = y.redIAdd(y);
                var g = i.redAdd(i).redIAdd(i),
                    E = g.redSqr().redISub(y).redISub(y),
                    A = a.redIAdd(a);
                A = A.redIAdd(A), A = A.redIAdd(A), e = E, t = g.redMul(y.redISub(E)).redISub(A), n = this.y.redAdd(this.y)
            } else {
                var I = this.x.redSqr(),
                    q = this.y.redSqr(),
                    L = q.redSqr(),
                    O = this.x.redAdd(q).redSqr().redISub(I).redISub(L);
                O = O.redIAdd(O);
                var Z = I.redAdd(I).redIAdd(I),
                    ge = Z.redSqr(),
                    ce = L.redIAdd(L);
                ce = ce.redIAdd(ce), ce = ce.redIAdd(ce), e = ge.redISub(O).redISub(O), t = Z.redMul(O.redISub(e)).redISub(ce), n = this.y.redMul(this.z), n = n.redIAdd(n)
            }
            return this.curve.jpoint(e, t, n)
        };
        Dr.prototype._threeDbl = function() {
            var e, t, n;
            if (this.zOne) {
                var i = this.x.redSqr(),
                    o = this.y.redSqr(),
                    a = o.redSqr(),
                    y = this.x.redAdd(o).redSqr().redISub(i).redISub(a);
                y = y.redIAdd(y);
                var g = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
                    E = g.redSqr().redISub(y).redISub(y);
                e = E;
                var A = a.redIAdd(a);
                A = A.redIAdd(A), A = A.redIAdd(A), t = g.redMul(y.redISub(E)).redISub(A), n = this.y.redAdd(this.y)
            } else {
                var I = this.z.redSqr(),
                    q = this.y.redSqr(),
                    L = this.x.redMul(q),
                    O = this.x.redSub(I).redMul(this.x.redAdd(I));
                O = O.redAdd(O).redIAdd(O);
                var Z = L.redIAdd(L);
                Z = Z.redIAdd(Z);
                var ge = Z.redAdd(Z);
                e = O.redSqr().redISub(ge), n = this.y.redAdd(this.z).redSqr().redISub(q).redISub(I);
                var ce = q.redSqr();
                ce = ce.redIAdd(ce), ce = ce.redIAdd(ce), ce = ce.redIAdd(ce), t = O.redMul(Z.redISub(e)).redISub(ce)
            }
            return this.curve.jpoint(e, t, n)
        };
        Dr.prototype._dbl = function() {
            var e = this.curve.a,
                t = this.x,
                n = this.y,
                i = this.z,
                o = i.redSqr().redSqr(),
                a = t.redSqr(),
                y = n.redSqr(),
                g = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(o)),
                E = t.redAdd(t);
            E = E.redIAdd(E);
            var A = E.redMul(y),
                I = g.redSqr().redISub(A.redAdd(A)),
                q = A.redISub(I),
                L = y.redSqr();
            L = L.redIAdd(L), L = L.redIAdd(L), L = L.redIAdd(L);
            var O = g.redMul(q).redISub(L),
                Z = n.redAdd(n).redMul(i);
            return this.curve.jpoint(I, O, Z)
        };
        Dr.prototype.trpl = function() {
            if (!this.curve.zeroA) return this.dbl().add(this);
            var e = this.x.redSqr(),
                t = this.y.redSqr(),
                n = this.z.redSqr(),
                i = t.redSqr(),
                o = e.redAdd(e).redIAdd(e),
                a = o.redSqr(),
                y = this.x.redAdd(t).redSqr().redISub(e).redISub(i);
            y = y.redIAdd(y), y = y.redAdd(y).redIAdd(y), y = y.redISub(a);
            var g = y.redSqr(),
                E = i.redIAdd(i);
            E = E.redIAdd(E), E = E.redIAdd(E), E = E.redIAdd(E);
            var A = o.redIAdd(y).redSqr().redISub(a).redISub(g).redISub(E),
                I = t.redMul(A);
            I = I.redIAdd(I), I = I.redIAdd(I);
            var q = this.x.redMul(g).redISub(I);
            q = q.redIAdd(q), q = q.redIAdd(q);
            var L = this.y.redMul(A.redMul(E.redISub(A)).redISub(y.redMul(g)));
            L = L.redIAdd(L), L = L.redIAdd(L), L = L.redIAdd(L);
            var O = this.z.redAdd(y).redSqr().redISub(n).redISub(g);
            return this.curve.jpoint(q, L, O)
        };
        Dr.prototype.mul = function(e, t) {
            return e = new gr(e, t), this.curve._wnafMul(this, e)
        };
        Dr.prototype.eq = function(e) {
            if (e.type === "affine") return this.eq(e.toJ());
            if (this === e) return !0;
            var t = this.z.redSqr(),
                n = e.z.redSqr();
            if (this.x.redMul(n).redISub(e.x.redMul(t)).cmpn(0) !== 0) return !1;
            var i = t.redMul(this.z),
                o = n.redMul(e.z);
            return this.y.redMul(o).redISub(e.y.redMul(i)).cmpn(0) === 0
        };
        Dr.prototype.eqXToP = function(e) {
            var t = this.z.redSqr(),
                n = e.toRed(this.curve.red).redMul(t);
            if (this.x.cmp(n) === 0) return !0;
            for (var i = e.clone(), o = this.curve.redN.redMul(t);;) {
                if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1;
                if (n.redIAdd(o), this.x.cmp(n) === 0) return !0
            }
        };
        Dr.prototype.inspect = function() {
            return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
        };
        Dr.prototype.isInfinity = function() {
            return this.z.cmpn(0) === 0
        }
    });
    var Bx = Ue((VL, Ix) => {
        "use strict";
        var Us = ci(),
            Ax = qa(),
            Ac = Na(),
            y_ = En();

        function Ns(r) {
            Ac.call(this, "mont", r), this.a = new Us(r.a, 16).toRed(this.red), this.b = new Us(r.b, 16).toRed(this.red), this.i4 = new Us(4).toRed(this.red).redInvm(), this.two = new Us(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two))
        }
        Ax(Ns, Ac);
        Ix.exports = Ns;
        Ns.prototype.validate = function(e) {
            var t = e.normalize().x,
                n = t.redSqr(),
                i = n.redMul(t).redAdd(n.redMul(this.a)).redAdd(t),
                o = i.redSqrt();
            return o.redSqr().cmp(i) === 0
        };

        function Tr(r, e, t) {
            Ac.BasePoint.call(this, r, "projective"), e === null && t === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Us(e, 16), this.z = new Us(t, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)))
        }
        Ax(Tr, Ac.BasePoint);
        Ns.prototype.decodePoint = function(e, t) {
            return this.point(y_.toArray(e, t), 1)
        };
        Ns.prototype.point = function(e, t) {
            return new Tr(this, e, t)
        };
        Ns.prototype.pointFromJSON = function(e) {
            return Tr.fromJSON(this, e)
        };
        Tr.prototype.precompute = function() {};
        Tr.prototype._encode = function() {
            return this.getX().toArray("be", this.curve.p.byteLength())
        };
        Tr.fromJSON = function(e, t) {
            return new Tr(e, t[0], t[1] || e.one)
        };
        Tr.prototype.inspect = function() {
            return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
        };
        Tr.prototype.isInfinity = function() {
            return this.z.cmpn(0) === 0
        };
        Tr.prototype.dbl = function() {
            var e = this.x.redAdd(this.z),
                t = e.redSqr(),
                n = this.x.redSub(this.z),
                i = n.redSqr(),
                o = t.redSub(i),
                a = t.redMul(i),
                y = o.redMul(i.redAdd(this.curve.a24.redMul(o)));
            return this.curve.point(a, y)
        };
        Tr.prototype.add = function() {
            throw new Error("Not supported on Montgomery curve")
        };
        Tr.prototype.diffAdd = function(e, t) {
            var n = this.x.redAdd(this.z),
                i = this.x.redSub(this.z),
                o = e.x.redAdd(e.z),
                a = e.x.redSub(e.z),
                y = a.redMul(n),
                g = o.redMul(i),
                E = t.z.redMul(y.redAdd(g).redSqr()),
                A = t.x.redMul(y.redISub(g).redSqr());
            return this.curve.point(E, A)
        };
        Tr.prototype.mul = function(e) {
            for (var t = e.clone(), n = this, i = this.curve.point(null, null), o = this, a = []; t.cmpn(0) !== 0; t.iushrn(1)) a.push(t.andln(1));
            for (var y = a.length - 1; y >= 0; y--) a[y] === 0 ? (n = n.diffAdd(i, o), i = i.dbl()) : (i = n.diffAdd(i, o), n = n.dbl());
            return i
        };
        Tr.prototype.mulAdd = function() {
            throw new Error("Not supported on Montgomery curve")
        };
        Tr.prototype.jumlAdd = function() {
            throw new Error("Not supported on Montgomery curve")
        };
        Tr.prototype.eq = function(e) {
            return this.getX().cmp(e.getX()) === 0
        };
        Tr.prototype.normalize = function() {
            return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this
        };
        Tr.prototype.getX = function() {
            return this.normalize(), this.x.fromRed()
        }
    });
    var Px = Ue((GL, kx) => {
        "use strict";
        var m_ = En(),
            $i = ci(),
            Rx = qa(),
            Ic = Na(),
            g_ = m_.assert;

        function hi(r) {
            this.twisted = (r.a | 0) !== 1, this.mOneA = this.twisted && (r.a | 0) === -1, this.extended = this.mOneA, Ic.call(this, "edwards", r), this.a = new $i(r.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new $i(r.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new $i(r.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), g_(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (r.c | 0) === 1
        }
        Rx(hi, Ic);
        kx.exports = hi;
        hi.prototype._mulA = function(e) {
            return this.mOneA ? e.redNeg() : this.a.redMul(e)
        };
        hi.prototype._mulC = function(e) {
            return this.oneC ? e : this.c.redMul(e)
        };
        hi.prototype.jpoint = function(e, t, n, i) {
            return this.point(e, t, n, i)
        };
        hi.prototype.pointFromX = function(e, t) {
            e = new $i(e, 16), e.red || (e = e.toRed(this.red));
            var n = e.redSqr(),
                i = this.c2.redSub(this.a.redMul(n)),
                o = this.one.redSub(this.c2.redMul(this.d).redMul(n)),
                a = i.redMul(o.redInvm()),
                y = a.redSqrt();
            if (y.redSqr().redSub(a).cmp(this.zero) !== 0) throw new Error("invalid point");
            var g = y.fromRed().isOdd();
            return (t && !g || !t && g) && (y = y.redNeg()), this.point(e, y)
        };
        hi.prototype.pointFromY = function(e, t) {
            e = new $i(e, 16), e.red || (e = e.toRed(this.red));
            var n = e.redSqr(),
                i = n.redSub(this.c2),
                o = n.redMul(this.d).redMul(this.c2).redSub(this.a),
                a = i.redMul(o.redInvm());
            if (a.cmp(this.zero) === 0) {
                if (t) throw new Error("invalid point");
                return this.point(this.zero, e)
            }
            var y = a.redSqrt();
            if (y.redSqr().redSub(a).cmp(this.zero) !== 0) throw new Error("invalid point");
            return y.fromRed().isOdd() !== t && (y = y.redNeg()), this.point(y, e)
        };
        hi.prototype.validate = function(e) {
            if (e.isInfinity()) return !0;
            e.normalize();
            var t = e.x.redSqr(),
                n = e.y.redSqr(),
                i = t.redMul(this.a).redAdd(n),
                o = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(n)));
            return i.cmp(o) === 0
        };

        function ur(r, e, t, n, i) {
            Ic.BasePoint.call(this, r, "projective"), e === null && t === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new $i(e, 16), this.y = new $i(t, 16), this.z = n ? new $i(n, 16) : this.curve.one, this.t = i && new $i(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
        }
        Rx(ur, Ic.BasePoint);
        hi.prototype.pointFromJSON = function(e) {
            return ur.fromJSON(this, e)
        };
        hi.prototype.point = function(e, t, n, i) {
            return new ur(this, e, t, n, i)
        };
        ur.fromJSON = function(e, t) {
            return new ur(e, t[0], t[1], t[2])
        };
        ur.prototype.inspect = function() {
            return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
        };
        ur.prototype.isInfinity = function() {
            return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0)
        };
        ur.prototype._extDbl = function() {
            var e = this.x.redSqr(),
                t = this.y.redSqr(),
                n = this.z.redSqr();
            n = n.redIAdd(n);
            var i = this.curve._mulA(e),
                o = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),
                a = i.redAdd(t),
                y = a.redSub(n),
                g = i.redSub(t),
                E = o.redMul(y),
                A = a.redMul(g),
                I = o.redMul(g),
                q = y.redMul(a);
            return this.curve.point(E, A, q, I)
        };
        ur.prototype._projDbl = function() {
            var e = this.x.redAdd(this.y).redSqr(),
                t = this.x.redSqr(),
                n = this.y.redSqr(),
                i, o, a, y, g, E;
            if (this.curve.twisted) {
                y = this.curve._mulA(t);
                var A = y.redAdd(n);
                this.zOne ? (i = e.redSub(t).redSub(n).redMul(A.redSub(this.curve.two)), o = A.redMul(y.redSub(n)), a = A.redSqr().redSub(A).redSub(A)) : (g = this.z.redSqr(), E = A.redSub(g).redISub(g), i = e.redSub(t).redISub(n).redMul(E), o = A.redMul(y.redSub(n)), a = A.redMul(E))
            } else y = t.redAdd(n), g = this.curve._mulC(this.z).redSqr(), E = y.redSub(g).redSub(g), i = this.curve._mulC(e.redISub(y)).redMul(E), o = this.curve._mulC(y).redMul(t.redISub(n)), a = y.redMul(E);
            return this.curve.point(i, o, a)
        };
        ur.prototype.dbl = function() {
            return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
        };
        ur.prototype._extAdd = function(e) {
            var t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)),
                n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),
                i = this.t.redMul(this.curve.dd).redMul(e.t),
                o = this.z.redMul(e.z.redAdd(e.z)),
                a = n.redSub(t),
                y = o.redSub(i),
                g = o.redAdd(i),
                E = n.redAdd(t),
                A = a.redMul(y),
                I = g.redMul(E),
                q = a.redMul(E),
                L = y.redMul(g);
            return this.curve.point(A, I, L, q)
        };
        ur.prototype._projAdd = function(e) {
            var t = this.z.redMul(e.z),
                n = t.redSqr(),
                i = this.x.redMul(e.x),
                o = this.y.redMul(e.y),
                a = this.curve.d.redMul(i).redMul(o),
                y = n.redSub(a),
                g = n.redAdd(a),
                E = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(o),
                A = t.redMul(y).redMul(E),
                I, q;
            return this.curve.twisted ? (I = t.redMul(g).redMul(o.redSub(this.curve._mulA(i))), q = y.redMul(g)) : (I = t.redMul(g).redMul(o.redSub(i)), q = this.curve._mulC(y).redMul(g)), this.curve.point(A, I, q)
        };
        ur.prototype.add = function(e) {
            return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e)
        };
        ur.prototype.mul = function(e) {
            return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e)
        };
        ur.prototype.mulAdd = function(e, t, n) {
            return this.curve._wnafMulAdd(1, [this, t], [e, n], 2, !1)
        };
        ur.prototype.jmulAdd = function(e, t, n) {
            return this.curve._wnafMulAdd(1, [this, t], [e, n], 2, !0)
        };
        ur.prototype.normalize = function() {
            if (this.zOne) return this;
            var e = this.z.redInvm();
            return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this
        };
        ur.prototype.neg = function() {
            return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
        };
        ur.prototype.getX = function() {
            return this.normalize(), this.x.fromRed()
        };
        ur.prototype.getY = function() {
            return this.normalize(), this.y.fromRed()
        };
        ur.prototype.eq = function(e) {
            return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0
        };
        ur.prototype.eqXToP = function(e) {
            var t = e.toRed(this.curve.red).redMul(this.z);
            if (this.x.cmp(t) === 0) return !0;
            for (var n = e.clone(), i = this.curve.redN.redMul(this.z);;) {
                if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0) return !1;
                if (t.redIAdd(i), this.x.cmp(t) === 0) return !0
            }
        };
        ur.prototype.toP = ur.prototype.normalize;
        ur.prototype.mixedAdd = ur.prototype.add
    });
    var J0 = Ue(Tx => {
        "use strict";
        var Bc = Tx;
        Bc.base = Na();
        Bc.short = Mx();
        Bc.mont = Bx();
        Bc.edwards = Px()
    });
    var Hn = Ue(ir => {
        "use strict";
        var b_ = po(),
            x_ = qa();
        ir.inherits = x_;

        function v_(r, e) {
            return (r.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= r.length ? !1 : (r.charCodeAt(e + 1) & 64512) === 56320
        }

        function w_(r, e) {
            if (Array.isArray(r)) return r.slice();
            if (!r) return [];
            var t = [];
            if (typeof r == "string")
                if (e) {
                    if (e === "hex")
                        for (r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 !== 0 && (r = "0" + r), i = 0; i < r.length; i += 2) t.push(parseInt(r[i] + r[i + 1], 16))
                } else
                    for (var n = 0, i = 0; i < r.length; i++) {
                        var o = r.charCodeAt(i);
                        o < 128 ? t[n++] = o : o < 2048 ? (t[n++] = o >> 6 | 192, t[n++] = o & 63 | 128) : v_(r, i) ? (o = 65536 + ((o & 1023) << 10) + (r.charCodeAt(++i) & 1023), t[n++] = o >> 18 | 240, t[n++] = o >> 12 & 63 | 128, t[n++] = o >> 6 & 63 | 128, t[n++] = o & 63 | 128) : (t[n++] = o >> 12 | 224, t[n++] = o >> 6 & 63 | 128, t[n++] = o & 63 | 128)
                    } else
                        for (i = 0; i < r.length; i++) t[i] = r[i] | 0;
            return t
        }
        ir.toArray = w_;

        function __(r) {
            for (var e = "", t = 0; t < r.length; t++) e += zx(r[t].toString(16));
            return e
        }
        ir.toHex = __;

        function Lx(r) {
            var e = r >>> 24 | r >>> 8 & 65280 | r << 8 & 16711680 | (r & 255) << 24;
            return e >>> 0
        }
        ir.htonl = Lx;

        function E_(r, e) {
            for (var t = "", n = 0; n < r.length; n++) {
                var i = r[n];
                e === "little" && (i = Lx(i)), t += Ux(i.toString(16))
            }
            return t
        }
        ir.toHex32 = E_;

        function zx(r) {
            return r.length === 1 ? "0" + r : r
        }
        ir.zero2 = zx;

        function Ux(r) {
            return r.length === 7 ? "0" + r : r.length === 6 ? "00" + r : r.length === 5 ? "000" + r : r.length === 4 ? "0000" + r : r.length === 3 ? "00000" + r : r.length === 2 ? "000000" + r : r.length === 1 ? "0000000" + r : r
        }
        ir.zero8 = Ux;

        function S_(r, e, t, n) {
            var i = t - e;
            b_(i % 4 === 0);
            for (var o = new Array(i / 4), a = 0, y = e; a < o.length; a++, y += 4) {
                var g;
                n === "big" ? g = r[y] << 24 | r[y + 1] << 16 | r[y + 2] << 8 | r[y + 3] : g = r[y + 3] << 24 | r[y + 2] << 16 | r[y + 1] << 8 | r[y], o[a] = g >>> 0
            }
            return o
        }
        ir.join32 = S_;

        function M_(r, e) {
            for (var t = new Array(r.length * 4), n = 0, i = 0; n < r.length; n++, i += 4) {
                var o = r[n];
                e === "big" ? (t[i] = o >>> 24, t[i + 1] = o >>> 16 & 255, t[i + 2] = o >>> 8 & 255, t[i + 3] = o & 255) : (t[i + 3] = o >>> 24, t[i + 2] = o >>> 16 & 255, t[i + 1] = o >>> 8 & 255, t[i] = o & 255)
            }
            return t
        }
        ir.split32 = M_;

        function A_(r, e) {
            return r >>> e | r << 32 - e
        }
        ir.rotr32 = A_;

        function I_(r, e) {
            return r << e | r >>> 32 - e
        }
        ir.rotl32 = I_;

        function B_(r, e) {
            return r + e >>> 0
        }
        ir.sum32 = B_;

        function R_(r, e, t) {
            return r + e + t >>> 0
        }
        ir.sum32_3 = R_;

        function k_(r, e, t, n) {
            return r + e + t + n >>> 0
        }
        ir.sum32_4 = k_;

        function P_(r, e, t, n, i) {
            return r + e + t + n + i >>> 0
        }
        ir.sum32_5 = P_;

        function T_(r, e, t, n) {
            var i = r[e],
                o = r[e + 1],
                a = n + o >>> 0,
                y = (a < n ? 1 : 0) + t + i;
            r[e] = y >>> 0, r[e + 1] = a
        }
        ir.sum64 = T_;

        function L_(r, e, t, n) {
            var i = e + n >>> 0,
                o = (i < e ? 1 : 0) + r + t;
            return o >>> 0
        }
        ir.sum64_hi = L_;

        function z_(r, e, t, n) {
            var i = e + n;
            return i >>> 0
        }
        ir.sum64_lo = z_;

        function U_(r, e, t, n, i, o, a, y) {
            var g = 0,
                E = e;
            E = E + n >>> 0, g += E < e ? 1 : 0, E = E + o >>> 0, g += E < o ? 1 : 0, E = E + y >>> 0, g += E < y ? 1 : 0;
            var A = r + t + i + a + g;
            return A >>> 0
        }
        ir.sum64_4_hi = U_;

        function N_(r, e, t, n, i, o, a, y) {
            var g = e + n + o + y;
            return g >>> 0
        }
        ir.sum64_4_lo = N_;

        function q_(r, e, t, n, i, o, a, y, g, E) {
            var A = 0,
                I = e;
            I = I + n >>> 0, A += I < e ? 1 : 0, I = I + o >>> 0, A += I < o ? 1 : 0, I = I + y >>> 0, A += I < y ? 1 : 0, I = I + E >>> 0, A += I < E ? 1 : 0;
            var q = r + t + i + a + g + A;
            return q >>> 0
        }
        ir.sum64_5_hi = q_;

        function F_(r, e, t, n, i, o, a, y, g, E) {
            var A = e + n + o + y + E;
            return A >>> 0
        }
        ir.sum64_5_lo = F_;

        function C_(r, e, t) {
            var n = e << 32 - t | r >>> t;
            return n >>> 0
        }
        ir.rotr64_hi = C_;

        function O_(r, e, t) {
            var n = r << 32 - t | e >>> t;
            return n >>> 0
        }
        ir.rotr64_lo = O_;

        function D_(r, e, t) {
            return r >>> t
        }
        ir.shr64_hi = D_;

        function K_(r, e, t) {
            var n = r << 32 - t | e >>> t;
            return n >>> 0
        }
        ir.shr64_lo = K_
    });
    var qs = Ue(qx => {
        "use strict";
        var Nx = Hn(),
            $_ = po();

        function Rc() {
            this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
        }
        qx.BlockHash = Rc;
        Rc.prototype.update = function(e, t) {
            if (e = Nx.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
                e = this.pending;
                var n = e.length % this._delta8;
                this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = Nx.join32(e, 0, e.length - n, this.endian);
                for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
            }
            return this
        };
        Rc.prototype.digest = function(e) {
            return this.update(this._pad()), $_(this.pending === null), this._digest(e)
        };
        Rc.prototype._pad = function() {
            var e = this.pendingTotal,
                t = this._delta8,
                n = t - (e + this.padLength) % t,
                i = new Array(n + this.padLength);
            i[0] = 128;
            for (var o = 1; o < n; o++) i[o] = 0;
            if (e <<= 3, this.endian === "big") {
                for (var a = 8; a < this.padLength; a++) i[o++] = 0;
                i[o++] = 0, i[o++] = 0, i[o++] = 0, i[o++] = 0, i[o++] = e >>> 24 & 255, i[o++] = e >>> 16 & 255, i[o++] = e >>> 8 & 255, i[o++] = e & 255
            } else
                for (i[o++] = e & 255, i[o++] = e >>> 8 & 255, i[o++] = e >>> 16 & 255, i[o++] = e >>> 24 & 255, i[o++] = 0, i[o++] = 0, i[o++] = 0, i[o++] = 0, a = 8; a < this.padLength; a++) i[o++] = 0;
            return i
        }
    });
    var X0 = Ue(ji => {
        "use strict";
        var j_ = Hn(),
            li = j_.rotr32;

        function W_(r, e, t, n) {
            if (r === 0) return Fx(e, t, n);
            if (r === 1 || r === 3) return Ox(e, t, n);
            if (r === 2) return Cx(e, t, n)
        }
        ji.ft_1 = W_;

        function Fx(r, e, t) {
            return r & e ^ ~r & t
        }
        ji.ch32 = Fx;

        function Cx(r, e, t) {
            return r & e ^ r & t ^ e & t
        }
        ji.maj32 = Cx;

        function Ox(r, e, t) {
            return r ^ e ^ t
        }
        ji.p32 = Ox;

        function H_(r) {
            return li(r, 2) ^ li(r, 13) ^ li(r, 22)
        }
        ji.s0_256 = H_;

        function V_(r) {
            return li(r, 6) ^ li(r, 11) ^ li(r, 25)
        }
        ji.s1_256 = V_;

        function G_(r) {
            return li(r, 7) ^ li(r, 18) ^ r >>> 3
        }
        ji.g0_256 = G_;

        function Z_(r) {
            return li(r, 17) ^ li(r, 19) ^ r >>> 10
        }
        ji.g1_256 = Z_
    });
    var $x = Ue((QL, Kx) => {
        "use strict";
        var Fs = Hn(),
            Y_ = qs(),
            J_ = X0(),
            Q0 = Fs.rotl32,
            Fa = Fs.sum32,
            X_ = Fs.sum32_5,
            Q_ = J_.ft_1,
            Dx = Y_.BlockHash,
            e9 = [1518500249, 1859775393, 2400959708, 3395469782];

        function di() {
            if (!(this instanceof di)) return new di;
            Dx.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
        }
        Fs.inherits(di, Dx);
        Kx.exports = di;
        di.blockSize = 512;
        di.outSize = 160;
        di.hmacStrength = 80;
        di.padLength = 64;
        di.prototype._update = function(e, t) {
            for (var n = this.W, i = 0; i < 16; i++) n[i] = e[t + i];
            for (; i < n.length; i++) n[i] = Q0(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
            var o = this.h[0],
                a = this.h[1],
                y = this.h[2],
                g = this.h[3],
                E = this.h[4];
            for (i = 0; i < n.length; i++) {
                var A = ~~(i / 20),
                    I = X_(Q0(o, 5), Q_(A, a, y, g), E, n[i], e9[A]);
                E = g, g = y, y = Q0(a, 30), a = o, o = I
            }
            this.h[0] = Fa(this.h[0], o), this.h[1] = Fa(this.h[1], a), this.h[2] = Fa(this.h[2], y), this.h[3] = Fa(this.h[3], g), this.h[4] = Fa(this.h[4], E)
        };
        di.prototype._digest = function(e) {
            return e === "hex" ? Fs.toHex32(this.h, "big") : Fs.split32(this.h, "big")
        }
    });
    var el = Ue((ez, Wx) => {
        "use strict";
        var Cs = Hn(),
            t9 = qs(),
            Os = X0(),
            r9 = po(),
            Vn = Cs.sum32,
            n9 = Cs.sum32_4,
            i9 = Cs.sum32_5,
            o9 = Os.ch32,
            s9 = Os.maj32,
            a9 = Os.s0_256,
            f9 = Os.s1_256,
            u9 = Os.g0_256,
            c9 = Os.g1_256,
            jx = t9.BlockHash,
            h9 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

        function pi() {
            if (!(this instanceof pi)) return new pi;
            jx.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = h9, this.W = new Array(64)
        }
        Cs.inherits(pi, jx);
        Wx.exports = pi;
        pi.blockSize = 512;
        pi.outSize = 256;
        pi.hmacStrength = 192;
        pi.padLength = 64;
        pi.prototype._update = function(e, t) {
            for (var n = this.W, i = 0; i < 16; i++) n[i] = e[t + i];
            for (; i < n.length; i++) n[i] = n9(c9(n[i - 2]), n[i - 7], u9(n[i - 15]), n[i - 16]);
            var o = this.h[0],
                a = this.h[1],
                y = this.h[2],
                g = this.h[3],
                E = this.h[4],
                A = this.h[5],
                I = this.h[6],
                q = this.h[7];
            for (r9(this.k.length === n.length), i = 0; i < n.length; i++) {
                var L = i9(q, f9(E), o9(E, A, I), this.k[i], n[i]),
                    O = Vn(a9(o), s9(o, a, y));
                q = I, I = A, A = E, E = Vn(g, L), g = y, y = a, a = o, o = Vn(L, O)
            }
            this.h[0] = Vn(this.h[0], o), this.h[1] = Vn(this.h[1], a), this.h[2] = Vn(this.h[2], y), this.h[3] = Vn(this.h[3], g), this.h[4] = Vn(this.h[4], E), this.h[5] = Vn(this.h[5], A), this.h[6] = Vn(this.h[6], I), this.h[7] = Vn(this.h[7], q)
        };
        pi.prototype._digest = function(e) {
            return e === "hex" ? Cs.toHex32(this.h, "big") : Cs.split32(this.h, "big")
        }
    });
    var Gx = Ue((tz, Vx) => {
        "use strict";
        var tl = Hn(),
            Hx = el();

        function Wi() {
            if (!(this instanceof Wi)) return new Wi;
            Hx.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
        }
        tl.inherits(Wi, Hx);
        Vx.exports = Wi;
        Wi.blockSize = 512;
        Wi.outSize = 224;
        Wi.hmacStrength = 192;
        Wi.padLength = 64;
        Wi.prototype._digest = function(e) {
            return e === "hex" ? tl.toHex32(this.h.slice(0, 7), "big") : tl.split32(this.h.slice(0, 7), "big")
        }
    });
    var il = Ue((rz, Xx) => {
        "use strict";
        var mn = Hn(),
            l9 = qs(),
            d9 = po(),
            yi = mn.rotr64_hi,
            mi = mn.rotr64_lo,
            Zx = mn.shr64_hi,
            Yx = mn.shr64_lo,
            go = mn.sum64,
            rl = mn.sum64_hi,
            nl = mn.sum64_lo,
            p9 = mn.sum64_4_hi,
            y9 = mn.sum64_4_lo,
            m9 = mn.sum64_5_hi,
            g9 = mn.sum64_5_lo,
            Jx = l9.BlockHash,
            b9 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

        function Gn() {
            if (!(this instanceof Gn)) return new Gn;
            Jx.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = b9, this.W = new Array(160)
        }
        mn.inherits(Gn, Jx);
        Xx.exports = Gn;
        Gn.blockSize = 1024;
        Gn.outSize = 512;
        Gn.hmacStrength = 192;
        Gn.padLength = 128;
        Gn.prototype._prepareBlock = function(e, t) {
            for (var n = this.W, i = 0; i < 32; i++) n[i] = e[t + i];
            for (; i < n.length; i += 2) {
                var o = R9(n[i - 4], n[i - 3]),
                    a = k9(n[i - 4], n[i - 3]),
                    y = n[i - 14],
                    g = n[i - 13],
                    E = I9(n[i - 30], n[i - 29]),
                    A = B9(n[i - 30], n[i - 29]),
                    I = n[i - 32],
                    q = n[i - 31];
                n[i] = p9(o, a, y, g, E, A, I, q), n[i + 1] = y9(o, a, y, g, E, A, I, q)
            }
        };
        Gn.prototype._update = function(e, t) {
            this._prepareBlock(e, t);
            var n = this.W,
                i = this.h[0],
                o = this.h[1],
                a = this.h[2],
                y = this.h[3],
                g = this.h[4],
                E = this.h[5],
                A = this.h[6],
                I = this.h[7],
                q = this.h[8],
                L = this.h[9],
                O = this.h[10],
                Z = this.h[11],
                ge = this.h[12],
                ce = this.h[13],
                Xe = this.h[14],
                xe = this.h[15];
            d9(this.k.length === n.length);
            for (var ie = 0; ie < n.length; ie += 2) {
                var ae = Xe,
                    be = xe,
                    we = M9(q, L),
                    he = A9(q, L),
                    gt = x9(q, L, O, Z, ge, ce),
                    T = v9(q, L, O, Z, ge, ce),
                    m = this.k[ie],
                    w = this.k[ie + 1],
                    l = n[ie],
                    s = n[ie + 1],
                    f = m9(ae, be, we, he, gt, T, m, w, l, s),
                    h = g9(ae, be, we, he, gt, T, m, w, l, s);
                ae = E9(i, o), be = S9(i, o), we = w9(i, o, a, y, g, E), he = _9(i, o, a, y, g, E);
                var p = rl(ae, be, we, he),
                    d = nl(ae, be, we, he);
                Xe = ge, xe = ce, ge = O, ce = Z, O = q, Z = L, q = rl(A, I, f, h), L = nl(I, I, f, h), A = g, I = E, g = a, E = y, a = i, y = o, i = rl(f, h, p, d), o = nl(f, h, p, d)
            }
            go(this.h, 0, i, o), go(this.h, 2, a, y), go(this.h, 4, g, E), go(this.h, 6, A, I), go(this.h, 8, q, L), go(this.h, 10, O, Z), go(this.h, 12, ge, ce), go(this.h, 14, Xe, xe)
        };
        Gn.prototype._digest = function(e) {
            return e === "hex" ? mn.toHex32(this.h, "big") : mn.split32(this.h, "big")
        };

        function x9(r, e, t, n, i) {
            var o = r & t ^ ~r & i;
            return o < 0 && (o += 4294967296), o
        }

        function v9(r, e, t, n, i, o) {
            var a = e & n ^ ~e & o;
            return a < 0 && (a += 4294967296), a
        }

        function w9(r, e, t, n, i) {
            var o = r & t ^ r & i ^ t & i;
            return o < 0 && (o += 4294967296), o
        }

        function _9(r, e, t, n, i, o) {
            var a = e & n ^ e & o ^ n & o;
            return a < 0 && (a += 4294967296), a
        }

        function E9(r, e) {
            var t = yi(r, e, 28),
                n = yi(e, r, 2),
                i = yi(e, r, 7),
                o = t ^ n ^ i;
            return o < 0 && (o += 4294967296), o
        }

        function S9(r, e) {
            var t = mi(r, e, 28),
                n = mi(e, r, 2),
                i = mi(e, r, 7),
                o = t ^ n ^ i;
            return o < 0 && (o += 4294967296), o
        }

        function M9(r, e) {
            var t = yi(r, e, 14),
                n = yi(r, e, 18),
                i = yi(e, r, 9),
                o = t ^ n ^ i;
            return o < 0 && (o += 4294967296), o
        }

        function A9(r, e) {
            var t = mi(r, e, 14),
                n = mi(r, e, 18),
                i = mi(e, r, 9),
                o = t ^ n ^ i;
            return o < 0 && (o += 4294967296), o
        }

        function I9(r, e) {
            var t = yi(r, e, 1),
                n = yi(r, e, 8),
                i = Zx(r, e, 7),
                o = t ^ n ^ i;
            return o < 0 && (o += 4294967296), o
        }

        function B9(r, e) {
            var t = mi(r, e, 1),
                n = mi(r, e, 8),
                i = Yx(r, e, 7),
                o = t ^ n ^ i;
            return o < 0 && (o += 4294967296), o
        }

        function R9(r, e) {
            var t = yi(r, e, 19),
                n = yi(e, r, 29),
                i = Zx(r, e, 6),
                o = t ^ n ^ i;
            return o < 0 && (o += 4294967296), o
        }

        function k9(r, e) {
            var t = mi(r, e, 19),
                n = mi(e, r, 29),
                i = Yx(r, e, 6),
                o = t ^ n ^ i;
            return o < 0 && (o += 4294967296), o
        }
    });
    var t2 = Ue((nz, e2) => {
        "use strict";
        var ol = Hn(),
            Qx = il();

        function Hi() {
            if (!(this instanceof Hi)) return new Hi;
            Qx.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
        }
        ol.inherits(Hi, Qx);
        e2.exports = Hi;
        Hi.blockSize = 1024;
        Hi.outSize = 384;
        Hi.hmacStrength = 192;
        Hi.padLength = 128;
        Hi.prototype._digest = function(e) {
            return e === "hex" ? ol.toHex32(this.h.slice(0, 12), "big") : ol.split32(this.h.slice(0, 12), "big")
        }
    });
    var r2 = Ue(Ds => {
        "use strict";
        Ds.sha1 = $x();
        Ds.sha224 = Gx();
        Ds.sha256 = el();
        Ds.sha384 = t2();
        Ds.sha512 = il()
    });
    var f2 = Ue(a2 => {
        "use strict";
        var Ko = Hn(),
            P9 = qs(),
            kc = Ko.rotl32,
            n2 = Ko.sum32,
            Ca = Ko.sum32_3,
            i2 = Ko.sum32_4,
            s2 = P9.BlockHash;

        function gi() {
            if (!(this instanceof gi)) return new gi;
            s2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
        }
        Ko.inherits(gi, s2);
        a2.ripemd160 = gi;
        gi.blockSize = 512;
        gi.outSize = 160;
        gi.hmacStrength = 192;
        gi.padLength = 64;
        gi.prototype._update = function(e, t) {
            for (var n = this.h[0], i = this.h[1], o = this.h[2], a = this.h[3], y = this.h[4], g = n, E = i, A = o, I = a, q = y, L = 0; L < 80; L++) {
                var O = n2(kc(i2(n, o2(L, i, o, a), e[z9[L] + t], T9(L)), N9[L]), y);
                n = y, y = a, a = kc(o, 10), o = i, i = O, O = n2(kc(i2(g, o2(79 - L, E, A, I), e[U9[L] + t], L9(L)), q9[L]), q), g = q, q = I, I = kc(A, 10), A = E, E = O
            }
            O = Ca(this.h[1], o, I), this.h[1] = Ca(this.h[2], a, q), this.h[2] = Ca(this.h[3], y, g), this.h[3] = Ca(this.h[4], n, E), this.h[4] = Ca(this.h[0], i, A), this.h[0] = O
        };
        gi.prototype._digest = function(e) {
            return e === "hex" ? Ko.toHex32(this.h, "little") : Ko.split32(this.h, "little")
        };

        function o2(r, e, t, n) {
            return r <= 15 ? e ^ t ^ n : r <= 31 ? e & t | ~e & n : r <= 47 ? (e | ~t) ^ n : r <= 63 ? e & n | t & ~n : e ^ (t | ~n)
        }

        function T9(r) {
            return r <= 15 ? 0 : r <= 31 ? 1518500249 : r <= 47 ? 1859775393 : r <= 63 ? 2400959708 : 2840853838
        }

        function L9(r) {
            return r <= 15 ? 1352829926 : r <= 31 ? 1548603684 : r <= 47 ? 1836072691 : r <= 63 ? 2053994217 : 0
        }
        var z9 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
            U9 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
            N9 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
            q9 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
    });
    var c2 = Ue((sz, u2) => {
        "use strict";
        var F9 = Hn(),
            C9 = po();

        function Ks(r, e, t) {
            if (!(this instanceof Ks)) return new Ks(r, e, t);
            this.Hash = r, this.blockSize = r.blockSize / 8, this.outSize = r.outSize / 8, this.inner = null, this.outer = null, this._init(F9.toArray(e, t))
        }
        u2.exports = Ks;
        Ks.prototype._init = function(e) {
            e.length > this.blockSize && (e = new this.Hash().update(e).digest()), C9(e.length <= this.blockSize);
            for (var t = e.length; t < this.blockSize; t++) e.push(0);
            for (t = 0; t < e.length; t++) e[t] ^= 54;
            for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++) e[t] ^= 106;
            this.outer = new this.Hash().update(e)
        };
        Ks.prototype.update = function(e, t) {
            return this.inner.update(e, t), this
        };
        Ks.prototype.digest = function(e) {
            return this.outer.update(this.inner.digest()), this.outer.digest(e)
        }
    });
    var Pc = Ue(h2 => {
        var Kr = h2;
        Kr.utils = Hn();
        Kr.common = qs();
        Kr.sha = r2();
        Kr.ripemd = f2();
        Kr.hmac = c2();
        Kr.sha1 = Kr.sha.sha1;
        Kr.sha256 = Kr.sha.sha256;
        Kr.sha224 = Kr.sha.sha224;
        Kr.sha384 = Kr.sha.sha384;
        Kr.sha512 = Kr.sha.sha512;
        Kr.ripemd160 = Kr.ripemd.ripemd160
    });
    var d2 = Ue((fz, l2) => {
        l2.exports = {
            doubles: {
                step: 4,
                points: [
                    ["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],
                    ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],
                    ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],
                    ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],
                    ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],
                    ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],
                    ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],
                    ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],
                    ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],
                    ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],
                    ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],
                    ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],
                    ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],
                    ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],
                    ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],
                    ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],
                    ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],
                    ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],
                    ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],
                    ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],
                    ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],
                    ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],
                    ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],
                    ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],
                    ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],
                    ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],
                    ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],
                    ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],
                    ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],
                    ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],
                    ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],
                    ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],
                    ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],
                    ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],
                    ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],
                    ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],
                    ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],
                    ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],
                    ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],
                    ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],
                    ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],
                    ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],
                    ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],
                    ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],
                    ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],
                    ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],
                    ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],
                    ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],
                    ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],
                    ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],
                    ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],
                    ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],
                    ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],
                    ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],
                    ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],
                    ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],
                    ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],
                    ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],
                    ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],
                    ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],
                    ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],
                    ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],
                    ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],
                    ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],
                    ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]
                ]
            },
            naf: {
                wnd: 7,
                points: [
                    ["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],
                    ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],
                    ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],
                    ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],
                    ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],
                    ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],
                    ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],
                    ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],
                    ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],
                    ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],
                    ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],
                    ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],
                    ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],
                    ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],
                    ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],
                    ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],
                    ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],
                    ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],
                    ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],
                    ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],
                    ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],
                    ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],
                    ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],
                    ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],
                    ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],
                    ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],
                    ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],
                    ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],
                    ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],
                    ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],
                    ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],
                    ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],
                    ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],
                    ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],
                    ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],
                    ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],
                    ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],
                    ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],
                    ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],
                    ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],
                    ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],
                    ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],
                    ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],
                    ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],
                    ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],
                    ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],
                    ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],
                    ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],
                    ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],
                    ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],
                    ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],
                    ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],
                    ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],
                    ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],
                    ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],
                    ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],
                    ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],
                    ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],
                    ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],
                    ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],
                    ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],
                    ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],
                    ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],
                    ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],
                    ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],
                    ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],
                    ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],
                    ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],
                    ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],
                    ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],
                    ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],
                    ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],
                    ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],
                    ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],
                    ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],
                    ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],
                    ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],
                    ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],
                    ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],
                    ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],
                    ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],
                    ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],
                    ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],
                    ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],
                    ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],
                    ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],
                    ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],
                    ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],
                    ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],
                    ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],
                    ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],
                    ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],
                    ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],
                    ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],
                    ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],
                    ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],
                    ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],
                    ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],
                    ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],
                    ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],
                    ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],
                    ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],
                    ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],
                    ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],
                    ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],
                    ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],
                    ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],
                    ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],
                    ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],
                    ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],
                    ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],
                    ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],
                    ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],
                    ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],
                    ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],
                    ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],
                    ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],
                    ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],
                    ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],
                    ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],
                    ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],
                    ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],
                    ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],
                    ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],
                    ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],
                    ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],
                    ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]
                ]
            }
        }
    });
    var Tc = Ue(m2 => {
        "use strict";
        var al = m2,
            bo = Pc(),
            sl = J0(),
            O9 = En(),
            p2 = O9.assert;

        function y2(r) {
            r.type === "short" ? this.curve = new sl.short(r) : r.type === "edwards" ? this.curve = new sl.edwards(r) : this.curve = new sl.mont(r), this.g = this.curve.g, this.n = this.curve.n, this.hash = r.hash, p2(this.g.validate(), "Invalid curve"), p2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        al.PresetCurve = y2;

        function xo(r, e) {
            Object.defineProperty(al, r, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var t = new y2(e);
                    return Object.defineProperty(al, r, {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    }), t
                }
            })
        }
        xo("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: bo.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
        });
        xo("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: bo.sha256,
            gRed: !1,
            g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
        });
        xo("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: bo.sha256,
            gRed: !1,
            g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
        });
        xo("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: bo.sha384,
            gRed: !1,
            g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
        });
        xo("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: bo.sha512,
            gRed: !1,
            g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
        });
        xo("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: bo.sha256,
            gRed: !1,
            g: ["9"]
        });
        xo("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: bo.sha256,
            gRed: !1,
            g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
        });
        var fl;
        try {
            fl = d2()
        } catch {
            fl = void 0
        }
        xo("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: bo.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [{
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            }, {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }],
            gRed: !1,
            g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", fl]
        })
    });
    var x2 = Ue((cz, b2) => {
        "use strict";
        var D9 = Pc(),
            $o = j0(),
            g2 = po();

        function vo(r) {
            if (!(this instanceof vo)) return new vo(r);
            this.hash = r.hash, this.predResist = !!r.predResist, this.outLen = this.hash.outSize, this.minEntropy = r.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
            var e = $o.toArray(r.entropy, r.entropyEnc || "hex"),
                t = $o.toArray(r.nonce, r.nonceEnc || "hex"),
                n = $o.toArray(r.pers, r.persEnc || "hex");
            g2(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, t, n)
        }
        b2.exports = vo;
        vo.prototype._init = function(e, t, n) {
            var i = e.concat(t).concat(n);
            this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
            for (var o = 0; o < this.V.length; o++) this.K[o] = 0, this.V[o] = 1;
            this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656
        };
        vo.prototype._hmac = function() {
            return new D9.hmac(this.hash, this.K)
        };
        vo.prototype._update = function(e) {
            var t = this._hmac().update(this.V).update([0]);
            e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
        };
        vo.prototype.reseed = function(e, t, n, i) {
            typeof t != "string" && (i = n, n = t, t = null), e = $o.toArray(e, t), n = $o.toArray(n, i), g2(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1
        };
        vo.prototype.generate = function(e, t, n, i) {
            if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
            typeof t != "string" && (i = n, n = t, t = null), n && (n = $o.toArray(n, i || "hex"), this._update(n));
            for (var o = []; o.length < e;) this.V = this._hmac().update(this.V).digest(), o = o.concat(this.V);
            var a = o.slice(0, e);
            return this._update(n), this._reseed++, $o.encode(a, t)
        }
    });
    var w2 = Ue((hz, v2) => {
        "use strict";
        var K9 = ci(),
            $9 = En(),
            ul = $9.assert;

        function tn(r, e) {
            this.ec = r, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc)
        }
        v2.exports = tn;
        tn.fromPublic = function(e, t, n) {
            return t instanceof tn ? t : new tn(e, {
                pub: t,
                pubEnc: n
            })
        };
        tn.fromPrivate = function(e, t, n) {
            return t instanceof tn ? t : new tn(e, {
                priv: t,
                privEnc: n
            })
        };
        tn.prototype.validate = function() {
            var e = this.getPublic();
            return e.isInfinity() ? {
                result: !1,
                reason: "Invalid public key"
            } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
                result: !0,
                reason: null
            } : {
                result: !1,
                reason: "Public key * N != O"
            } : {
                result: !1,
                reason: "Public key is not a point"
            }
        };
        tn.prototype.getPublic = function(e, t) {
            return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub
        };
        tn.prototype.getPrivate = function(e) {
            return e === "hex" ? this.priv.toString(16, 2) : this.priv
        };
        tn.prototype._importPrivate = function(e, t) {
            this.priv = new K9(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n)
        };
        tn.prototype._importPublic = function(e, t) {
            if (e.x || e.y) {
                this.ec.curve.type === "mont" ? ul(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && ul(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
                return
            }
            this.pub = this.ec.curve.decodePoint(e, t)
        };
        tn.prototype.derive = function(e) {
            return e.validate() || ul(e.validate(), "public point not validated"), e.mul(this.priv).getX()
        };
        tn.prototype.sign = function(e, t, n) {
            return this.ec.sign(e, this, t, n)
        };
        tn.prototype.verify = function(e, t) {
            return this.ec.verify(e, t, this)
        };
        tn.prototype.inspect = function() {
            return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
        }
    });
    var S2 = Ue((lz, E2) => {
        "use strict";
        var Lc = ci(),
            ll = En(),
            j9 = ll.assert;

        function zc(r, e) {
            if (r instanceof zc) return r;
            this._importDER(r, e) || (j9(r.r && r.s, "Signature without r or s"), this.r = new Lc(r.r, 16), this.s = new Lc(r.s, 16), r.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = r.recoveryParam)
        }
        E2.exports = zc;

        function W9() {
            this.place = 0
        }

        function cl(r, e) {
            var t = r[e.place++];
            if (!(t & 128)) return t;
            var n = t & 15;
            if (n === 0 || n > 4) return !1;
            for (var i = 0, o = 0, a = e.place; o < n; o++, a++) i <<= 8, i |= r[a], i >>>= 0;
            return i <= 127 ? !1 : (e.place = a, i)
        }

        function _2(r) {
            for (var e = 0, t = r.length - 1; !r[e] && !(r[e + 1] & 128) && e < t;) e++;
            return e === 0 ? r : r.slice(e)
        }
        zc.prototype._importDER = function(e, t) {
            e = ll.toArray(e, t);
            var n = new W9;
            if (e[n.place++] !== 48) return !1;
            var i = cl(e, n);
            if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2) return !1;
            var o = cl(e, n);
            if (o === !1) return !1;
            var a = e.slice(n.place, o + n.place);
            if (n.place += o, e[n.place++] !== 2) return !1;
            var y = cl(e, n);
            if (y === !1 || e.length !== y + n.place) return !1;
            var g = e.slice(n.place, y + n.place);
            if (a[0] === 0)
                if (a[1] & 128) a = a.slice(1);
                else return !1;
            if (g[0] === 0)
                if (g[1] & 128) g = g.slice(1);
                else return !1;
            return this.r = new Lc(a), this.s = new Lc(g), this.recoveryParam = null, !0
        };

        function hl(r, e) {
            if (e < 128) {
                r.push(e);
                return
            }
            var t = 1 + (Math.log(e) / Math.LN2 >>> 3);
            for (r.push(t | 128); --t;) r.push(e >>> (t << 3) & 255);
            r.push(e)
        }
        zc.prototype.toDER = function(e) {
            var t = this.r.toArray(),
                n = this.s.toArray();
            for (t[0] & 128 && (t = [0].concat(t)), n[0] & 128 && (n = [0].concat(n)), t = _2(t), n = _2(n); !n[0] && !(n[1] & 128);) n = n.slice(1);
            var i = [2];
            hl(i, t.length), i = i.concat(t), i.push(2), hl(i, n.length);
            var o = i.concat(n),
                a = [48];
            return hl(a, o.length), a = a.concat(o), ll.encode(a, e)
        }
    });
    var B2 = Ue((dz, I2) => {
        "use strict";
        var jo = ci(),
            M2 = x2(),
            H9 = En(),
            dl = Tc(),
            V9 = G0(),
            A2 = H9.assert,
            pl = w2(),
            Uc = S2();

        function Nn(r) {
            if (!(this instanceof Nn)) return new Nn(r);
            typeof r == "string" && (A2(Object.prototype.hasOwnProperty.call(dl, r), "Unknown curve " + r), r = dl[r]), r instanceof dl.PresetCurve && (r = {
                curve: r
            }), this.curve = r.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = r.curve.g, this.g.precompute(r.curve.n.bitLength() + 1), this.hash = r.hash || r.curve.hash
        }
        I2.exports = Nn;
        Nn.prototype.keyPair = function(e) {
            return new pl(this, e)
        };
        Nn.prototype.keyFromPrivate = function(e, t) {
            return pl.fromPrivate(this, e, t)
        };
        Nn.prototype.keyFromPublic = function(e, t) {
            return pl.fromPublic(this, e, t)
        };
        Nn.prototype.genKeyPair = function(e) {
            e || (e = {});
            for (var t = new M2({
                    hash: this.hash,
                    pers: e.pers,
                    persEnc: e.persEnc || "utf8",
                    entropy: e.entropy || V9(this.hash.hmacStrength),
                    entropyEnc: e.entropy && e.entropyEnc || "utf8",
                    nonce: this.n.toArray()
                }), n = this.n.byteLength(), i = this.n.sub(new jo(2));;) {
                var o = new jo(t.generate(n));
                if (!(o.cmp(i) > 0)) return o.iaddn(1), this.keyFromPrivate(o)
            }
        };
        Nn.prototype._truncateToN = function(e, t) {
            var n = e.byteLength() * 8 - this.n.bitLength();
            return n > 0 && (e = e.ushrn(n)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
        };
        Nn.prototype.sign = function(e, t, n, i) {
            typeof n == "object" && (i = n, n = null), i || (i = {}), t = this.keyFromPrivate(t, n), e = this._truncateToN(new jo(e, 16));
            for (var o = this.n.byteLength(), a = t.getPrivate().toArray("be", o), y = e.toArray("be", o), g = new M2({
                    hash: this.hash,
                    entropy: a,
                    nonce: y,
                    pers: i.pers,
                    persEnc: i.persEnc || "utf8"
                }), E = this.n.sub(new jo(1)), A = 0;; A++) {
                var I = i.k ? i.k(A) : new jo(g.generate(this.n.byteLength()));
                if (I = this._truncateToN(I, !0), !(I.cmpn(1) <= 0 || I.cmp(E) >= 0)) {
                    var q = this.g.mul(I);
                    if (!q.isInfinity()) {
                        var L = q.getX(),
                            O = L.umod(this.n);
                        if (O.cmpn(0) !== 0) {
                            var Z = I.invm(this.n).mul(O.mul(t.getPrivate()).iadd(e));
                            if (Z = Z.umod(this.n), Z.cmpn(0) !== 0) {
                                var ge = (q.getY().isOdd() ? 1 : 0) | (L.cmp(O) !== 0 ? 2 : 0);
                                return i.canonical && Z.cmp(this.nh) > 0 && (Z = this.n.sub(Z), ge ^= 1), new Uc({
                                    r: O,
                                    s: Z,
                                    recoveryParam: ge
                                })
                            }
                        }
                    }
                }
            }
        };
        Nn.prototype.verify = function(e, t, n, i) {
            e = this._truncateToN(new jo(e, 16)), n = this.keyFromPublic(n, i), t = new Uc(t, "hex");
            var o = t.r,
                a = t.s;
            if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0) return !1;
            var y = a.invm(this.n),
                g = y.mul(e).umod(this.n),
                E = y.mul(o).umod(this.n),
                A;
            return this.curve._maxwellTrick ? (A = this.g.jmulAdd(g, n.getPublic(), E), A.isInfinity() ? !1 : A.eqXToP(o)) : (A = this.g.mulAdd(g, n.getPublic(), E), A.isInfinity() ? !1 : A.getX().umod(this.n).cmp(o) === 0)
        };
        Nn.prototype.recoverPubKey = function(r, e, t, n) {
            A2((3 & t) === t, "The recovery param is more than two bits"), e = new Uc(e, n);
            var i = this.n,
                o = new jo(r),
                a = e.r,
                y = e.s,
                g = t & 1,
                E = t >> 1;
            if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && E) throw new Error("Unable to find sencond key candinate");
            E ? a = this.curve.pointFromX(a.add(this.curve.n), g) : a = this.curve.pointFromX(a, g);
            var A = e.r.invm(i),
                I = i.sub(o).mul(A).umod(i),
                q = y.mul(A).umod(i);
            return this.g.mulAdd(I, a, q)
        };
        Nn.prototype.getKeyRecoveryParam = function(r, e, t, n) {
            if (e = new Uc(e, n), e.recoveryParam !== null) return e.recoveryParam;
            for (var i = 0; i < 4; i++) {
                var o;
                try {
                    o = this.recoverPubKey(r, e, i)
                } catch {
                    continue
                }
                if (o.eq(t)) return i
            }
            throw new Error("Unable to find valid recovery factor")
        }
    });
    var T2 = Ue((pz, P2) => {
        "use strict";
        var Oa = En(),
            k2 = Oa.assert,
            R2 = Oa.parseBytes,
            $s = Oa.cachedProperty;

        function Lr(r, e) {
            this.eddsa = r, this._secret = R2(e.secret), r.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = R2(e.pub)
        }
        Lr.fromPublic = function(e, t) {
            return t instanceof Lr ? t : new Lr(e, {
                pub: t
            })
        };
        Lr.fromSecret = function(e, t) {
            return t instanceof Lr ? t : new Lr(e, {
                secret: t
            })
        };
        Lr.prototype.secret = function() {
            return this._secret
        };
        $s(Lr, "pubBytes", function() {
            return this.eddsa.encodePoint(this.pub())
        });
        $s(Lr, "pub", function() {
            return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
        });
        $s(Lr, "privBytes", function() {
            var e = this.eddsa,
                t = this.hash(),
                n = e.encodingLength - 1,
                i = t.slice(0, e.encodingLength);
            return i[0] &= 248, i[n] &= 127, i[n] |= 64, i
        });
        $s(Lr, "priv", function() {
            return this.eddsa.decodeInt(this.privBytes())
        });
        $s(Lr, "hash", function() {
            return this.eddsa.hash().update(this.secret()).digest()
        });
        $s(Lr, "messagePrefix", function() {
            return this.hash().slice(this.eddsa.encodingLength)
        });
        Lr.prototype.sign = function(e) {
            return k2(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this)
        };
        Lr.prototype.verify = function(e, t) {
            return this.eddsa.verify(e, t, this)
        };
        Lr.prototype.getSecret = function(e) {
            return k2(this._secret, "KeyPair is public only"), Oa.encode(this.secret(), e)
        };
        Lr.prototype.getPublic = function(e) {
            return Oa.encode(this.pubBytes(), e)
        };
        P2.exports = Lr
    });
    var z2 = Ue((yz, L2) => {
        "use strict";
        var G9 = ci(),
            Nc = En(),
            Z9 = Nc.assert,
            qc = Nc.cachedProperty,
            Y9 = Nc.parseBytes;

        function Wo(r, e) {
            this.eddsa = r, typeof e != "object" && (e = Y9(e)), Array.isArray(e) && (e = {
                R: e.slice(0, r.encodingLength),
                S: e.slice(r.encodingLength)
            }), Z9(e.R && e.S, "Signature without R or S"), r.isPoint(e.R) && (this._R = e.R), e.S instanceof G9 && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded
        }
        qc(Wo, "S", function() {
            return this.eddsa.decodeInt(this.Sencoded())
        });
        qc(Wo, "R", function() {
            return this.eddsa.decodePoint(this.Rencoded())
        });
        qc(Wo, "Rencoded", function() {
            return this.eddsa.encodePoint(this.R())
        });
        qc(Wo, "Sencoded", function() {
            return this.eddsa.encodeInt(this.S())
        });
        Wo.prototype.toBytes = function() {
            return this.Rencoded().concat(this.Sencoded())
        };
        Wo.prototype.toHex = function() {
            return Nc.encode(this.toBytes(), "hex").toUpperCase()
        };
        L2.exports = Wo
    });
    var C2 = Ue((mz, F2) => {
        "use strict";
        var J9 = Pc(),
            X9 = Tc(),
            js = En(),
            Q9 = js.assert,
            N2 = js.parseBytes,
            q2 = T2(),
            U2 = z2();

        function gn(r) {
            if (Q9(r === "ed25519", "only tested with ed25519 so far"), !(this instanceof gn)) return new gn(r);
            r = X9[r].curve, this.curve = r, this.g = r.g, this.g.precompute(r.n.bitLength() + 1), this.pointClass = r.point().constructor, this.encodingLength = Math.ceil(r.n.bitLength() / 8), this.hash = J9.sha512
        }
        F2.exports = gn;
        gn.prototype.sign = function(e, t) {
            e = N2(e);
            var n = this.keyFromSecret(t),
                i = this.hashInt(n.messagePrefix(), e),
                o = this.g.mul(i),
                a = this.encodePoint(o),
                y = this.hashInt(a, n.pubBytes(), e).mul(n.priv()),
                g = i.add(y).umod(this.curve.n);
            return this.makeSignature({
                R: o,
                S: g,
                Rencoded: a
            })
        };
        gn.prototype.verify = function(e, t, n) {
            e = N2(e), t = this.makeSignature(t);
            var i = this.keyFromPublic(n),
                o = this.hashInt(t.Rencoded(), i.pubBytes(), e),
                a = this.g.mul(t.S()),
                y = t.R().add(i.pub().mul(o));
            return y.eq(a)
        };
        gn.prototype.hashInt = function() {
            for (var e = this.hash(), t = 0; t < arguments.length; t++) e.update(arguments[t]);
            return js.intFromLE(e.digest()).umod(this.curve.n)
        };
        gn.prototype.keyFromPublic = function(e) {
            return q2.fromPublic(this, e)
        };
        gn.prototype.keyFromSecret = function(e) {
            return q2.fromSecret(this, e)
        };
        gn.prototype.makeSignature = function(e) {
            return e instanceof U2 ? e : new U2(this, e)
        };
        gn.prototype.encodePoint = function(e) {
            var t = e.getY().toArray("le", this.encodingLength);
            return t[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, t
        };
        gn.prototype.decodePoint = function(e) {
            e = js.parseBytes(e);
            var t = e.length - 1,
                n = e.slice(0, t).concat(e[t] & -129),
                i = (e[t] & 128) !== 0,
                o = js.intFromLE(n);
            return this.curve.pointFromY(o, i)
        };
        gn.prototype.encodeInt = function(e) {
            return e.toArray("le", this.encodingLength)
        };
        gn.prototype.decodeInt = function(e) {
            return js.intFromLE(e)
        };
        gn.prototype.isPoint = function(e) {
            return e instanceof this.pointClass
        }
    });
    var D2 = Ue(O2 => {
        "use strict";
        var Ho = O2;
        Ho.version = yx().version;
        Ho.utils = En();
        Ho.rand = G0();
        Ho.curve = J0();
        Ho.curves = Tc();
        Ho.ec = B2();
        Ho.eddsa = C2()
    });
    var $2 = Ue((bz, K2) => {
        var eE = D2().ec,
            bi = new eE("secp256k1"),
            Ft = bi.curve,
            or = Ft.n.constructor;

        function tE(r, e) {
            let t = new or(e);
            if (t.cmp(Ft.p) >= 0) return null;
            t = t.toRed(Ft.red);
            let n = t.redSqr().redIMul(t).redIAdd(Ft.b).redSqrt();
            return r === 3 !== n.isOdd() && (n = n.redNeg()), bi.keyPair({
                pub: {
                    x: t,
                    y: n
                }
            })
        }

        function rE(r, e, t) {
            let n = new or(e),
                i = new or(t);
            if (n.cmp(Ft.p) >= 0 || i.cmp(Ft.p) >= 0 || (n = n.toRed(Ft.red), i = i.toRed(Ft.red), (r === 6 || r === 7) && i.isOdd() !== (r === 7))) return null;
            let o = n.redSqr().redIMul(n);
            return i.redSqr().redISub(o.redIAdd(Ft.b)).isZero() ? bi.keyPair({
                pub: {
                    x: n,
                    y: i
                }
            }) : null
        }

        function wo(r) {
            let e = r[0];
            switch (e) {
                case 2:
                case 3:
                    return r.length !== 33 ? null : tE(e, r.subarray(1, 33));
                case 4:
                case 6:
                case 7:
                    return r.length !== 65 ? null : rE(e, r.subarray(1, 33), r.subarray(33, 65));
                default:
                    return null
            }
        }

        function Vo(r, e) {
            let t = e.encode(null, r.length === 33);
            for (let n = 0; n < r.length; ++n) r[n] = t[n]
        }
        K2.exports = {
            contextRandomize() {
                return 0
            },
            privateKeyVerify(r) {
                let e = new or(r);
                return e.cmp(Ft.n) < 0 && !e.isZero() ? 0 : 1
            },
            privateKeyNegate(r) {
                let e = new or(r),
                    t = Ft.n.sub(e).umod(Ft.n).toArrayLike(Uint8Array, "be", 32);
                return r.set(t), 0
            },
            privateKeyTweakAdd(r, e) {
                let t = new or(e);
                if (t.cmp(Ft.n) >= 0 || (t.iadd(new or(r)), t.cmp(Ft.n) >= 0 && t.isub(Ft.n), t.isZero())) return 1;
                let n = t.toArrayLike(Uint8Array, "be", 32);
                return r.set(n), 0
            },
            privateKeyTweakMul(r, e) {
                let t = new or(e);
                if (t.cmp(Ft.n) >= 0 || t.isZero()) return 1;
                t.imul(new or(r)), t.cmp(Ft.n) >= 0 && (t = t.umod(Ft.n));
                let n = t.toArrayLike(Uint8Array, "be", 32);
                return r.set(n), 0
            },
            publicKeyVerify(r) {
                return wo(r) === null ? 1 : 0
            },
            publicKeyCreate(r, e) {
                let t = new or(e);
                if (t.cmp(Ft.n) >= 0 || t.isZero()) return 1;
                let n = bi.keyFromPrivate(e).getPublic();
                return Vo(r, n), 0
            },
            publicKeyConvert(r, e) {
                let t = wo(e);
                if (t === null) return 1;
                let n = t.getPublic();
                return Vo(r, n), 0
            },
            publicKeyNegate(r, e) {
                let t = wo(e);
                if (t === null) return 1;
                let n = t.getPublic();
                return n.y = n.y.redNeg(), Vo(r, n), 0
            },
            publicKeyCombine(r, e) {
                let t = new Array(e.length);
                for (let i = 0; i < e.length; ++i)
                    if (t[i] = wo(e[i]), t[i] === null) return 1;
                let n = t[0].getPublic();
                for (let i = 1; i < t.length; ++i) n = n.add(t[i].pub);
                return n.isInfinity() ? 2 : (Vo(r, n), 0)
            },
            publicKeyTweakAdd(r, e, t) {
                let n = wo(e);
                if (n === null) return 1;
                if (t = new or(t), t.cmp(Ft.n) >= 0) return 2;
                let i = n.getPublic().add(Ft.g.mul(t));
                return i.isInfinity() ? 2 : (Vo(r, i), 0)
            },
            publicKeyTweakMul(r, e, t) {
                let n = wo(e);
                if (n === null) return 1;
                if (t = new or(t), t.cmp(Ft.n) >= 0 || t.isZero()) return 2;
                let i = n.getPublic().mul(t);
                return Vo(r, i), 0
            },
            signatureNormalize(r) {
                let e = new or(r.subarray(0, 32)),
                    t = new or(r.subarray(32, 64));
                return e.cmp(Ft.n) >= 0 || t.cmp(Ft.n) >= 0 ? 1 : (t.cmp(bi.nh) === 1 && r.set(Ft.n.sub(t).toArrayLike(Uint8Array, "be", 32), 32), 0)
            },
            signatureExport(r, e) {
                let t = e.subarray(0, 32),
                    n = e.subarray(32, 64);
                if (new or(t).cmp(Ft.n) >= 0 || new or(n).cmp(Ft.n) >= 0) return 1;
                let {
                    output: i
                } = r, o = i.subarray(4, 4 + 33);
                o[0] = 0, o.set(t, 1);
                let a = 33,
                    y = 0;
                for (; a > 1 && o[y] === 0 && !(o[y + 1] & 128); --a, ++y);
                if (o = o.subarray(y), o[0] & 128 || a > 1 && o[0] === 0 && !(o[1] & 128)) return 1;
                let g = i.subarray(6 + 33, 6 + 33 + 33);
                g[0] = 0, g.set(n, 1);
                let E = 33,
                    A = 0;
                for (; E > 1 && g[A] === 0 && !(g[A + 1] & 128); --E, ++A);
                return g = g.subarray(A), g[0] & 128 || E > 1 && g[0] === 0 && !(g[1] & 128) ? 1 : (r.outputlen = 6 + a + E, i[0] = 48, i[1] = r.outputlen - 2, i[2] = 2, i[3] = o.length, i.set(o, 4), i[4 + a] = 2, i[5 + a] = g.length, i.set(g, 6 + a), 0)
            },
            signatureImport(r, e) {
                if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return 1;
                let t = e[3];
                if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return 1;
                let n = e[5 + t];
                if (n === 0 || 6 + t + n !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || n > 1 && e[t + 6] === 0 && !(e[t + 7] & 128)) return 1;
                let i = e.subarray(4, 4 + t);
                if (i.length === 33 && i[0] === 0 && (i = i.subarray(1)), i.length > 32) return 1;
                let o = e.subarray(6 + t);
                if (o.length === 33 && o[0] === 0 && (o = o.slice(1)), o.length > 32) throw new Error("S length is too long");
                let a = new or(i);
                a.cmp(Ft.n) >= 0 && (a = new or(0));
                let y = new or(e.subarray(6 + t));
                return y.cmp(Ft.n) >= 0 && (y = new or(0)), r.set(a.toArrayLike(Uint8Array, "be", 32), 0), r.set(y.toArrayLike(Uint8Array, "be", 32), 32), 0
            },
            ecdsaSign(r, e, t, n, i) {
                if (i) {
                    let y = i;
                    i = g => {
                        let E = y(e, t, null, n, g);
                        if (!(E instanceof Uint8Array && E.length === 32)) throw new Error("This is the way");
                        return new or(E)
                    }
                }
                let o = new or(t);
                if (o.cmp(Ft.n) >= 0 || o.isZero()) return 1;
                let a;
                try {
                    a = bi.sign(e, t, {
                        canonical: !0,
                        k: i,
                        pers: n
                    })
                } catch {
                    return 1
                }
                return r.signature.set(a.r.toArrayLike(Uint8Array, "be", 32), 0), r.signature.set(a.s.toArrayLike(Uint8Array, "be", 32), 32), r.recid = a.recoveryParam, 0
            },
            ecdsaVerify(r, e, t) {
                let n = {
                        r: r.subarray(0, 32),
                        s: r.subarray(32, 64)
                    },
                    i = new or(n.r),
                    o = new or(n.s);
                if (i.cmp(Ft.n) >= 0 || o.cmp(Ft.n) >= 0) return 1;
                if (o.cmp(bi.nh) === 1 || i.isZero() || o.isZero()) return 3;
                let a = wo(t);
                if (a === null) return 2;
                let y = a.getPublic();
                return bi.verify(e, n, y) ? 0 : 3
            },
            ecdsaRecover(r, e, t, n) {
                let i = {
                        r: e.slice(0, 32),
                        s: e.slice(32, 64)
                    },
                    o = new or(i.r),
                    a = new or(i.s);
                if (o.cmp(Ft.n) >= 0 || a.cmp(Ft.n) >= 0) return 1;
                if (o.isZero() || a.isZero()) return 2;
                let y;
                try {
                    y = bi.recoverPubKey(n, i, t)
                } catch {
                    return 2
                }
                return Vo(r, y), 0
            },
            ecdh(r, e, t, n, i, o, a) {
                let y = wo(e);
                if (y === null) return 1;
                let g = new or(t);
                if (g.cmp(Ft.n) >= 0 || g.isZero()) return 2;
                let E = y.getPublic().mul(g);
                if (i === void 0) {
                    let A = E.encode(null, !0),
                        I = bi.hash().update(A).digest();
                    for (let q = 0; q < 32; ++q) r[q] = I[q]
                } else {
                    o || (o = new Uint8Array(32));
                    let A = E.getX().toArray("be", 32);
                    for (let O = 0; O < 32; ++O) o[O] = A[O];
                    a || (a = new Uint8Array(32));
                    let I = E.getY().toArray("be", 32);
                    for (let O = 0; O < 32; ++O) a[O] = I[O];
                    let q = i(o, a, n);
                    if (!(q instanceof Uint8Array && q.length === r.length)) return 2;
                    r.set(q)
                }
                return 0
            }
        }
    });
    var W2 = Ue((xz, j2) => {
        j2.exports = px()($2())
    });
    var l3 = Ue(na => {
        "use strict";
        var Vl = ca(),
            ta = ha(),
            Yv = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        na.Buffer = Q;
        na.SlowBuffer = VM;
        na.INSPECT_MAX_BYTES = 50;
        var eh = 2147483647;
        na.kMaxLength = eh;
        Q.TYPED_ARRAY_SUPPORT = KM();
        !Q.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

        function KM() {
            try {
                let r = new Uint8Array(1),
                    e = {
                        foo: function() {
                            return 42
                        }
                    };
                return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42
            } catch {
                return !1
            }
        }
        Object.defineProperty(Q.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (!!Q.isBuffer(this)) return this.buffer
            }
        });
        Object.defineProperty(Q.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (!!Q.isBuffer(this)) return this.byteOffset
            }
        });

        function Zi(r) {
            if (r > eh) throw new RangeError('The value "' + r + '" is invalid for option "size"');
            let e = new Uint8Array(r);
            return Object.setPrototypeOf(e, Q.prototype), e
        }

        function Q(r, e, t) {
            if (typeof r == "number") {
                if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
                return Jl(r)
            }
            return e3(r, e, t)
        }
        Q.poolSize = 8192;

        function e3(r, e, t) {
            if (typeof r == "string") return jM(r, e);
            if (ArrayBuffer.isView(r)) return WM(r);
            if (r == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
            if (Ai(r, ArrayBuffer) || r && Ai(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ai(r, SharedArrayBuffer) || r && Ai(r.buffer, SharedArrayBuffer))) return Zl(r, e, t);
            if (typeof r == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
            let n = r.valueOf && r.valueOf();
            if (n != null && n !== r) return Q.from(n, e, t);
            let i = HM(r);
            if (i) return i;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function") return Q.from(r[Symbol.toPrimitive]("string"), e, t);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r)
        }
        Q.from = function(r, e, t) {
            return e3(r, e, t)
        };
        Object.setPrototypeOf(Q.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(Q, Uint8Array);

        function t3(r) {
            if (typeof r != "number") throw new TypeError('"size" argument must be of type number');
            if (r < 0) throw new RangeError('The value "' + r + '" is invalid for option "size"')
        }

        function $M(r, e, t) {
            return t3(r), r <= 0 ? Zi(r) : e !== void 0 ? typeof t == "string" ? Zi(r).fill(e, t) : Zi(r).fill(e) : Zi(r)
        }
        Q.alloc = function(r, e, t) {
            return $M(r, e, t)
        };

        function Jl(r) {
            return t3(r), Zi(r < 0 ? 0 : Xl(r) | 0)
        }
        Q.allocUnsafe = function(r) {
            return Jl(r)
        };
        Q.allocUnsafeSlow = function(r) {
            return Jl(r)
        };

        function jM(r, e) {
            if ((typeof e != "string" || e === "") && (e = "utf8"), !Q.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            let t = r3(r, e) | 0,
                n = Zi(t),
                i = n.write(r, e);
            return i !== t && (n = n.slice(0, i)), n
        }

        function Gl(r) {
            let e = r.length < 0 ? 0 : Xl(r.length) | 0,
                t = Zi(e);
            for (let n = 0; n < e; n += 1) t[n] = r[n] & 255;
            return t
        }

        function WM(r) {
            if (Ai(r, Uint8Array)) {
                let e = new Uint8Array(r);
                return Zl(e.buffer, e.byteOffset, e.byteLength)
            }
            return Gl(r)
        }

        function Zl(r, e, t) {
            if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
            if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
            let n;
            return e === void 0 && t === void 0 ? n = new Uint8Array(r) : t === void 0 ? n = new Uint8Array(r, e) : n = new Uint8Array(r, e, t), Object.setPrototypeOf(n, Q.prototype), n
        }

        function HM(r) {
            if (Q.isBuffer(r)) {
                let e = Xl(r.length) | 0,
                    t = Zi(e);
                return t.length === 0 || r.copy(t, 0, 0, e), t
            }
            if (r.length !== void 0) return typeof r.length != "number" || ed(r.length) ? Zi(0) : Gl(r);
            if (r.type === "Buffer" && Array.isArray(r.data)) return Gl(r.data)
        }

        function Xl(r) {
            if (r >= eh) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + eh.toString(16) + " bytes");
            return r | 0
        }

        function VM(r) {
            return +r != r && (r = 0), Q.alloc(+r)
        }
        Q.isBuffer = function(e) {
            return e != null && e._isBuffer === !0 && e !== Q.prototype
        };
        Q.compare = function(e, t) {
            if (Ai(e, Uint8Array) && (e = Q.from(e, e.offset, e.byteLength)), Ai(t, Uint8Array) && (t = Q.from(t, t.offset, t.byteLength)), !Q.isBuffer(e) || !Q.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (e === t) return 0;
            let n = e.length,
                i = t.length;
            for (let o = 0, a = Math.min(n, i); o < a; ++o)
                if (e[o] !== t[o]) {
                    n = e[o], i = t[o];
                    break
                } return n < i ? -1 : i < n ? 1 : 0
        };
        Q.isEncoding = function(e) {
            switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
            }
        };
        Q.concat = function(e, t) {
            if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (e.length === 0) return Q.alloc(0);
            let n;
            if (t === void 0)
                for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
            let i = Q.allocUnsafe(t),
                o = 0;
            for (n = 0; n < e.length; ++n) {
                let a = e[n];
                if (Ai(a, Uint8Array)) o + a.length > i.length ? (Q.isBuffer(a) || (a = Q.from(a)), a.copy(i, o)) : Uint8Array.prototype.set.call(i, a, o);
                else if (Q.isBuffer(a)) a.copy(i, o);
                else throw new TypeError('"list" argument must be an Array of Buffers');
                o += a.length
            }
            return i
        };

        function r3(r, e) {
            if (Q.isBuffer(r)) return r.length;
            if (ArrayBuffer.isView(r) || Ai(r, ArrayBuffer)) return r.byteLength;
            if (typeof r != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r);
            let t = r.length,
                n = arguments.length > 2 && arguments[2] === !0;
            if (!n && t === 0) return 0;
            let i = !1;
            for (;;) switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                    return t;
                case "utf8":
                case "utf-8":
                    return Yl(r).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return t * 2;
                case "hex":
                    return t >>> 1;
                case "base64":
                    return h3(r).length;
                default:
                    if (i) return n ? -1 : Yl(r).length;
                    e = ("" + e).toLowerCase(), i = !0
            }
        }
        Q.byteLength = r3;

        function GM(r, e, t) {
            let n = !1;
            if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e)) return "";
            for (r || (r = "utf8");;) switch (r) {
                case "hex":
                    return iA(this, e, t);
                case "utf8":
                case "utf-8":
                    return i3(this, e, t);
                case "ascii":
                    return rA(this, e, t);
                case "latin1":
                case "binary":
                    return nA(this, e, t);
                case "base64":
                    return eA(this, e, t);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return oA(this, e, t);
                default:
                    if (n) throw new TypeError("Unknown encoding: " + r);
                    r = (r + "").toLowerCase(), n = !0
            }
        }
        Q.prototype._isBuffer = !0;

        function Xo(r, e, t) {
            let n = r[e];
            r[e] = r[t], r[t] = n
        }
        Q.prototype.swap16 = function() {
            let e = this.length;
            if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let t = 0; t < e; t += 2) Xo(this, t, t + 1);
            return this
        };
        Q.prototype.swap32 = function() {
            let e = this.length;
            if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let t = 0; t < e; t += 4) Xo(this, t, t + 3), Xo(this, t + 1, t + 2);
            return this
        };
        Q.prototype.swap64 = function() {
            let e = this.length;
            if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let t = 0; t < e; t += 8) Xo(this, t, t + 7), Xo(this, t + 1, t + 6), Xo(this, t + 2, t + 5), Xo(this, t + 3, t + 4);
            return this
        };
        Q.prototype.toString = function() {
            let e = this.length;
            return e === 0 ? "" : arguments.length === 0 ? i3(this, 0, e) : GM.apply(this, arguments)
        };
        Q.prototype.toLocaleString = Q.prototype.toString;
        Q.prototype.equals = function(e) {
            if (!Q.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
            return this === e ? !0 : Q.compare(this, e) === 0
        };
        Q.prototype.inspect = function() {
            let e = "",
                t = na.INSPECT_MAX_BYTES;
            return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">"
        };
        Yv && (Q.prototype[Yv] = Q.prototype.inspect);
        Q.prototype.compare = function(e, t, n, i, o) {
            if (Ai(e, Uint8Array) && (e = Q.from(e, e.offset, e.byteLength)), !Q.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
            if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), o === void 0 && (o = this.length), t < 0 || n > e.length || i < 0 || o > this.length) throw new RangeError("out of range index");
            if (i >= o && t >= n) return 0;
            if (i >= o) return -1;
            if (t >= n) return 1;
            if (t >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === e) return 0;
            let a = o - i,
                y = n - t,
                g = Math.min(a, y),
                E = this.slice(i, o),
                A = e.slice(t, n);
            for (let I = 0; I < g; ++I)
                if (E[I] !== A[I]) {
                    a = E[I], y = A[I];
                    break
                } return a < y ? -1 : y < a ? 1 : 0
        };

        function n3(r, e, t, n, i) {
            if (r.length === 0) return -1;
            if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, ed(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
                if (i) return -1;
                t = r.length - 1
            } else if (t < 0)
                if (i) t = 0;
                else return -1;
            if (typeof e == "string" && (e = Q.from(e, n)), Q.isBuffer(e)) return e.length === 0 ? -1 : Jv(r, e, t, n, i);
            if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : Jv(r, [e], t, n, i);
            throw new TypeError("val must be string, number or Buffer")
        }

        function Jv(r, e, t, n, i) {
            let o = 1,
                a = r.length,
                y = e.length;
            if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
                if (r.length < 2 || e.length < 2) return -1;
                o = 2, a /= 2, y /= 2, t /= 2
            }

            function g(A, I) {
                return o === 1 ? A[I] : A.readUInt16BE(I * o)
            }
            let E;
            if (i) {
                let A = -1;
                for (E = t; E < a; E++)
                    if (g(r, E) === g(e, A === -1 ? 0 : E - A)) {
                        if (A === -1 && (A = E), E - A + 1 === y) return A * o
                    } else A !== -1 && (E -= E - A), A = -1
            } else
                for (t + y > a && (t = a - y), E = t; E >= 0; E--) {
                    let A = !0;
                    for (let I = 0; I < y; I++)
                        if (g(r, E + I) !== g(e, I)) {
                            A = !1;
                            break
                        } if (A) return E
                }
            return -1
        }
        Q.prototype.includes = function(e, t, n) {
            return this.indexOf(e, t, n) !== -1
        };
        Q.prototype.indexOf = function(e, t, n) {
            return n3(this, e, t, n, !0)
        };
        Q.prototype.lastIndexOf = function(e, t, n) {
            return n3(this, e, t, n, !1)
        };

        function ZM(r, e, t, n) {
            t = Number(t) || 0;
            let i = r.length - t;
            n ? (n = Number(n), n > i && (n = i)) : n = i;
            let o = e.length;
            n > o / 2 && (n = o / 2);
            let a;
            for (a = 0; a < n; ++a) {
                let y = parseInt(e.substr(a * 2, 2), 16);
                if (ed(y)) return a;
                r[t + a] = y
            }
            return a
        }

        function YM(r, e, t, n) {
            return th(Yl(e, r.length - t), r, t, n)
        }

        function JM(r, e, t, n) {
            return th(uA(e), r, t, n)
        }

        function XM(r, e, t, n) {
            return th(h3(e), r, t, n)
        }

        function QM(r, e, t, n) {
            return th(cA(e, r.length - t), r, t, n)
        }
        Q.prototype.write = function(e, t, n, i) {
            if (t === void 0) i = "utf8", n = this.length, t = 0;
            else if (n === void 0 && typeof t == "string") i = t, n = this.length, t = 0;
            else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
            else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            let o = this.length - t;
            if ((n === void 0 || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            i || (i = "utf8");
            let a = !1;
            for (;;) switch (i) {
                case "hex":
                    return ZM(this, e, t, n);
                case "utf8":
                case "utf-8":
                    return YM(this, e, t, n);
                case "ascii":
                case "latin1":
                case "binary":
                    return JM(this, e, t, n);
                case "base64":
                    return XM(this, e, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return QM(this, e, t, n);
                default:
                    if (a) throw new TypeError("Unknown encoding: " + i);
                    i = ("" + i).toLowerCase(), a = !0
            }
        };
        Q.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        };

        function eA(r, e, t) {
            return e === 0 && t === r.length ? Vl.fromByteArray(r) : Vl.fromByteArray(r.slice(e, t))
        }

        function i3(r, e, t) {
            t = Math.min(r.length, t);
            let n = [],
                i = e;
            for (; i < t;) {
                let o = r[i],
                    a = null,
                    y = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
                if (i + y <= t) {
                    let g, E, A, I;
                    switch (y) {
                        case 1:
                            o < 128 && (a = o);
                            break;
                        case 2:
                            g = r[i + 1], (g & 192) === 128 && (I = (o & 31) << 6 | g & 63, I > 127 && (a = I));
                            break;
                        case 3:
                            g = r[i + 1], E = r[i + 2], (g & 192) === 128 && (E & 192) === 128 && (I = (o & 15) << 12 | (g & 63) << 6 | E & 63, I > 2047 && (I < 55296 || I > 57343) && (a = I));
                            break;
                        case 4:
                            g = r[i + 1], E = r[i + 2], A = r[i + 3], (g & 192) === 128 && (E & 192) === 128 && (A & 192) === 128 && (I = (o & 15) << 18 | (g & 63) << 12 | (E & 63) << 6 | A & 63, I > 65535 && I < 1114112 && (a = I))
                    }
                }
                a === null ? (a = 65533, y = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), n.push(a), i += y
            }
            return tA(n)
        }
        var Xv = 4096;

        function tA(r) {
            let e = r.length;
            if (e <= Xv) return String.fromCharCode.apply(String, r);
            let t = "",
                n = 0;
            for (; n < e;) t += String.fromCharCode.apply(String, r.slice(n, n += Xv));
            return t
        }

        function rA(r, e, t) {
            let n = "";
            t = Math.min(r.length, t);
            for (let i = e; i < t; ++i) n += String.fromCharCode(r[i] & 127);
            return n
        }

        function nA(r, e, t) {
            let n = "";
            t = Math.min(r.length, t);
            for (let i = e; i < t; ++i) n += String.fromCharCode(r[i]);
            return n
        }

        function iA(r, e, t) {
            let n = r.length;
            (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
            let i = "";
            for (let o = e; o < t; ++o) i += hA[r[o]];
            return i
        }

        function oA(r, e, t) {
            let n = r.slice(e, t),
                i = "";
            for (let o = 0; o < n.length - 1; o += 2) i += String.fromCharCode(n[o] + n[o + 1] * 256);
            return i
        }
        Q.prototype.slice = function(e, t) {
            let n = this.length;
            e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
            let i = this.subarray(e, t);
            return Object.setPrototypeOf(i, Q.prototype), i
        };

        function zr(r, e, t) {
            if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
            if (r + e > t) throw new RangeError("Trying to access beyond buffer length")
        }
        Q.prototype.readUintLE = Q.prototype.readUIntLE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || zr(e, t, this.length);
            let i = this[e],
                o = 1,
                a = 0;
            for (; ++a < t && (o *= 256);) i += this[e + a] * o;
            return i
        };
        Q.prototype.readUintBE = Q.prototype.readUIntBE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || zr(e, t, this.length);
            let i = this[e + --t],
                o = 1;
            for (; t > 0 && (o *= 256);) i += this[e + --t] * o;
            return i
        };
        Q.prototype.readUint8 = Q.prototype.readUInt8 = function(e, t) {
            return e = e >>> 0, t || zr(e, 1, this.length), this[e]
        };
        Q.prototype.readUint16LE = Q.prototype.readUInt16LE = function(e, t) {
            return e = e >>> 0, t || zr(e, 2, this.length), this[e] | this[e + 1] << 8
        };
        Q.prototype.readUint16BE = Q.prototype.readUInt16BE = function(e, t) {
            return e = e >>> 0, t || zr(e, 2, this.length), this[e] << 8 | this[e + 1]
        };
        Q.prototype.readUint32LE = Q.prototype.readUInt32LE = function(e, t) {
            return e = e >>> 0, t || zr(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216
        };
        Q.prototype.readUint32BE = Q.prototype.readUInt32BE = function(e, t) {
            return e = e >>> 0, t || zr(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
        };
        Q.prototype.readBigUInt64LE = Ao(function(e) {
            e = e >>> 0, ra(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && Ya(e, this.length - 8);
            let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24,
                o = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24;
            return BigInt(i) + (BigInt(o) << BigInt(32))
        });
        Q.prototype.readBigUInt64BE = Ao(function(e) {
            e = e >>> 0, ra(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && Ya(e, this.length - 8);
            let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e],
                o = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n;
            return (BigInt(i) << BigInt(32)) + BigInt(o)
        });
        Q.prototype.readIntLE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || zr(e, t, this.length);
            let i = this[e],
                o = 1,
                a = 0;
            for (; ++a < t && (o *= 256);) i += this[e + a] * o;
            return o *= 128, i >= o && (i -= Math.pow(2, 8 * t)), i
        };
        Q.prototype.readIntBE = function(e, t, n) {
            e = e >>> 0, t = t >>> 0, n || zr(e, t, this.length);
            let i = t,
                o = 1,
                a = this[e + --i];
            for (; i > 0 && (o *= 256);) a += this[e + --i] * o;
            return o *= 128, a >= o && (a -= Math.pow(2, 8 * t)), a
        };
        Q.prototype.readInt8 = function(e, t) {
            return e = e >>> 0, t || zr(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
        };
        Q.prototype.readInt16LE = function(e, t) {
            e = e >>> 0, t || zr(e, 2, this.length);
            let n = this[e] | this[e + 1] << 8;
            return n & 32768 ? n | 4294901760 : n
        };
        Q.prototype.readInt16BE = function(e, t) {
            e = e >>> 0, t || zr(e, 2, this.length);
            let n = this[e + 1] | this[e] << 8;
            return n & 32768 ? n | 4294901760 : n
        };
        Q.prototype.readInt32LE = function(e, t) {
            return e = e >>> 0, t || zr(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
        };
        Q.prototype.readInt32BE = function(e, t) {
            return e = e >>> 0, t || zr(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
        };
        Q.prototype.readBigInt64LE = Ao(function(e) {
            e = e >>> 0, ra(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && Ya(e, this.length - 8);
            let i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24);
            return (BigInt(i) << BigInt(32)) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
        });
        Q.prototype.readBigInt64BE = Ao(function(e) {
            e = e >>> 0, ra(e, "offset");
            let t = this[e],
                n = this[e + 7];
            (t === void 0 || n === void 0) && Ya(e, this.length - 8);
            let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
            return (BigInt(i) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n)
        });
        Q.prototype.readFloatLE = function(e, t) {
            return e = e >>> 0, t || zr(e, 4, this.length), ta.read(this, e, !0, 23, 4)
        };
        Q.prototype.readFloatBE = function(e, t) {
            return e = e >>> 0, t || zr(e, 4, this.length), ta.read(this, e, !1, 23, 4)
        };
        Q.prototype.readDoubleLE = function(e, t) {
            return e = e >>> 0, t || zr(e, 8, this.length), ta.read(this, e, !0, 52, 8)
        };
        Q.prototype.readDoubleBE = function(e, t) {
            return e = e >>> 0, t || zr(e, 8, this.length), ta.read(this, e, !1, 52, 8)
        };

        function xn(r, e, t, n, i, o) {
            if (!Q.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > i || e < o) throw new RangeError('"value" argument is out of bounds');
            if (t + n > r.length) throw new RangeError("Index out of range")
        }
        Q.prototype.writeUintLE = Q.prototype.writeUIntLE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
                let y = Math.pow(2, 8 * n) - 1;
                xn(this, e, t, n, y, 0)
            }
            let o = 1,
                a = 0;
            for (this[t] = e & 255; ++a < n && (o *= 256);) this[t + a] = e / o & 255;
            return t + n
        };
        Q.prototype.writeUintBE = Q.prototype.writeUIntBE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
                let y = Math.pow(2, 8 * n) - 1;
                xn(this, e, t, n, y, 0)
            }
            let o = n - 1,
                a = 1;
            for (this[t + o] = e & 255; --o >= 0 && (a *= 256);) this[t + o] = e / a & 255;
            return t + n
        };
        Q.prototype.writeUint8 = Q.prototype.writeUInt8 = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1
        };
        Q.prototype.writeUint16LE = Q.prototype.writeUInt16LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
        };
        Q.prototype.writeUint16BE = Q.prototype.writeUInt16BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
        };
        Q.prototype.writeUint32LE = Q.prototype.writeUInt32LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4
        };
        Q.prototype.writeUint32BE = Q.prototype.writeUInt32BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
        };

        function o3(r, e, t, n, i) {
            c3(e, n, i, r, t, 7);
            let o = Number(e & BigInt(4294967295));
            r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o;
            let a = Number(e >> BigInt(32) & BigInt(4294967295));
            return r[t++] = a, a = a >> 8, r[t++] = a, a = a >> 8, r[t++] = a, a = a >> 8, r[t++] = a, t
        }

        function s3(r, e, t, n, i) {
            c3(e, n, i, r, t, 7);
            let o = Number(e & BigInt(4294967295));
            r[t + 7] = o, o = o >> 8, r[t + 6] = o, o = o >> 8, r[t + 5] = o, o = o >> 8, r[t + 4] = o;
            let a = Number(e >> BigInt(32) & BigInt(4294967295));
            return r[t + 3] = a, a = a >> 8, r[t + 2] = a, a = a >> 8, r[t + 1] = a, a = a >> 8, r[t] = a, t + 8
        }
        Q.prototype.writeBigUInt64LE = Ao(function(e, t = 0) {
            return o3(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
        });
        Q.prototype.writeBigUInt64BE = Ao(function(e, t = 0) {
            return s3(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
        });
        Q.prototype.writeIntLE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, !i) {
                let g = Math.pow(2, 8 * n - 1);
                xn(this, e, t, n, g - 1, -g)
            }
            let o = 0,
                a = 1,
                y = 0;
            for (this[t] = e & 255; ++o < n && (a *= 256);) e < 0 && y === 0 && this[t + o - 1] !== 0 && (y = 1), this[t + o] = (e / a >> 0) - y & 255;
            return t + n
        };
        Q.prototype.writeIntBE = function(e, t, n, i) {
            if (e = +e, t = t >>> 0, !i) {
                let g = Math.pow(2, 8 * n - 1);
                xn(this, e, t, n, g - 1, -g)
            }
            let o = n - 1,
                a = 1,
                y = 0;
            for (this[t + o] = e & 255; --o >= 0 && (a *= 256);) e < 0 && y === 0 && this[t + o + 1] !== 0 && (y = 1), this[t + o] = (e / a >> 0) - y & 255;
            return t + n
        };
        Q.prototype.writeInt8 = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1
        };
        Q.prototype.writeInt16LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
        };
        Q.prototype.writeInt16BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
        };
        Q.prototype.writeInt32LE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
        };
        Q.prototype.writeInt32BE = function(e, t, n) {
            return e = +e, t = t >>> 0, n || xn(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
        };
        Q.prototype.writeBigInt64LE = Ao(function(e, t = 0) {
            return o3(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        });
        Q.prototype.writeBigInt64BE = Ao(function(e, t = 0) {
            return s3(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        });

        function a3(r, e, t, n, i, o) {
            if (t + n > r.length) throw new RangeError("Index out of range");
            if (t < 0) throw new RangeError("Index out of range")
        }

        function f3(r, e, t, n, i) {
            return e = +e, t = t >>> 0, i || a3(r, e, t, 4, 34028234663852886e22, -34028234663852886e22), ta.write(r, e, t, n, 23, 4), t + 4
        }
        Q.prototype.writeFloatLE = function(e, t, n) {
            return f3(this, e, t, !0, n)
        };
        Q.prototype.writeFloatBE = function(e, t, n) {
            return f3(this, e, t, !1, n)
        };

        function u3(r, e, t, n, i) {
            return e = +e, t = t >>> 0, i || a3(r, e, t, 8, 17976931348623157e292, -17976931348623157e292), ta.write(r, e, t, n, 52, 8), t + 8
        }
        Q.prototype.writeDoubleLE = function(e, t, n) {
            return u3(this, e, t, !0, n)
        };
        Q.prototype.writeDoubleBE = function(e, t, n) {
            return u3(this, e, t, !1, n)
        };
        Q.prototype.copy = function(e, t, n, i) {
            if (!Q.isBuffer(e)) throw new TypeError("argument should be a Buffer");
            if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0) return 0;
            if (t < 0) throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
            if (i < 0) throw new RangeError("sourceEnd out of bounds");
            i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
            let o = i - n;
            return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, i) : Uint8Array.prototype.set.call(e, this.subarray(n, i), t), o
        };
        Q.prototype.fill = function(e, t, n, i) {
            if (typeof e == "string") {
                if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string") throw new TypeError("encoding must be a string");
                if (typeof i == "string" && !Q.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                if (e.length === 1) {
                    let a = e.charCodeAt(0);
                    (i === "utf8" && a < 128 || i === "latin1") && (e = a)
                }
            } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
            if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
            if (n <= t) return this;
            t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
            let o;
            if (typeof e == "number")
                for (o = t; o < n; ++o) this[o] = e;
            else {
                let a = Q.isBuffer(e) ? e : Q.from(e, i),
                    y = a.length;
                if (y === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                for (o = 0; o < n - t; ++o) this[o + t] = a[o % y]
            }
            return this
        };
        var ea = {};

        function Ql(r, e, t) {
            ea[r] = class extends t {
                constructor() {
                    super(), Object.defineProperty(this, "message", {
                        value: e.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }), this.name = `${this.name} [${r}]`, this.stack, delete this.name
                }
                get code() {
                    return r
                }
                set code(i) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: i,
                        writable: !0
                    })
                }
                toString() {
                    return `${this.name} [${r}]: ${this.message}`
                }
            }
        }
        Ql("ERR_BUFFER_OUT_OF_BOUNDS", function(r) {
            return r ? `${r} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
        }, RangeError);
        Ql("ERR_INVALID_ARG_TYPE", function(r, e) {
            return `The "${r}" argument must be of type number. Received type ${typeof e}`
        }, TypeError);
        Ql("ERR_OUT_OF_RANGE", function(r, e, t) {
            let n = `The value of "${r}" is out of range.`,
                i = t;
            return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? i = Qv(String(t)) : typeof t == "bigint" && (i = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (i = Qv(i)), i += "n"), n += ` It must be ${e}. Received ${i}`, n
        }, RangeError);

        function Qv(r) {
            let e = "",
                t = r.length,
                n = r[0] === "-" ? 1 : 0;
            for (; t >= n + 4; t -= 3) e = `_${r.slice(t-3,t)}${e}`;
            return `${r.slice(0,t)}${e}`
        }

        function sA(r, e, t) {
            ra(e, "offset"), (r[e] === void 0 || r[e + t] === void 0) && Ya(e, r.length - (t + 1))
        }

        function c3(r, e, t, n, i, o) {
            if (r > t || r < e) {
                let a = typeof e == "bigint" ? "n" : "",
                    y;
                throw o > 3 ? e === 0 || e === BigInt(0) ? y = `>= 0${a} and < 2${a} ** ${(o+1)*8}${a}` : y = `>= -(2${a} ** ${(o+1)*8-1}${a}) and < 2 ** ${(o+1)*8-1}${a}` : y = `>= ${e}${a} and <= ${t}${a}`, new ea.ERR_OUT_OF_RANGE("value", y, r)
            }
            sA(n, i, o)
        }

        function ra(r, e) {
            if (typeof r != "number") throw new ea.ERR_INVALID_ARG_TYPE(e, "number", r)
        }

        function Ya(r, e, t) {
            throw Math.floor(r) !== r ? (ra(r, t), new ea.ERR_OUT_OF_RANGE(t || "offset", "an integer", r)) : e < 0 ? new ea.ERR_BUFFER_OUT_OF_BOUNDS : new ea.ERR_OUT_OF_RANGE(t || "offset", `>= ${t?1:0} and <= ${e}`, r)
        }
        var aA = /[^+/0-9A-Za-z-_]/g;

        function fA(r) {
            if (r = r.split("=")[0], r = r.trim().replace(aA, ""), r.length < 2) return "";
            for (; r.length % 4 !== 0;) r = r + "=";
            return r
        }

        function Yl(r, e) {
            e = e || 1 / 0;
            let t, n = r.length,
                i = null,
                o = [];
            for (let a = 0; a < n; ++a) {
                if (t = r.charCodeAt(a), t > 55295 && t < 57344) {
                    if (!i) {
                        if (t > 56319) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        } else if (a + 1 === n) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        i = t;
                        continue
                    }
                    if (t < 56320) {
                        (e -= 3) > -1 && o.push(239, 191, 189), i = t;
                        continue
                    }
                    t = (i - 55296 << 10 | t - 56320) + 65536
                } else i && (e -= 3) > -1 && o.push(239, 191, 189);
                if (i = null, t < 128) {
                    if ((e -= 1) < 0) break;
                    o.push(t)
                } else if (t < 2048) {
                    if ((e -= 2) < 0) break;
                    o.push(t >> 6 | 192, t & 63 | 128)
                } else if (t < 65536) {
                    if ((e -= 3) < 0) break;
                    o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128)
                } else if (t < 1114112) {
                    if ((e -= 4) < 0) break;
                    o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128)
                } else throw new Error("Invalid code point")
            }
            return o
        }

        function uA(r) {
            let e = [];
            for (let t = 0; t < r.length; ++t) e.push(r.charCodeAt(t) & 255);
            return e
        }

        function cA(r, e) {
            let t, n, i, o = [];
            for (let a = 0; a < r.length && !((e -= 2) < 0); ++a) t = r.charCodeAt(a), n = t >> 8, i = t % 256, o.push(i), o.push(n);
            return o
        }

        function h3(r) {
            return Vl.toByteArray(fA(r))
        }

        function th(r, e, t, n) {
            let i;
            for (i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i) e[i + t] = r[i];
            return i
        }

        function Ai(r, e) {
            return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name
        }

        function ed(r) {
            return r !== r
        }
        var hA = function() {
            let r = "0123456789abcdef",
                e = new Array(256);
            for (let t = 0; t < 16; ++t) {
                let n = t * 16;
                for (let i = 0; i < 16; ++i) e[n + i] = r[t] + r[i]
            }
            return e
        }();

        function Ao(r) {
            return typeof BigInt > "u" ? lA : r
        }

        function lA() {
            throw new Error("BigInt not supported")
        }
    });
    var wf = {};
    ct(wf, {
        dapp_icon: () => vf
    });
    var vf = {};
    ct(vf, {
        method: () => sp,
        notification: () => gw,
        params: () => ap
    });
    var Jt;
    (function(r) {
        r.assertEqual = i => i;

        function e(i) {}
        r.assertIs = e;

        function t(i) {
            throw new Error
        }
        r.assertNever = t, r.arrayToEnum = i => {
            let o = {};
            for (let a of i) o[a] = a;
            return o
        }, r.getValidEnumValues = i => {
            let o = r.objectKeys(i).filter(y => typeof i[i[y]] != "number"),
                a = {};
            for (let y of o) a[y] = i[y];
            return r.objectValues(a)
        }, r.objectValues = i => r.objectKeys(i).map(function(o) {
            return i[o]
        }), r.objectKeys = typeof Object.keys == "function" ? i => Object.keys(i) : i => {
            let o = [];
            for (let a in i) Object.prototype.hasOwnProperty.call(i, a) && o.push(a);
            return o
        }, r.find = (i, o) => {
            for (let a of i)
                if (o(a)) return a
        }, r.isInteger = typeof Number.isInteger == "function" ? i => Number.isInteger(i) : i => typeof i == "number" && isFinite(i) && Math.floor(i) === i;

        function n(i, o = " | ") {
            return i.map(a => typeof a == "string" ? `'${a}'` : a).join(o)
        }
        r.joinValues = n, r.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o
    })(Jt || (Jt = {}));
    var ft = Jt.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
        Yi = r => {
            switch (typeof r) {
                case "undefined":
                    return ft.undefined;
                case "string":
                    return ft.string;
                case "number":
                    return isNaN(r) ? ft.nan : ft.number;
                case "boolean":
                    return ft.boolean;
                case "function":
                    return ft.function;
                case "bigint":
                    return ft.bigint;
                case "object":
                    return Array.isArray(r) ? ft.array : r === null ? ft.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? ft.promise : typeof Map < "u" && r instanceof Map ? ft.map : typeof Set < "u" && r instanceof Set ? ft.set : typeof Date < "u" && r instanceof Date ? ft.date : ft.object;
                default:
                    return ft.unknown
            }
        },
        Je = Jt.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of"]),
        M3 = r => JSON.stringify(r, null, 2).replace(/"([^"]+)":/g, "$1:"),
        vn = class extends Error {
            constructor(e) {
                super(), this.issues = [], this.addIssue = n => {
                    this.issues = [...this.issues, n]
                }, this.addIssues = (n = []) => {
                    this.issues = [...this.issues, ...n]
                };
                let t = new.target.prototype;
                Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e
            }
            get errors() {
                return this.issues
            }
            format(e) {
                let t = e || function(o) {
                        return o.message
                    },
                    n = {
                        _errors: []
                    },
                    i = o => {
                        for (let a of o.issues)
                            if (a.code === "invalid_union") a.unionErrors.map(i);
                            else if (a.code === "invalid_return_type") i(a.returnTypeError);
                        else if (a.code === "invalid_arguments") i(a.argumentsError);
                        else if (a.path.length === 0) n._errors.push(t(a));
                        else {
                            let y = n,
                                g = 0;
                            for (; g < a.path.length;) {
                                let E = a.path[g];
                                g === a.path.length - 1 ? (y[E] = y[E] || {
                                    _errors: []
                                }, y[E]._errors.push(t(a))) : y[E] = y[E] || {
                                    _errors: []
                                }, y = y[E], g++
                            }
                        }
                    };
                return i(this), n
            }
            toString() {
                return this.message
            }
            get message() {
                return JSON.stringify(this.issues, Jt.jsonStringifyReplacer, 2)
            }
            get isEmpty() {
                return this.issues.length === 0
            }
            flatten(e = t => t.message) {
                let t = {},
                    n = [];
                for (let i of this.issues) i.path.length > 0 ? (t[i.path[0]] = t[i.path[0]] || [], t[i.path[0]].push(e(i))) : n.push(e(i));
                return {
                    formErrors: n,
                    fieldErrors: t
                }
            }
            get formErrors() {
                return this.flatten()
            }
        };
    vn.create = r => new vn(r);
    var aa = (r, e) => {
            let t;
            switch (r.code) {
                case Je.invalid_type:
                    r.received === ft.undefined ? t = "Required" : t = `Expected ${r.expected}, received ${r.received}`;
                    break;
                case Je.invalid_literal:
                    t = `Invalid literal value, expected ${JSON.stringify(r.expected,Jt.jsonStringifyReplacer)}`;
                    break;
                case Je.unrecognized_keys:
                    t = `Unrecognized key(s) in object: ${Jt.joinValues(r.keys,", ")}`;
                    break;
                case Je.invalid_union:
                    t = "Invalid input";
                    break;
                case Je.invalid_union_discriminator:
                    t = `Invalid discriminator value. Expected ${Jt.joinValues(r.options)}`;
                    break;
                case Je.invalid_enum_value:
                    t = `Invalid enum value. Expected ${Jt.joinValues(r.options)}, received '${r.received}'`;
                    break;
                case Je.invalid_arguments:
                    t = "Invalid function arguments";
                    break;
                case Je.invalid_return_type:
                    t = "Invalid function return type";
                    break;
                case Je.invalid_date:
                    t = "Invalid date";
                    break;
                case Je.invalid_string:
                    typeof r.validation == "object" ? "startsWith" in r.validation ? t = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith" in r.validation ? t = `Invalid input: must end with "${r.validation.endsWith}"` : Jt.assertNever(r.validation) : r.validation !== "regex" ? t = `Invalid ${r.validation}` : t = "Invalid";
                    break;
                case Je.too_small:
                    r.type === "array" ? t = `Array must contain ${r.inclusive?"at least":"more than"} ${r.minimum} element(s)` : r.type === "string" ? t = `String must contain ${r.inclusive?"at least":"over"} ${r.minimum} character(s)` : r.type === "number" ? t = `Number must be greater than ${r.inclusive?"or equal to ":""}${r.minimum}` : r.type === "date" ? t = `Date must be greater than ${r.inclusive?"or equal to ":""}${new Date(r.minimum)}` : t = "Invalid input";
                    break;
                case Je.too_big:
                    r.type === "array" ? t = `Array must contain ${r.inclusive?"at most":"less than"} ${r.maximum} element(s)` : r.type === "string" ? t = `String must contain ${r.inclusive?"at most":"under"} ${r.maximum} character(s)` : r.type === "number" ? t = `Number must be less than ${r.inclusive?"or equal to ":""}${r.maximum}` : r.type === "date" ? t = `Date must be smaller than ${r.inclusive?"or equal to ":""}${new Date(r.maximum)}` : t = "Invalid input";
                    break;
                case Je.custom:
                    t = "Invalid input";
                    break;
                case Je.invalid_intersection_types:
                    t = "Intersection results could not be merged";
                    break;
                case Je.not_multiple_of:
                    t = `Number must be a multiple of ${r.multipleOf}`;
                    break;
                default:
                    t = e.defaultError, Jt.assertNever(r)
            }
            return {
                message: t
            }
        },
        ud = aa;

    function A3(r) {
        ud = r
    }

    function Qa() {
        return ud
    }
    var ef = r => {
            let {
                data: e,
                path: t,
                errorMaps: n,
                issueData: i
            } = r, o = [...t, ...i.path || []], a = {
                ...i,
                path: o
            }, y = "", g = n.filter(E => !!E).slice().reverse();
            for (let E of g) y = E(a, {
                data: e,
                defaultError: y
            }).message;
            return {
                ...i,
                path: o,
                message: i.message || y
            }
        },
        I3 = [];

    function vt(r, e) {
        let t = ef({
            issueData: e,
            data: r.data,
            path: r.path,
            errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, Qa(), aa].filter(n => !!n)
        });
        r.common.issues.push(t)
    }
    var Fr = class {
            constructor() {
                this.value = "valid"
            }
            dirty() {
                this.value === "valid" && (this.value = "dirty")
            }
            abort() {
                this.value !== "aborted" && (this.value = "aborted")
            }
            static mergeArray(e, t) {
                let n = [];
                for (let i of t) {
                    if (i.status === "aborted") return kt;
                    i.status === "dirty" && e.dirty(), n.push(i.value)
                }
                return {
                    status: e.value,
                    value: n
                }
            }
            static async mergeObjectAsync(e, t) {
                let n = [];
                for (let i of t) n.push({
                    key: await i.key,
                    value: await i.value
                });
                return Fr.mergeObjectSync(e, n)
            }
            static mergeObjectSync(e, t) {
                let n = {};
                for (let i of t) {
                    let {
                        key: o,
                        value: a
                    } = i;
                    if (o.status === "aborted" || a.status === "aborted") return kt;
                    o.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), (typeof a.value < "u" || i.alwaysSet) && (n[o.value] = a.value)
                }
                return {
                    status: e.value,
                    value: n
                }
            }
        },
        kt = Object.freeze({
            status: "aborted"
        }),
        B3 = r => ({
            status: "dirty",
            value: r
        }),
        sn = r => ({
            status: "valid",
            value: r
        }),
        ch = r => r.status === "aborted",
        hh = r => r.status === "dirty",
        tf = r => r.status === "valid",
        lh = r => typeof Promise !== void 0 && r instanceof Promise,
        Wt;
    (function(r) {
        r.errToObj = e => typeof e == "string" ? {
            message: e
        } : e || {}, r.toString = e => typeof e == "string" ? e : e?.message
    })(Wt || (Wt = {}));
    var In = class {
            constructor(e, t, n, i) {
                this.parent = e, this.data = t, this._path = n, this._key = i
            }
            get path() {
                return this._path.concat(this._key)
            }
        },
        sd = (r, e) => {
            if (tf(e)) return {
                success: !0,
                data: e.value
            }; {
                if (!r.common.issues.length) throw new Error("Validation failed but no issues detected.");
                let t = new vn(r.common.issues);
                return {
                    success: !1,
                    error: t
                }
            }
        };

    function Ut(r) {
        if (!r) return {};
        let {
            errorMap: e,
            invalid_type_error: t,
            required_error: n,
            description: i
        } = r;
        if (e && (t || n)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        return e ? {
            errorMap: e,
            description: i
        } : {
            errorMap: (a, y) => a.code !== "invalid_type" ? {
                message: y.defaultError
            } : typeof y.data > "u" ? {
                message: n ?? y.defaultError
            } : {
                message: t ?? y.defaultError
            },
            description: i
        }
    }
    var Lt = class {
            constructor(e) {
                this.spa = this.safeParseAsync, this.superRefine = this._refinement, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.default = this.default.bind(this), this.describe = this.describe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this)
            }
            get description() {
                return this._def.description
            }
            _getType(e) {
                return Yi(e.data)
            }
            _getOrReturnCtx(e, t) {
                return t || {
                    common: e.parent.common,
                    data: e.data,
                    parsedType: Yi(e.data),
                    schemaErrorMap: this._def.errorMap,
                    path: e.path,
                    parent: e.parent
                }
            }
            _processInputParams(e) {
                return {
                    status: new Fr,
                    ctx: {
                        common: e.parent.common,
                        data: e.data,
                        parsedType: Yi(e.data),
                        schemaErrorMap: this._def.errorMap,
                        path: e.path,
                        parent: e.parent
                    }
                }
            }
            _parseSync(e) {
                let t = this._parse(e);
                if (lh(t)) throw new Error("Synchronous parse encountered promise.");
                return t
            }
            _parseAsync(e) {
                let t = this._parse(e);
                return Promise.resolve(t)
            }
            parse(e, t) {
                let n = this.safeParse(e, t);
                if (n.success) return n.data;
                throw n.error
            }
            safeParse(e, t) {
                var n;
                let i = {
                        common: {
                            issues: [],
                            async: (n = t?.async) !== null && n !== void 0 ? n : !1,
                            contextualErrorMap: t?.errorMap
                        },
                        path: t?.path || [],
                        schemaErrorMap: this._def.errorMap,
                        parent: null,
                        data: e,
                        parsedType: Yi(e)
                    },
                    o = this._parseSync({
                        data: e,
                        path: i.path,
                        parent: i
                    });
                return sd(i, o)
            }
            async parseAsync(e, t) {
                let n = await this.safeParseAsync(e, t);
                if (n.success) return n.data;
                throw n.error
            }
            async safeParseAsync(e, t) {
                let n = {
                        common: {
                            issues: [],
                            contextualErrorMap: t?.errorMap,
                            async: !0
                        },
                        path: t?.path || [],
                        schemaErrorMap: this._def.errorMap,
                        parent: null,
                        data: e,
                        parsedType: Yi(e)
                    },
                    i = this._parse({
                        data: e,
                        path: [],
                        parent: n
                    }),
                    o = await (lh(i) ? i : Promise.resolve(i));
                return sd(n, o)
            }
            refine(e, t) {
                let n = i => typeof t == "string" || typeof t > "u" ? {
                    message: t
                } : typeof t == "function" ? t(i) : t;
                return this._refinement((i, o) => {
                    let a = e(i),
                        y = () => o.addIssue({
                            code: Je.custom,
                            ...n(i)
                        });
                    return typeof Promise < "u" && a instanceof Promise ? a.then(g => g ? !0 : (y(), !1)) : a ? !0 : (y(), !1)
                })
            }
            refinement(e, t) {
                return this._refinement((n, i) => e(n) ? !0 : (i.addIssue(typeof t == "function" ? t(n, i) : t), !1))
            }
            _refinement(e) {
                return new kn({
                    schema: this,
                    typeName: At.ZodEffects,
                    effect: {
                        type: "refinement",
                        refinement: e
                    }
                })
            }
            optional() {
                return An.create(this)
            }
            nullable() {
                return ki.create(this)
            }
            nullish() {
                return this.optional().nullable()
            }
            array() {
                return Bn.create(this)
            }
            promise() {
                return eo.create(this)
            }
            or(e) {
                return Io.create([this, e])
            }
            and(e) {
                return Bo.create(this, e)
            }
            transform(e) {
                return new kn({
                    schema: this,
                    typeName: At.ZodEffects,
                    effect: {
                        type: "transform",
                        transform: e
                    }
                })
            }
            default (e) {
                let t = typeof e == "function" ? e : () => e;
                return new fa({
                    innerType: this,
                    defaultValue: t,
                    typeName: At.ZodDefault
                })
            }
            brand() {
                return new nf({
                    typeName: At.ZodBranded,
                    type: this,
                    ...Ut(void 0)
                })
            }
            describe(e) {
                let t = this.constructor;
                return new t({
                    ...this._def,
                    description: e
                })
            }
            isOptional() {
                return this.safeParse(void 0).success
            }
            isNullable() {
                return this.safeParse(null).success
            }
        },
        R3 = /^c[^\s-]{8,}$/i,
        k3 = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i,
        P3 = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i,
        ti = class extends Lt {
            constructor() {
                super(...arguments), this._regex = (e, t, n) => this.refinement(i => e.test(i), {
                    validation: t,
                    code: Je.invalid_string,
                    ...Wt.errToObj(n)
                }), this.nonempty = e => this.min(1, Wt.errToObj(e)), this.trim = () => new ti({
                    ...this._def,
                    checks: [...this._def.checks, {
                        kind: "trim"
                    }]
                })
            }
            _parse(e) {
                if (this._getType(e) !== ft.string) {
                    let o = this._getOrReturnCtx(e);
                    return vt(o, {
                        code: Je.invalid_type,
                        expected: ft.string,
                        received: o.parsedType
                    }), kt
                }
                let n = new Fr,
                    i;
                for (let o of this._def.checks)
                    if (o.kind === "min") e.data.length < o.value && (i = this._getOrReturnCtx(e, i), vt(i, {
                        code: Je.too_small,
                        minimum: o.value,
                        type: "string",
                        inclusive: !0,
                        message: o.message
                    }), n.dirty());
                    else if (o.kind === "max") e.data.length > o.value && (i = this._getOrReturnCtx(e, i), vt(i, {
                    code: Je.too_big,
                    maximum: o.value,
                    type: "string",
                    inclusive: !0,
                    message: o.message
                }), n.dirty());
                else if (o.kind === "email") P3.test(e.data) || (i = this._getOrReturnCtx(e, i), vt(i, {
                    validation: "email",
                    code: Je.invalid_string,
                    message: o.message
                }), n.dirty());
                else if (o.kind === "uuid") k3.test(e.data) || (i = this._getOrReturnCtx(e, i), vt(i, {
                    validation: "uuid",
                    code: Je.invalid_string,
                    message: o.message
                }), n.dirty());
                else if (o.kind === "cuid") R3.test(e.data) || (i = this._getOrReturnCtx(e, i), vt(i, {
                    validation: "cuid",
                    code: Je.invalid_string,
                    message: o.message
                }), n.dirty());
                else if (o.kind === "url") try {
                    new URL(e.data)
                } catch {
                    i = this._getOrReturnCtx(e, i), vt(i, {
                        validation: "url",
                        code: Je.invalid_string,
                        message: o.message
                    }), n.dirty()
                } else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(e.data) || (i = this._getOrReturnCtx(e, i), vt(i, {
                    validation: "regex",
                    code: Je.invalid_string,
                    message: o.message
                }), n.dirty())) : o.kind === "trim" ? e.data = e.data.trim() : o.kind === "startsWith" ? e.data.startsWith(o.value) || (i = this._getOrReturnCtx(e, i), vt(i, {
                    code: Je.invalid_string,
                    validation: {
                        startsWith: o.value
                    },
                    message: o.message
                }), n.dirty()) : o.kind === "endsWith" ? e.data.endsWith(o.value) || (i = this._getOrReturnCtx(e, i), vt(i, {
                    code: Je.invalid_string,
                    validation: {
                        endsWith: o.value
                    },
                    message: o.message
                }), n.dirty()) : Jt.assertNever(o);
                return {
                    status: n.value,
                    value: e.data
                }
            }
            _addCheck(e) {
                return new ti({
                    ...this._def,
                    checks: [...this._def.checks, e]
                })
            }
            email(e) {
                return this._addCheck({
                    kind: "email",
                    ...Wt.errToObj(e)
                })
            }
            url(e) {
                return this._addCheck({
                    kind: "url",
                    ...Wt.errToObj(e)
                })
            }
            uuid(e) {
                return this._addCheck({
                    kind: "uuid",
                    ...Wt.errToObj(e)
                })
            }
            cuid(e) {
                return this._addCheck({
                    kind: "cuid",
                    ...Wt.errToObj(e)
                })
            }
            regex(e, t) {
                return this._addCheck({
                    kind: "regex",
                    regex: e,
                    ...Wt.errToObj(t)
                })
            }
            startsWith(e, t) {
                return this._addCheck({
                    kind: "startsWith",
                    value: e,
                    ...Wt.errToObj(t)
                })
            }
            endsWith(e, t) {
                return this._addCheck({
                    kind: "endsWith",
                    value: e,
                    ...Wt.errToObj(t)
                })
            }
            min(e, t) {
                return this._addCheck({
                    kind: "min",
                    value: e,
                    ...Wt.errToObj(t)
                })
            }
            max(e, t) {
                return this._addCheck({
                    kind: "max",
                    value: e,
                    ...Wt.errToObj(t)
                })
            }
            length(e, t) {
                return this.min(e, t).max(e, t)
            }
            get isEmail() {
                return !!this._def.checks.find(e => e.kind === "email")
            }
            get isURL() {
                return !!this._def.checks.find(e => e.kind === "url")
            }
            get isUUID() {
                return !!this._def.checks.find(e => e.kind === "uuid")
            }
            get isCUID() {
                return !!this._def.checks.find(e => e.kind === "cuid")
            }
            get minLength() {
                let e = null;
                for (let t of this._def.checks) t.kind === "min" && (e === null || t.value > e) && (e = t.value);
                return e
            }
            get maxLength() {
                let e = null;
                for (let t of this._def.checks) t.kind === "max" && (e === null || t.value < e) && (e = t.value);
                return e
            }
        };
    ti.create = r => new ti({
        checks: [],
        typeName: At.ZodString,
        ...Ut(r)
    });

    function T3(r, e) {
        let t = (r.toString().split(".")[1] || "").length,
            n = (e.toString().split(".")[1] || "").length,
            i = t > n ? t : n,
            o = parseInt(r.toFixed(i).replace(".", "")),
            a = parseInt(e.toFixed(i).replace(".", ""));
        return o % a / Math.pow(10, i)
    }
    var Bi = class extends Lt {
        constructor() {
            super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
        }
        _parse(e) {
            if (this._getType(e) !== ft.number) {
                let o = this._getOrReturnCtx(e);
                return vt(o, {
                    code: Je.invalid_type,
                    expected: ft.number,
                    received: o.parsedType
                }), kt
            }
            let n, i = new Fr;
            for (let o of this._def.checks) o.kind === "int" ? Jt.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), vt(n, {
                code: Je.invalid_type,
                expected: "integer",
                received: "float",
                message: o.message
            }), i.dirty()) : o.kind === "min" ? (o.inclusive ? e.data < o.value : e.data <= o.value) && (n = this._getOrReturnCtx(e, n), vt(n, {
                code: Je.too_small,
                minimum: o.value,
                type: "number",
                inclusive: o.inclusive,
                message: o.message
            }), i.dirty()) : o.kind === "max" ? (o.inclusive ? e.data > o.value : e.data >= o.value) && (n = this._getOrReturnCtx(e, n), vt(n, {
                code: Je.too_big,
                maximum: o.value,
                type: "number",
                inclusive: o.inclusive,
                message: o.message
            }), i.dirty()) : o.kind === "multipleOf" ? T3(e.data, o.value) !== 0 && (n = this._getOrReturnCtx(e, n), vt(n, {
                code: Je.not_multiple_of,
                multipleOf: o.value,
                message: o.message
            }), i.dirty()) : Jt.assertNever(o);
            return {
                status: i.value,
                value: e.data
            }
        }
        gte(e, t) {
            return this.setLimit("min", e, !0, Wt.toString(t))
        }
        gt(e, t) {
            return this.setLimit("min", e, !1, Wt.toString(t))
        }
        lte(e, t) {
            return this.setLimit("max", e, !0, Wt.toString(t))
        }
        lt(e, t) {
            return this.setLimit("max", e, !1, Wt.toString(t))
        }
        setLimit(e, t, n, i) {
            return new Bi({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: e,
                    value: t,
                    inclusive: n,
                    message: Wt.toString(i)
                }]
            })
        }
        _addCheck(e) {
            return new Bi({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        int(e) {
            return this._addCheck({
                kind: "int",
                message: Wt.toString(e)
            })
        }
        positive(e) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !1,
                message: Wt.toString(e)
            })
        }
        negative(e) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !1,
                message: Wt.toString(e)
            })
        }
        nonpositive(e) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !0,
                message: Wt.toString(e)
            })
        }
        nonnegative(e) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !0,
                message: Wt.toString(e)
            })
        }
        multipleOf(e, t) {
            return this._addCheck({
                kind: "multipleOf",
                value: e,
                message: Wt.toString(t)
            })
        }
        get minValue() {
            let e = null;
            for (let t of this._def.checks) t.kind === "min" && (e === null || t.value > e) && (e = t.value);
            return e
        }
        get maxValue() {
            let e = null;
            for (let t of this._def.checks) t.kind === "max" && (e === null || t.value < e) && (e = t.value);
            return e
        }
        get isInt() {
            return !!this._def.checks.find(e => e.kind === "int")
        }
    };
    Bi.create = r => new Bi({
        checks: [],
        typeName: At.ZodNumber,
        ...Ut(r)
    });
    var es = class extends Lt {
        _parse(e) {
            if (this._getType(e) !== ft.bigint) {
                let n = this._getOrReturnCtx(e);
                return vt(n, {
                    code: Je.invalid_type,
                    expected: ft.bigint,
                    received: n.parsedType
                }), kt
            }
            return sn(e.data)
        }
    };
    es.create = r => new es({
        typeName: At.ZodBigInt,
        ...Ut(r)
    });
    var ts = class extends Lt {
        _parse(e) {
            if (this._getType(e) !== ft.boolean) {
                let n = this._getOrReturnCtx(e);
                return vt(n, {
                    code: Je.invalid_type,
                    expected: ft.boolean,
                    received: n.parsedType
                }), kt
            }
            return sn(e.data)
        }
    };
    ts.create = r => new ts({
        typeName: At.ZodBoolean,
        ...Ut(r)
    });
    var Xi = class extends Lt {
        _parse(e) {
            if (this._getType(e) !== ft.date) {
                let o = this._getOrReturnCtx(e);
                return vt(o, {
                    code: Je.invalid_type,
                    expected: ft.date,
                    received: o.parsedType
                }), kt
            }
            if (isNaN(e.data.getTime())) {
                let o = this._getOrReturnCtx(e);
                return vt(o, {
                    code: Je.invalid_date
                }), kt
            }
            let n = new Fr,
                i;
            for (let o of this._def.checks) o.kind === "min" ? e.data.getTime() < o.value && (i = this._getOrReturnCtx(e, i), vt(i, {
                code: Je.too_small,
                message: o.message,
                inclusive: !0,
                minimum: o.value,
                type: "date"
            }), n.dirty()) : o.kind === "max" ? e.data.getTime() > o.value && (i = this._getOrReturnCtx(e, i), vt(i, {
                code: Je.too_big,
                message: o.message,
                inclusive: !0,
                maximum: o.value,
                type: "date"
            }), n.dirty()) : Jt.assertNever(o);
            return {
                status: n.value,
                value: new Date(e.data.getTime())
            }
        }
        _addCheck(e) {
            return new Xi({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        min(e, t) {
            return this._addCheck({
                kind: "min",
                value: e.getTime(),
                message: Wt.toString(t)
            })
        }
        max(e, t) {
            return this._addCheck({
                kind: "max",
                value: e.getTime(),
                message: Wt.toString(t)
            })
        }
        get minDate() {
            let e = null;
            for (let t of this._def.checks) t.kind === "min" && (e === null || t.value > e) && (e = t.value);
            return e != null ? new Date(e) : null
        }
        get maxDate() {
            let e = null;
            for (let t of this._def.checks) t.kind === "max" && (e === null || t.value < e) && (e = t.value);
            return e != null ? new Date(e) : null
        }
    };
    Xi.create = r => new Xi({
        checks: [],
        typeName: At.ZodDate,
        ...Ut(r)
    });
    var rs = class extends Lt {
        _parse(e) {
            if (this._getType(e) !== ft.undefined) {
                let n = this._getOrReturnCtx(e);
                return vt(n, {
                    code: Je.invalid_type,
                    expected: ft.undefined,
                    received: n.parsedType
                }), kt
            }
            return sn(e.data)
        }
    };
    rs.create = r => new rs({
        typeName: At.ZodUndefined,
        ...Ut(r)
    });
    var ns = class extends Lt {
        _parse(e) {
            if (this._getType(e) !== ft.null) {
                let n = this._getOrReturnCtx(e);
                return vt(n, {
                    code: Je.invalid_type,
                    expected: ft.null,
                    received: n.parsedType
                }), kt
            }
            return sn(e.data)
        }
    };
    ns.create = r => new ns({
        typeName: At.ZodNull,
        ...Ut(r)
    });
    var Qi = class extends Lt {
        constructor() {
            super(...arguments), this._any = !0
        }
        _parse(e) {
            return sn(e.data)
        }
    };
    Qi.create = r => new Qi({
        typeName: At.ZodAny,
        ...Ut(r)
    });
    var Ii = class extends Lt {
        constructor() {
            super(...arguments), this._unknown = !0
        }
        _parse(e) {
            return sn(e.data)
        }
    };
    Ii.create = r => new Ii({
        typeName: At.ZodUnknown,
        ...Ut(r)
    });
    var Cn = class extends Lt {
        _parse(e) {
            let t = this._getOrReturnCtx(e);
            return vt(t, {
                code: Je.invalid_type,
                expected: ft.never,
                received: t.parsedType
            }), kt
        }
    };
    Cn.create = r => new Cn({
        typeName: At.ZodNever,
        ...Ut(r)
    });
    var is = class extends Lt {
        _parse(e) {
            if (this._getType(e) !== ft.undefined) {
                let n = this._getOrReturnCtx(e);
                return vt(n, {
                    code: Je.invalid_type,
                    expected: ft.void,
                    received: n.parsedType
                }), kt
            }
            return sn(e.data)
        }
    };
    is.create = r => new is({
        typeName: At.ZodVoid,
        ...Ut(r)
    });
    var Bn = class extends Lt {
        _parse(e) {
            let {
                ctx: t,
                status: n
            } = this._processInputParams(e), i = this._def;
            if (t.parsedType !== ft.array) return vt(t, {
                code: Je.invalid_type,
                expected: ft.array,
                received: t.parsedType
            }), kt;
            if (i.minLength !== null && t.data.length < i.minLength.value && (vt(t, {
                    code: Je.too_small,
                    minimum: i.minLength.value,
                    type: "array",
                    inclusive: !0,
                    message: i.minLength.message
                }), n.dirty()), i.maxLength !== null && t.data.length > i.maxLength.value && (vt(t, {
                    code: Je.too_big,
                    maximum: i.maxLength.value,
                    type: "array",
                    inclusive: !0,
                    message: i.maxLength.message
                }), n.dirty()), t.common.async) return Promise.all(t.data.map((a, y) => i.type._parseAsync(new In(t, a, t.path, y)))).then(a => Fr.mergeArray(n, a));
            let o = t.data.map((a, y) => i.type._parseSync(new In(t, a, t.path, y)));
            return Fr.mergeArray(n, o)
        }
        get element() {
            return this._def.type
        }
        min(e, t) {
            return new Bn({
                ...this._def,
                minLength: {
                    value: e,
                    message: Wt.toString(t)
                }
            })
        }
        max(e, t) {
            return new Bn({
                ...this._def,
                maxLength: {
                    value: e,
                    message: Wt.toString(t)
                }
            })
        }
        length(e, t) {
            return this.min(e, t).max(e, t)
        }
        nonempty(e) {
            return this.min(1, e)
        }
    };
    Bn.create = (r, e) => new Bn({
        type: r,
        minLength: null,
        maxLength: null,
        typeName: At.ZodArray,
        ...Ut(e)
    });
    var rf;
    (function(r) {
        r.mergeShapes = (e, t) => ({
            ...e,
            ...t
        })
    })(rf || (rf = {}));
    var ad = r => e => new ar({
        ...r,
        shape: () => ({
            ...r.shape(),
            ...e
        })
    });

    function Qo(r) {
        if (r instanceof ar) {
            let e = {};
            for (let t in r.shape) {
                let n = r.shape[t];
                e[t] = An.create(Qo(n))
            }
            return new ar({
                ...r._def,
                shape: () => e
            })
        } else return r instanceof Bn ? Bn.create(Qo(r.element)) : r instanceof An ? An.create(Qo(r.unwrap())) : r instanceof ki ? ki.create(Qo(r.unwrap())) : r instanceof Rn ? Rn.create(r.items.map(e => Qo(e))) : r
    }
    var ar = class extends Lt {
        constructor() {
            super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = ad(this._def), this.extend = ad(this._def)
        }
        _getCached() {
            if (this._cached !== null) return this._cached;
            let e = this._def.shape(),
                t = Jt.objectKeys(e);
            return this._cached = {
                shape: e,
                keys: t
            }
        }
        _parse(e) {
            if (this._getType(e) !== ft.object) {
                let E = this._getOrReturnCtx(e);
                return vt(E, {
                    code: Je.invalid_type,
                    expected: ft.object,
                    received: E.parsedType
                }), kt
            }
            let {
                status: n,
                ctx: i
            } = this._processInputParams(e), {
                shape: o,
                keys: a
            } = this._getCached(), y = [];
            if (!(this._def.catchall instanceof Cn && this._def.unknownKeys === "strip"))
                for (let E in i.data) a.includes(E) || y.push(E);
            let g = [];
            for (let E of a) {
                let A = o[E],
                    I = i.data[E];
                g.push({
                    key: {
                        status: "valid",
                        value: E
                    },
                    value: A._parse(new In(i, I, i.path, E)),
                    alwaysSet: E in i.data
                })
            }
            if (this._def.catchall instanceof Cn) {
                let E = this._def.unknownKeys;
                if (E === "passthrough")
                    for (let A of y) g.push({
                        key: {
                            status: "valid",
                            value: A
                        },
                        value: {
                            status: "valid",
                            value: i.data[A]
                        }
                    });
                else if (E === "strict") y.length > 0 && (vt(i, {
                    code: Je.unrecognized_keys,
                    keys: y
                }), n.dirty());
                else if (E !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.")
            } else {
                let E = this._def.catchall;
                for (let A of y) {
                    let I = i.data[A];
                    g.push({
                        key: {
                            status: "valid",
                            value: A
                        },
                        value: E._parse(new In(i, I, i.path, A)),
                        alwaysSet: A in i.data
                    })
                }
            }
            return i.common.async ? Promise.resolve().then(async () => {
                let E = [];
                for (let A of g) {
                    let I = await A.key;
                    E.push({
                        key: I,
                        value: await A.value,
                        alwaysSet: A.alwaysSet
                    })
                }
                return E
            }).then(E => Fr.mergeObjectSync(n, E)) : Fr.mergeObjectSync(n, g)
        }
        get shape() {
            return this._def.shape()
        }
        strict(e) {
            return Wt.errToObj, new ar({
                ...this._def,
                unknownKeys: "strict",
                ...e !== void 0 ? {
                    errorMap: (t, n) => {
                        var i, o, a, y;
                        let g = (a = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, t, n).message) !== null && a !== void 0 ? a : n.defaultError;
                        return t.code === "unrecognized_keys" ? {
                            message: (y = Wt.errToObj(e).message) !== null && y !== void 0 ? y : g
                        } : {
                            message: g
                        }
                    }
                } : {}
            })
        }
        strip() {
            return new ar({
                ...this._def,
                unknownKeys: "strip"
            })
        }
        passthrough() {
            return new ar({
                ...this._def,
                unknownKeys: "passthrough"
            })
        }
        setKey(e, t) {
            return this.augment({
                [e]: t
            })
        }
        merge(e) {
            return new ar({
                unknownKeys: e._def.unknownKeys,
                catchall: e._def.catchall,
                shape: () => rf.mergeShapes(this._def.shape(), e._def.shape()),
                typeName: At.ZodObject
            })
        }
        catchall(e) {
            return new ar({
                ...this._def,
                catchall: e
            })
        }
        pick(e) {
            let t = {};
            return Jt.objectKeys(e).map(n => {
                this.shape[n] && (t[n] = this.shape[n])
            }), new ar({
                ...this._def,
                shape: () => t
            })
        }
        omit(e) {
            let t = {};
            return Jt.objectKeys(this.shape).map(n => {
                Jt.objectKeys(e).indexOf(n) === -1 && (t[n] = this.shape[n])
            }), new ar({
                ...this._def,
                shape: () => t
            })
        }
        deepPartial() {
            return Qo(this)
        }
        partial(e) {
            let t = {};
            if (e) return Jt.objectKeys(this.shape).map(n => {
                Jt.objectKeys(e).indexOf(n) === -1 ? t[n] = this.shape[n] : t[n] = this.shape[n].optional()
            }), new ar({
                ...this._def,
                shape: () => t
            });
            for (let n in this.shape) {
                let i = this.shape[n];
                t[n] = i.optional()
            }
            return new ar({
                ...this._def,
                shape: () => t
            })
        }
        required() {
            let e = {};
            for (let t in this.shape) {
                let i = this.shape[t];
                for (; i instanceof An;) i = i._def.innerType;
                e[t] = i
            }
            return new ar({
                ...this._def,
                shape: () => e
            })
        }
        keyof() {
            return cd(Jt.objectKeys(this.shape))
        }
    };
    ar.create = (r, e) => new ar({
        shape: () => r,
        unknownKeys: "strip",
        catchall: Cn.create(),
        typeName: At.ZodObject,
        ...Ut(e)
    });
    ar.strictCreate = (r, e) => new ar({
        shape: () => r,
        unknownKeys: "strict",
        catchall: Cn.create(),
        typeName: At.ZodObject,
        ...Ut(e)
    });
    ar.lazycreate = (r, e) => new ar({
        shape: r,
        unknownKeys: "strip",
        catchall: Cn.create(),
        typeName: At.ZodObject,
        ...Ut(e)
    });
    var Io = class extends Lt {
        _parse(e) {
            let {
                ctx: t
            } = this._processInputParams(e), n = this._def.options;

            function i(o) {
                for (let y of o)
                    if (y.result.status === "valid") return y.result;
                for (let y of o)
                    if (y.result.status === "dirty") return t.common.issues.push(...y.ctx.common.issues), y.result;
                let a = o.map(y => new vn(y.ctx.common.issues));
                return vt(t, {
                    code: Je.invalid_union,
                    unionErrors: a
                }), kt
            }
            if (t.common.async) return Promise.all(n.map(async o => {
                let a = {
                    ...t,
                    common: {
                        ...t.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await o._parseAsync({
                        data: t.data,
                        path: t.path,
                        parent: a
                    }),
                    ctx: a
                }
            })).then(i); {
                let o, a = [];
                for (let g of n) {
                    let E = {
                            ...t,
                            common: {
                                ...t.common,
                                issues: []
                            },
                            parent: null
                        },
                        A = g._parseSync({
                            data: t.data,
                            path: t.path,
                            parent: E
                        });
                    if (A.status === "valid") return A;
                    A.status === "dirty" && !o && (o = {
                        result: A,
                        ctx: E
                    }), E.common.issues.length && a.push(E.common.issues)
                }
                if (o) return t.common.issues.push(...o.ctx.common.issues), o.result;
                let y = a.map(g => new vn(g));
                return vt(t, {
                    code: Je.invalid_union,
                    unionErrors: y
                }), kt
            }
        }
        get options() {
            return this._def.options
        }
    };
    Io.create = (r, e) => new Io({
        options: r,
        typeName: At.ZodUnion,
        ...Ut(e)
    });
    var os = class extends Lt {
        _parse(e) {
            let {
                ctx: t
            } = this._processInputParams(e);
            if (t.parsedType !== ft.object) return vt(t, {
                code: Je.invalid_type,
                expected: ft.object,
                received: t.parsedType
            }), kt;
            let n = this.discriminator,
                i = t.data[n],
                o = this.options.get(i);
            return o ? t.common.async ? o._parseAsync({
                data: t.data,
                path: t.path,
                parent: t
            }) : o._parseSync({
                data: t.data,
                path: t.path,
                parent: t
            }) : (vt(t, {
                code: Je.invalid_union_discriminator,
                options: this.validDiscriminatorValues,
                path: [n]
            }), kt)
        }
        get discriminator() {
            return this._def.discriminator
        }
        get validDiscriminatorValues() {
            return Array.from(this.options.keys())
        }
        get options() {
            return this._def.options
        }
        static create(e, t, n) {
            let i = new Map;
            try {
                t.forEach(o => {
                    let a = o.shape[e].value;
                    i.set(a, o)
                })
            } catch {
                throw new Error("The discriminator value could not be extracted from all the provided schemas")
            }
            if (i.size !== t.length) throw new Error("Some of the discriminator values are not unique");
            return new os({
                typeName: At.ZodDiscriminatedUnion,
                discriminator: e,
                options: i,
                ...Ut(n)
            })
        }
    };

    function dh(r, e) {
        let t = Yi(r),
            n = Yi(e);
        if (r === e) return {
            valid: !0,
            data: r
        };
        if (t === ft.object && n === ft.object) {
            let i = Jt.objectKeys(e),
                o = Jt.objectKeys(r).filter(y => i.indexOf(y) !== -1),
                a = {
                    ...r,
                    ...e
                };
            for (let y of o) {
                let g = dh(r[y], e[y]);
                if (!g.valid) return {
                    valid: !1
                };
                a[y] = g.data
            }
            return {
                valid: !0,
                data: a
            }
        } else if (t === ft.array && n === ft.array) {
            if (r.length !== e.length) return {
                valid: !1
            };
            let i = [];
            for (let o = 0; o < r.length; o++) {
                let a = r[o],
                    y = e[o],
                    g = dh(a, y);
                if (!g.valid) return {
                    valid: !1
                };
                i.push(g.data)
            }
            return {
                valid: !0,
                data: i
            }
        } else return t === ft.date && n === ft.date && +r == +e ? {
            valid: !0,
            data: r
        } : {
            valid: !1
        }
    }
    var Bo = class extends Lt {
        _parse(e) {
            let {
                status: t,
                ctx: n
            } = this._processInputParams(e), i = (o, a) => {
                if (ch(o) || ch(a)) return kt;
                let y = dh(o.value, a.value);
                return y.valid ? ((hh(o) || hh(a)) && t.dirty(), {
                    status: t.value,
                    value: y.data
                }) : (vt(n, {
                    code: Je.invalid_intersection_types
                }), kt)
            };
            return n.common.async ? Promise.all([this._def.left._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }), this._def.right._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            })]).then(([o, a]) => i(o, a)) : i(this._def.left._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            }), this._def.right._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            }))
        }
    };
    Bo.create = (r, e, t) => new Bo({
        left: r,
        right: e,
        typeName: At.ZodIntersection,
        ...Ut(t)
    });
    var Rn = class extends Lt {
        _parse(e) {
            let {
                status: t,
                ctx: n
            } = this._processInputParams(e);
            if (n.parsedType !== ft.array) return vt(n, {
                code: Je.invalid_type,
                expected: ft.array,
                received: n.parsedType
            }), kt;
            if (n.data.length < this._def.items.length) return vt(n, {
                code: Je.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                type: "array"
            }), kt;
            !this._def.rest && n.data.length > this._def.items.length && (vt(n, {
                code: Je.too_big,
                maximum: this._def.items.length,
                inclusive: !0,
                type: "array"
            }), t.dirty());
            let o = n.data.map((a, y) => {
                let g = this._def.items[y] || this._def.rest;
                return g ? g._parse(new In(n, a, n.path, y)) : null
            }).filter(a => !!a);
            return n.common.async ? Promise.all(o).then(a => Fr.mergeArray(t, a)) : Fr.mergeArray(t, o)
        }
        get items() {
            return this._def.items
        }
        rest(e) {
            return new Rn({
                ...this._def,
                rest: e
            })
        }
    };
    Rn.create = (r, e) => {
        if (!Array.isArray(r)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new Rn({
            items: r,
            typeName: At.ZodTuple,
            rest: null,
            ...Ut(e)
        })
    };
    var Ro = class extends Lt {
            get keySchema() {
                return this._def.keyType
            }
            get valueSchema() {
                return this._def.valueType
            }
            _parse(e) {
                let {
                    status: t,
                    ctx: n
                } = this._processInputParams(e);
                if (n.parsedType !== ft.object) return vt(n, {
                    code: Je.invalid_type,
                    expected: ft.object,
                    received: n.parsedType
                }), kt;
                let i = [],
                    o = this._def.keyType,
                    a = this._def.valueType;
                for (let y in n.data) i.push({
                    key: o._parse(new In(n, y, n.path, y)),
                    value: a._parse(new In(n, n.data[y], n.path, y))
                });
                return n.common.async ? Fr.mergeObjectAsync(t, i) : Fr.mergeObjectSync(t, i)
            }
            get element() {
                return this._def.valueType
            }
            static create(e, t, n) {
                return t instanceof Lt ? new Ro({
                    keyType: e,
                    valueType: t,
                    typeName: At.ZodRecord,
                    ...Ut(n)
                }) : new Ro({
                    keyType: ti.create(),
                    valueType: e,
                    typeName: At.ZodRecord,
                    ...Ut(t)
                })
            }
        },
        ss = class extends Lt {
            _parse(e) {
                let {
                    status: t,
                    ctx: n
                } = this._processInputParams(e);
                if (n.parsedType !== ft.map) return vt(n, {
                    code: Je.invalid_type,
                    expected: ft.map,
                    received: n.parsedType
                }), kt;
                let i = this._def.keyType,
                    o = this._def.valueType,
                    a = [...n.data.entries()].map(([y, g], E) => ({
                        key: i._parse(new In(n, y, n.path, [E, "key"])),
                        value: o._parse(new In(n, g, n.path, [E, "value"]))
                    }));
                if (n.common.async) {
                    let y = new Map;
                    return Promise.resolve().then(async () => {
                        for (let g of a) {
                            let E = await g.key,
                                A = await g.value;
                            if (E.status === "aborted" || A.status === "aborted") return kt;
                            (E.status === "dirty" || A.status === "dirty") && t.dirty(), y.set(E.value, A.value)
                        }
                        return {
                            status: t.value,
                            value: y
                        }
                    })
                } else {
                    let y = new Map;
                    for (let g of a) {
                        let E = g.key,
                            A = g.value;
                        if (E.status === "aborted" || A.status === "aborted") return kt;
                        (E.status === "dirty" || A.status === "dirty") && t.dirty(), y.set(E.value, A.value)
                    }
                    return {
                        status: t.value,
                        value: y
                    }
                }
            }
        };
    ss.create = (r, e, t) => new ss({
        valueType: e,
        keyType: r,
        typeName: At.ZodMap,
        ...Ut(t)
    });
    var Ri = class extends Lt {
        _parse(e) {
            let {
                status: t,
                ctx: n
            } = this._processInputParams(e);
            if (n.parsedType !== ft.set) return vt(n, {
                code: Je.invalid_type,
                expected: ft.set,
                received: n.parsedType
            }), kt;
            let i = this._def;
            i.minSize !== null && n.data.size < i.minSize.value && (vt(n, {
                code: Je.too_small,
                minimum: i.minSize.value,
                type: "set",
                inclusive: !0,
                message: i.minSize.message
            }), t.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (vt(n, {
                code: Je.too_big,
                maximum: i.maxSize.value,
                type: "set",
                inclusive: !0,
                message: i.maxSize.message
            }), t.dirty());
            let o = this._def.valueType;

            function a(g) {
                let E = new Set;
                for (let A of g) {
                    if (A.status === "aborted") return kt;
                    A.status === "dirty" && t.dirty(), E.add(A.value)
                }
                return {
                    status: t.value,
                    value: E
                }
            }
            let y = [...n.data.values()].map((g, E) => o._parse(new In(n, g, n.path, E)));
            return n.common.async ? Promise.all(y).then(g => a(g)) : a(y)
        }
        min(e, t) {
            return new Ri({
                ...this._def,
                minSize: {
                    value: e,
                    message: Wt.toString(t)
                }
            })
        }
        max(e, t) {
            return new Ri({
                ...this._def,
                maxSize: {
                    value: e,
                    message: Wt.toString(t)
                }
            })
        }
        size(e, t) {
            return this.min(e, t).max(e, t)
        }
        nonempty(e) {
            return this.min(1, e)
        }
    };
    Ri.create = (r, e) => new Ri({
        valueType: r,
        minSize: null,
        maxSize: null,
        typeName: At.ZodSet,
        ...Ut(e)
    });
    var Ji = class extends Lt {
            constructor() {
                super(...arguments), this.validate = this.implement
            }
            _parse(e) {
                let {
                    ctx: t
                } = this._processInputParams(e);
                if (t.parsedType !== ft.function) return vt(t, {
                    code: Je.invalid_type,
                    expected: ft.function,
                    received: t.parsedType
                }), kt;

                function n(y, g) {
                    return ef({
                        data: y,
                        path: t.path,
                        errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Qa(), aa].filter(E => !!E),
                        issueData: {
                            code: Je.invalid_arguments,
                            argumentsError: g
                        }
                    })
                }

                function i(y, g) {
                    return ef({
                        data: y,
                        path: t.path,
                        errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Qa(), aa].filter(E => !!E),
                        issueData: {
                            code: Je.invalid_return_type,
                            returnTypeError: g
                        }
                    })
                }
                let o = {
                        errorMap: t.common.contextualErrorMap
                    },
                    a = t.data;
                return this._def.returns instanceof eo ? sn(async (...y) => {
                    let g = new vn([]),
                        E = await this._def.args.parseAsync(y, o).catch(q => {
                            throw g.addIssue(n(y, q)), g
                        }),
                        A = await a(...E);
                    return await this._def.returns._def.type.parseAsync(A, o).catch(q => {
                        throw g.addIssue(i(A, q)), g
                    })
                }) : sn((...y) => {
                    let g = this._def.args.safeParse(y, o);
                    if (!g.success) throw new vn([n(y, g.error)]);
                    let E = a(...g.data),
                        A = this._def.returns.safeParse(E, o);
                    if (!A.success) throw new vn([i(E, A.error)]);
                    return A.data
                })
            }
            parameters() {
                return this._def.args
            }
            returnType() {
                return this._def.returns
            }
            args(...e) {
                return new Ji({
                    ...this._def,
                    args: Rn.create(e).rest(Ii.create())
                })
            }
            returns(e) {
                return new Ji({
                    ...this._def,
                    returns: e
                })
            }
            implement(e) {
                return this.parse(e)
            }
            strictImplement(e) {
                return this.parse(e)
            }
            static create(e, t, n) {
                return new Ji({
                    args: e || Rn.create([]).rest(Ii.create()),
                    returns: t || Ii.create(),
                    typeName: At.ZodFunction,
                    ...Ut(n)
                })
            }
        },
        as = class extends Lt {
            get schema() {
                return this._def.getter()
            }
            _parse(e) {
                let {
                    ctx: t
                } = this._processInputParams(e);
                return this._def.getter()._parse({
                    data: t.data,
                    path: t.path,
                    parent: t
                })
            }
        };
    as.create = (r, e) => new as({
        getter: r,
        typeName: At.ZodLazy,
        ...Ut(e)
    });
    var fs = class extends Lt {
        _parse(e) {
            if (e.data !== this._def.value) {
                let t = this._getOrReturnCtx(e);
                return vt(t, {
                    code: Je.invalid_literal,
                    expected: this._def.value
                }), kt
            }
            return {
                status: "valid",
                value: e.data
            }
        }
        get value() {
            return this._def.value
        }
    };
    fs.create = (r, e) => new fs({
        value: r,
        typeName: At.ZodLiteral,
        ...Ut(e)
    });

    function cd(r, e) {
        return new us({
            values: r,
            typeName: At.ZodEnum,
            ...Ut(e)
        })
    }
    var us = class extends Lt {
        _parse(e) {
            if (typeof e.data != "string") {
                let t = this._getOrReturnCtx(e),
                    n = this._def.values;
                return vt(t, {
                    expected: Jt.joinValues(n),
                    received: t.parsedType,
                    code: Je.invalid_type
                }), kt
            }
            if (this._def.values.indexOf(e.data) === -1) {
                let t = this._getOrReturnCtx(e),
                    n = this._def.values;
                return vt(t, {
                    received: t.data,
                    code: Je.invalid_enum_value,
                    options: n
                }), kt
            }
            return sn(e.data)
        }
        get options() {
            return this._def.values
        }
        get enum() {
            let e = {};
            for (let t of this._def.values) e[t] = t;
            return e
        }
        get Values() {
            let e = {};
            for (let t of this._def.values) e[t] = t;
            return e
        }
        get Enum() {
            let e = {};
            for (let t of this._def.values) e[t] = t;
            return e
        }
    };
    us.create = cd;
    var cs = class extends Lt {
        _parse(e) {
            let t = Jt.getValidEnumValues(this._def.values),
                n = this._getOrReturnCtx(e);
            if (n.parsedType !== ft.string && n.parsedType !== ft.number) {
                let i = Jt.objectValues(t);
                return vt(n, {
                    expected: Jt.joinValues(i),
                    received: n.parsedType,
                    code: Je.invalid_type
                }), kt
            }
            if (t.indexOf(e.data) === -1) {
                let i = Jt.objectValues(t);
                return vt(n, {
                    received: n.data,
                    code: Je.invalid_enum_value,
                    options: i
                }), kt
            }
            return sn(e.data)
        }
        get enum() {
            return this._def.values
        }
    };
    cs.create = (r, e) => new cs({
        values: r,
        typeName: At.ZodNativeEnum,
        ...Ut(e)
    });
    var eo = class extends Lt {
        _parse(e) {
            let {
                ctx: t
            } = this._processInputParams(e);
            if (t.parsedType !== ft.promise && t.common.async === !1) return vt(t, {
                code: Je.invalid_type,
                expected: ft.promise,
                received: t.parsedType
            }), kt;
            let n = t.parsedType === ft.promise ? t.data : Promise.resolve(t.data);
            return sn(n.then(i => this._def.type.parseAsync(i, {
                path: t.path,
                errorMap: t.common.contextualErrorMap
            })))
        }
    };
    eo.create = (r, e) => new eo({
        type: r,
        typeName: At.ZodPromise,
        ...Ut(e)
    });
    var kn = class extends Lt {
        innerType() {
            return this._def.schema
        }
        _parse(e) {
            let {
                status: t,
                ctx: n
            } = this._processInputParams(e), i = this._def.effect || null;
            if (i.type === "preprocess") {
                let a = i.transform(n.data);
                return n.common.async ? Promise.resolve(a).then(y => this._def.schema._parseAsync({
                    data: y,
                    path: n.path,
                    parent: n
                })) : this._def.schema._parseSync({
                    data: a,
                    path: n.path,
                    parent: n
                })
            }
            let o = {
                addIssue: a => {
                    vt(n, a), a.fatal ? t.abort() : t.dirty()
                },
                get path() {
                    return n.path
                }
            };
            if (o.addIssue = o.addIssue.bind(o), i.type === "refinement") {
                let a = y => {
                    let g = i.refinement(y, o);
                    if (n.common.async) return Promise.resolve(g);
                    if (g instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    return y
                };
                if (n.common.async === !1) {
                    let y = this._def.schema._parseSync({
                        data: n.data,
                        path: n.path,
                        parent: n
                    });
                    return y.status === "aborted" ? kt : (y.status === "dirty" && t.dirty(), a(y.value), {
                        status: t.value,
                        value: y.value
                    })
                } else return this._def.schema._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }).then(y => y.status === "aborted" ? kt : (y.status === "dirty" && t.dirty(), a(y.value).then(() => ({
                    status: t.value,
                    value: y.value
                }))))
            }
            if (i.type === "transform")
                if (n.common.async === !1) {
                    let a = this._def.schema._parseSync({
                        data: n.data,
                        path: n.path,
                        parent: n
                    });
                    if (!tf(a)) return a;
                    let y = i.transform(a.value, o);
                    if (y instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                    return {
                        status: t.value,
                        value: y
                    }
                } else return this._def.schema._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }).then(a => tf(a) ? Promise.resolve(i.transform(a.value, o)).then(y => ({
                    status: t.value,
                    value: y
                })) : a);
            Jt.assertNever(i)
        }
    };
    kn.create = (r, e, t) => new kn({
        schema: r,
        typeName: At.ZodEffects,
        effect: e,
        ...Ut(t)
    });
    kn.createWithPreprocess = (r, e, t) => new kn({
        schema: e,
        effect: {
            type: "preprocess",
            transform: r
        },
        typeName: At.ZodEffects,
        ...Ut(t)
    });
    var An = class extends Lt {
        _parse(e) {
            return this._getType(e) === ft.undefined ? sn(void 0) : this._def.innerType._parse(e)
        }
        unwrap() {
            return this._def.innerType
        }
    };
    An.create = (r, e) => new An({
        innerType: r,
        typeName: At.ZodOptional,
        ...Ut(e)
    });
    var ki = class extends Lt {
        _parse(e) {
            return this._getType(e) === ft.null ? sn(null) : this._def.innerType._parse(e)
        }
        unwrap() {
            return this._def.innerType
        }
    };
    ki.create = (r, e) => new ki({
        innerType: r,
        typeName: At.ZodNullable,
        ...Ut(e)
    });
    var fa = class extends Lt {
        _parse(e) {
            let {
                ctx: t
            } = this._processInputParams(e), n = t.data;
            return t.parsedType === ft.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
                data: n,
                path: t.path,
                parent: t
            })
        }
        removeDefault() {
            return this._def.innerType
        }
    };
    fa.create = (r, e) => new An({
        innerType: r,
        typeName: At.ZodOptional,
        ...Ut(e)
    });
    var hs = class extends Lt {
        _parse(e) {
            if (this._getType(e) !== ft.nan) {
                let n = this._getOrReturnCtx(e);
                return vt(n, {
                    code: Je.invalid_type,
                    expected: ft.nan,
                    received: n.parsedType
                }), kt
            }
            return {
                status: "valid",
                value: e.data
            }
        }
    };
    hs.create = r => new hs({
        typeName: At.ZodNaN,
        ...Ut(r)
    });
    var L3 = Symbol("zod_brand"),
        nf = class extends Lt {
            _parse(e) {
                let {
                    ctx: t
                } = this._processInputParams(e), n = t.data;
                return this._def.type._parse({
                    data: n,
                    path: t.path,
                    parent: t
                })
            }
            unwrap() {
                return this._def.type
            }
        },
        hd = (r, e = {}, t) => r ? Qi.create().superRefine((n, i) => {
            if (!r(n)) {
                let o = typeof e == "function" ? e(n) : e,
                    a = typeof o == "string" ? {
                        message: o
                    } : o;
                i.addIssue({
                    code: "custom",
                    ...a,
                    fatal: t
                })
            }
        }) : Qi.create(),
        z3 = {
            object: ar.lazycreate
        },
        At;
    (function(r) {
        r.ZodString = "ZodString", r.ZodNumber = "ZodNumber", r.ZodNaN = "ZodNaN", r.ZodBigInt = "ZodBigInt", r.ZodBoolean = "ZodBoolean", r.ZodDate = "ZodDate", r.ZodUndefined = "ZodUndefined", r.ZodNull = "ZodNull", r.ZodAny = "ZodAny", r.ZodUnknown = "ZodUnknown", r.ZodNever = "ZodNever", r.ZodVoid = "ZodVoid", r.ZodArray = "ZodArray", r.ZodObject = "ZodObject", r.ZodUnion = "ZodUnion", r.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r.ZodIntersection = "ZodIntersection", r.ZodTuple = "ZodTuple", r.ZodRecord = "ZodRecord", r.ZodMap = "ZodMap", r.ZodSet = "ZodSet", r.ZodFunction = "ZodFunction", r.ZodLazy = "ZodLazy", r.ZodLiteral = "ZodLiteral", r.ZodEnum = "ZodEnum", r.ZodEffects = "ZodEffects", r.ZodNativeEnum = "ZodNativeEnum", r.ZodOptional = "ZodOptional", r.ZodNullable = "ZodNullable", r.ZodDefault = "ZodDefault", r.ZodPromise = "ZodPromise", r.ZodBranded = "ZodBranded"
    })(At || (At = {}));
    var U3 = (r, e = {
            message: `Input not instance of ${r.name}`
        }) => hd(t => t instanceof r, e, !0),
        ld = ti.create,
        dd = Bi.create,
        N3 = hs.create,
        q3 = es.create,
        pd = ts.create,
        F3 = Xi.create,
        C3 = rs.create,
        O3 = ns.create,
        D3 = Qi.create,
        K3 = Ii.create,
        $3 = Cn.create,
        j3 = is.create,
        W3 = Bn.create,
        H3 = ar.create,
        V3 = ar.strictCreate,
        G3 = Io.create,
        Z3 = os.create,
        Y3 = Bo.create,
        J3 = Rn.create,
        X3 = Ro.create,
        Q3 = ss.create,
        e6 = Ri.create,
        t6 = Ji.create,
        r6 = as.create,
        n6 = fs.create,
        i6 = us.create,
        o6 = cs.create,
        s6 = eo.create,
        fd = kn.create,
        a6 = An.create,
        f6 = ki.create,
        u6 = kn.createWithPreprocess,
        c6 = () => ld().optional(),
        h6 = () => dd().optional(),
        l6 = () => pd().optional(),
        d6 = kt,
        B = Object.freeze({
            __proto__: null,
            getParsedType: Yi,
            ZodParsedType: ft,
            defaultErrorMap: aa,
            setErrorMap: A3,
            getErrorMap: Qa,
            makeIssue: ef,
            EMPTY_PATH: I3,
            addIssueToContext: vt,
            ParseStatus: Fr,
            INVALID: kt,
            DIRTY: B3,
            OK: sn,
            isAborted: ch,
            isDirty: hh,
            isValid: tf,
            isAsync: lh,
            ZodType: Lt,
            ZodString: ti,
            ZodNumber: Bi,
            ZodBigInt: es,
            ZodBoolean: ts,
            ZodDate: Xi,
            ZodUndefined: rs,
            ZodNull: ns,
            ZodAny: Qi,
            ZodUnknown: Ii,
            ZodNever: Cn,
            ZodVoid: is,
            ZodArray: Bn,
            get objectUtil() {
                return rf
            },
            ZodObject: ar,
            ZodUnion: Io,
            ZodDiscriminatedUnion: os,
            ZodIntersection: Bo,
            ZodTuple: Rn,
            ZodRecord: Ro,
            ZodMap: ss,
            ZodSet: Ri,
            ZodFunction: Ji,
            ZodLazy: as,
            ZodLiteral: fs,
            ZodEnum: us,
            ZodNativeEnum: cs,
            ZodPromise: eo,
            ZodEffects: kn,
            ZodTransformer: kn,
            ZodOptional: An,
            ZodNullable: ki,
            ZodDefault: fa,
            ZodNaN: hs,
            BRAND: L3,
            ZodBranded: nf,
            custom: hd,
            Schema: Lt,
            ZodSchema: Lt,
            late: z3,
            get ZodFirstPartyTypeKind() {
                return At
            },
            any: D3,
            array: W3,
            bigint: q3,
            boolean: pd,
            date: F3,
            discriminatedUnion: Z3,
            effect: fd,
            enum: i6,
            function: t6,
            instanceof: U3,
            intersection: Y3,
            lazy: r6,
            literal: n6,
            map: Q3,
            nan: N3,
            nativeEnum: o6,
            never: $3,
            null: O3,
            nullable: f6,
            number: dd,
            object: H3,
            oboolean: l6,
            onumber: h6,
            optional: a6,
            ostring: c6,
            preprocess: u6,
            promise: s6,
            record: X3,
            set: e6,
            strictObject: V3,
            string: ld,
            transformer: fd,
            tuple: J3,
            undefined: C3,
            union: G3,
            unknown: K3,
            void: j3,
            NEVER: d6,
            ZodIssueCode: Je,
            quotelessJson: M3,
            ZodError: vn
        });
    var yd = "logger/5.6.0";
    var md = !1,
        gd = !1,
        of = {
            debug: 1,
            default: 2,
            info: 2,
            warning: 3,
            error: 4,
            off: 5
        },
        bd = of.default,
        ph = null;

    function p6() {
        try {
            let r = [];
            if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                    try {
                        if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                    } catch {
                        r.push(e)
                    }
                }), r.length) throw new Error("missing " + r.join(", "));
            if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
        } catch (r) {
            return r.message
        }
        return null
    }
    var xd = p6(),
        yh;
    (function(r) {
        r.DEBUG = "DEBUG", r.INFO = "INFO", r.WARNING = "WARNING", r.ERROR = "ERROR", r.OFF = "OFF"
    })(yh || (yh = {}));
    var On;
    (function(r) {
        r.UNKNOWN_ERROR = "UNKNOWN_ERROR", r.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", r.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", r.NETWORK_ERROR = "NETWORK_ERROR", r.SERVER_ERROR = "SERVER_ERROR", r.TIMEOUT = "TIMEOUT", r.BUFFER_OVERRUN = "BUFFER_OVERRUN", r.NUMERIC_FAULT = "NUMERIC_FAULT", r.MISSING_NEW = "MISSING_NEW", r.INVALID_ARGUMENT = "INVALID_ARGUMENT", r.MISSING_ARGUMENT = "MISSING_ARGUMENT", r.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", r.CALL_EXCEPTION = "CALL_EXCEPTION", r.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", r.NONCE_EXPIRED = "NONCE_EXPIRED", r.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", r.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", r.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"
    })(On || (On = {}));
    var vd = "0123456789abcdef",
        er = class {
            constructor(e) {
                Object.defineProperty(this, "version", {
                    enumerable: !0,
                    value: e,
                    writable: !1
                })
            }
            _log(e, t) {
                let n = e.toLowerCase();
                of [n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(bd > of [n]) && console.log.apply(console, t)
            }
            debug(...e) {
                this._log(er.levels.DEBUG, e)
            }
            info(...e) {
                this._log(er.levels.INFO, e)
            }
            warn(...e) {
                this._log(er.levels.WARNING, e)
            }
            makeError(e, t, n) {
                if (gd) return this.makeError("censored error", t, {});
                t || (t = er.errors.UNKNOWN_ERROR), n || (n = {});
                let i = [];
                Object.keys(n).forEach(g => {
                    let E = n[g];
                    try {
                        if (E instanceof Uint8Array) {
                            let A = "";
                            for (let I = 0; I < E.length; I++) A += vd[E[I] >> 4], A += vd[E[I] & 15];
                            i.push(g + "=Uint8Array(0x" + A + ")")
                        } else i.push(g + "=" + JSON.stringify(E))
                    } catch {
                        i.push(g + "=" + JSON.stringify(n[g].toString()))
                    }
                }), i.push(`code=${t}`), i.push(`version=${this.version}`);
                let o = e,
                    a = "";
                switch (t) {
                    case On.NUMERIC_FAULT: {
                        a = "NUMERIC_FAULT";
                        let g = e;
                        switch (g) {
                            case "overflow":
                            case "underflow":
                            case "division-by-zero":
                                a += "-" + g;
                                break;
                            case "negative-power":
                            case "negative-width":
                                a += "-unsupported";
                                break;
                            case "unbound-bitwise-result":
                                a += "-unbound-result";
                                break
                        }
                        break
                    }
                    case On.CALL_EXCEPTION:
                    case On.INSUFFICIENT_FUNDS:
                    case On.MISSING_NEW:
                    case On.NONCE_EXPIRED:
                    case On.REPLACEMENT_UNDERPRICED:
                    case On.TRANSACTION_REPLACED:
                    case On.UNPREDICTABLE_GAS_LIMIT:
                        a = t;
                        break
                }
                a && (e += " [ See: https://links.ethers.org/v5-errors-" + a + " ]"), i.length && (e += " (" + i.join(", ") + ")");
                let y = new Error(e);
                return y.reason = o, y.code = t, Object.keys(n).forEach(function(g) {
                    y[g] = n[g]
                }), y
            }
            throwError(e, t, n) {
                throw this.makeError(e, t, n)
            }
            throwArgumentError(e, t, n) {
                return this.throwError(e, er.errors.INVALID_ARGUMENT, {
                    argument: t,
                    value: n
                })
            }
            assert(e, t, n, i) {
                e || this.throwError(t, n, i)
            }
            assertArgument(e, t, n, i) {
                e || this.throwArgumentError(t, n, i)
            }
            checkNormalize(e) {
                e == null && (e = "platform missing String.prototype.normalize"), xd && this.throwError("platform missing String.prototype.normalize", er.errors.UNSUPPORTED_OPERATION, {
                    operation: "String.prototype.normalize",
                    form: xd
                })
            }
            checkSafeUint53(e, t) {
                typeof e == "number" && (t == null && (t = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(t, er.errors.NUMERIC_FAULT, {
                    operation: "checkSafeInteger",
                    fault: "out-of-safe-range",
                    value: e
                }), e % 1 && this.throwError(t, er.errors.NUMERIC_FAULT, {
                    operation: "checkSafeInteger",
                    fault: "non-integer",
                    value: e
                }))
            }
            checkArgumentCount(e, t, n) {
                n ? n = ": " + n : n = "", e < t && this.throwError("missing argument" + n, er.errors.MISSING_ARGUMENT, {
                    count: e,
                    expectedCount: t
                }), e > t && this.throwError("too many arguments" + n, er.errors.UNEXPECTED_ARGUMENT, {
                    count: e,
                    expectedCount: t
                })
            }
            checkNew(e, t) {
                (e === Object || e == null) && this.throwError("missing new", er.errors.MISSING_NEW, {
                    name: t.name
                })
            }
            checkAbstract(e, t) {
                e === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", er.errors.UNSUPPORTED_OPERATION, {
                    name: e.name,
                    operation: "new"
                }) : (e === Object || e == null) && this.throwError("missing new", er.errors.MISSING_NEW, {
                    name: t.name
                })
            }
            static globalLogger() {
                return ph || (ph = new er(yd)), ph
            }
            static setCensorship(e, t) {
                if (!e && t && this.globalLogger().throwError("cannot permanently disable censorship", er.errors.UNSUPPORTED_OPERATION, {
                        operation: "setCensorship"
                    }), md) {
                    if (!e) return;
                    this.globalLogger().throwError("error censorship permanent", er.errors.UNSUPPORTED_OPERATION, {
                        operation: "setCensorship"
                    })
                }
                gd = !!e, md = !!t
            }
            static setLogLevel(e) {
                let t = of [e.toLowerCase()];
                if (t == null) {
                    er.globalLogger().warn("invalid log level - " + e);
                    return
                }
                bd = t
            }
            static from(e) {
                return new er(e)
            }
        };
    er.errors = On;
    er.levels = yh;
    var wd = "bytes/5.6.1";
    var mh = new er(wd);

    function y6(r) {
        return !!r.toHexString
    }

    function sf(r) {
        return r.slice || (r.slice = function() {
            let e = Array.prototype.slice.call(arguments);
            return sf(new Uint8Array(Array.prototype.slice.apply(r, e)))
        }), r
    }

    function _d(r) {
        return typeof r == "number" && r == r && r % 1 === 0
    }

    function m6(r) {
        if (r == null) return !1;
        if (r.constructor === Uint8Array) return !0;
        if (typeof r == "string" || !_d(r.length) || r.length < 0) return !1;
        for (let e = 0; e < r.length; e++) {
            let t = r[e];
            if (!_d(t) || t < 0 || t >= 256) return !1
        }
        return !0
    }

    function af(r, e) {
        if (e || (e = {}), typeof r == "number") {
            mh.checkSafeUint53(r, "invalid arrayify value");
            let t = [];
            for (; r;) t.unshift(r & 255), r = parseInt(String(r / 256));
            return t.length === 0 && t.push(0), sf(new Uint8Array(t))
        }
        if (e.allowMissingPrefix && typeof r == "string" && r.substring(0, 2) !== "0x" && (r = "0x" + r), y6(r) && (r = r.toHexString()), gh(r)) {
            let t = r.substring(2);
            t.length % 2 && (e.hexPad === "left" ? t = "0" + t : e.hexPad === "right" ? t += "0" : mh.throwArgumentError("hex data is odd-length", "value", r));
            let n = [];
            for (let i = 0; i < t.length; i += 2) n.push(parseInt(t.substring(i, i + 2), 16));
            return sf(new Uint8Array(n))
        }
        return m6(r) ? sf(new Uint8Array(r)) : mh.throwArgumentError("invalid arrayify value", "value", r)
    }

    function gh(r, e) {
        return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || e && r.length !== 2 + 2 * e)
    }
    var Ad = jt(Sd());
    var Md = "bignumber/5.6.2";
    var g6 = Ad.default.BN,
        RA = new er(Md);

    function xh(r) {
        return new g6(r, 36).toString(16)
    }
    var Id = jt(vh());

    function Bd(r) {
        return "0x" + Id.default.keccak_256(af(r))
    }
    var Rd = "address/5.6.1";
    var ua = new er(Rd);

    function kd(r) {
        gh(r, 20) || ua.throwArgumentError("invalid address", "address", r), r = r.toLowerCase();
        let e = r.substring(2).split(""),
            t = new Uint8Array(40);
        for (let i = 0; i < 40; i++) t[i] = e[i].charCodeAt(0);
        let n = af(Bd(t));
        for (let i = 0; i < 40; i += 2) n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
        return "0x" + e.join("")
    }
    var x6 = 9007199254740991;

    function v6(r) {
        return Math.log10 ? Math.log10(r) : Math.log(r) / Math.LN10
    }
    var wh = {};
    for (let r = 0; r < 10; r++) wh[String(r)] = String(r);
    for (let r = 0; r < 26; r++) wh[String.fromCharCode(65 + r)] = String(10 + r);
    var Pd = Math.floor(v6(x6));

    function w6(r) {
        r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + "00";
        let e = r.split("").map(n => wh[n]).join("");
        for (; e.length >= Pd;) {
            let n = e.substring(0, Pd);
            e = parseInt(n, 10) % 97 + e.substring(n.length)
        }
        let t = String(98 - parseInt(e, 10) % 97);
        for (; t.length < 2;) t = "0" + t;
        return t
    }

    function _6(r) {
        let e = null;
        if (typeof r != "string" && ua.throwArgumentError("invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/)) r.substring(0, 2) !== "0x" && (r = "0x" + r), e = kd(r), r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== r && ua.throwArgumentError("bad address checksum", "address", r);
        else if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            for (r.substring(2, 4) !== w6(r) && ua.throwArgumentError("bad icap checksum", "address", r), e = xh(r.substring(4)); e.length < 40;) e = "0" + e;
            e = kd("0x" + e)
        } else ua.throwArgumentError("invalid address", "address", r);
        return e
    }

    function Td(r) {
        try {
            return _6(r), !0
        } catch {}
        return !1
    }
    var Th = jt(Ti());
    var Ht = B.string().min(2, {
            message: "Must be 2 or more characters long"
        }).regex(/^0x[0-9A-Fa-f]*$/, {
            message: "String must be '0x'-prefixed and followed by valid hex characters"
        }),
        ue = Ht.min(3, {
            message: "Must be 3 or more characters long (should always have at least one digit - zero is '0x0')."
        }).refine(r => r === "0x0" ? !0 : r[2] !== "0", {
            message: "Invalid hex quantity: leading zero digits are not allowed."
        }),
        Nt = Ht.refine(r => r.length % 2 === 0, {
            message: "Invalid hex-encoded data: must be even number of digits"
        }),
        Lh = B.string().transform(r => {
            let e = Nt.safeParse(r);
            return e.success ? e.data : `0x${Buffer.from(r).toString("hex")}`
        }),
        zh = r => Nt.refine(e => e.length === r * 2 + 2, {
            message: `Invalid byte length. (Expected ${r} bytes)`
        }),
        lt = Ht.refine(Td, {
            message: "Invalid Ethereum address."
        }),
        xt = zh(32),
        Qd = zh(256),
        Li = B.object({
            blockHash: xt,
            address: lt,
            logIndex: ue,
            data: Nt,
            removed: B.boolean().optional(),
            topics: B.array(xt),
            blockNumber: ue.nullable(),
            transactionIndex: ue,
            transactionHash: xt
        }),
        yf = B.object({
            transactionHash: xt,
            transactionIndex: ue,
            blockHash: xt,
            blockNumber: ue,
            from: lt,
            to: lt.nullable().optional(),
            root: xt.optional(),
            status: B.literal("0x1").or(B.literal("0x0")).optional(),
            cumulativeGasUsed: ue,
            gasUsed: ue,
            contractAddress: lt.nullable(),
            logs: B.array(Li),
            logsBloom: Qd,
            effectiveGasPrice: ue.optional(),
            type: ue.optional()
        }),
        mf = B.object({
            from: lt.optional(),
            chainId: B.string().or(B.number()).optional(),
            to: lt.optional(),
            gas: ue.optional(),
            gasPrice: ue.optional(),
            value: ue.optional(),
            data: Nt.optional(),
            nonce: ue.optional()
        }),
        ln = B.object({
            name: B.string(),
            type: B.string()
        }),
        rw = B.object({
            name: B.literal("name"),
            type: B.literal("string")
        }),
        nw = B.object({
            name: B.literal("chainId"),
            type: B.literal("uint256")
        }),
        Uh = B.union([B.tuple([ln, ln, ln]), B.tuple([ln, ln, ln, ln])]).refine(r => {
            let e = [rw, nw],
                t = new Set(["name", "chainId"]);
            for (let n of r)
                for (let i of e) {
                    let o = i.safeParse(n);
                    if (o.success) {
                        t.delete(o.data.name);
                        continue
                    }
                }
            return t.size === 0
        }),
        iw = B.object({
            chainId: B.number(),
            name: B.string(),
            verifyingContract: lt,
            version: B.string().optional()
        }),
        ep = B.object({
            type: B.string(),
            name: B.string(),
            value: B.string()
        }).array(),
        Nh = B.object({
            domain: iw,
            message: B.record(B.any()),
            primaryType: B.string(),
            types: B.object({
                EIP712Domain: Uh
            }).and(B.record(ln.array()))
        }),
        tp = B.object({
            chainId: B.string().or(B.number()),
            name: B.string(),
            verifyingContract: lt.optional(),
            version: B.string().optional()
        }),
        qh = B.object({
            domain: tp,
            message: B.record(B.any()),
            primaryType: B.string(),
            types: B.object({
                EIP712Domain: Uh
            }).and(B.record(ln.array()))
        }),
        ow = B.object({
            name: B.literal("owner"),
            type: B.literal("address")
        }),
        sw = B.object({
            name: B.literal("spender"),
            type: B.literal("address")
        }),
        aw = B.object({
            name: B.literal("value"),
            type: B.literal("uint256")
        }),
        fw = B.object({
            name: B.literal("value"),
            type: B.literal("uint256")
        }),
        uw = B.object({
            name: B.literal("deadline"),
            type: B.literal("uint256")
        }),
        cw = B.tuple([ln, ln, ln, ln, ln]).refine(r => {
            let e = [ow, sw, aw, fw, uw],
                t = new Set(["owner", "spender", "value", "nonce", "deadline"]);
            for (let n of r)
                for (let i of e) {
                    let o = i.safeParse(n);
                    if (o.success) {
                        t.delete(o.data.name);
                        continue
                    }
                }
            return t.size === 0
        }).transform(() => [{
            name: "owner",
            type: "address"
        }, {
            name: "spender",
            type: "address"
        }, {
            name: "value",
            type: "uint256"
        }, {
            name: "nonce",
            type: "uint256"
        }, {
            name: "deadline",
            type: "uint256"
        }]),
        hw = B.literal("Permit"),
        lw = B.object({
            EIP712Domain: Uh,
            Permit: cw
        }),
        dw = B.object({
            owner: lt,
            spender: lt,
            value: ue,
            nonce: ue,
            deadline: ue
        }),
        tI = B.object({
            domain: tp,
            primaryType: hw,
            types: lw,
            message: dw
        }),
        rp = (n => (n.legacy = "0x0", n.eip2930 = "0x1", n.eip1559 = "0x2", n))(rp || {}),
        pw = B.tuple([lt, B.array(xt)]),
        Lo = B.object({
            chainId: B.number().or(Ht.transform(r => parseInt(r.substring(2), 16))).optional(),
            data: Nt.optional(),
            from: lt,
            gas: ue.optional(),
            gasPrice: ue.optional(),
            nonce: ue.optional(),
            to: lt.optional(),
            value: ue.optional(),
            type: B.nativeEnum(rp).optional(),
            accessList: B.array(pw).optional(),
            maxPriorityFeePerGas: ue.optional(),
            maxFeePerGas: ue.optional()
        }),
        zi = B.object({
            blockHash: xt.nullish(),
            blockNumber: ue.nullish(),
            from: lt,
            gas: ue,
            gasPrice: ue.nullish(),
            hash: xt,
            input: Nt,
            nonce: ue,
            to: lt.nullable(),
            transactionIndex: ue.nullish(),
            value: ue,
            v: ue,
            r: ue,
            s: ue
        }),
        np = B.object({
            address: lt.optional(),
            balance: ue,
            codeHash: xt,
            nonce: ue,
            storageHash: xt,
            accountProof: B.array(Ht),
            storageProof: B.array(B.object({
                key: ue,
                value: ue,
                proof: B.array(Ht)
            }))
        }),
        fr = B.literal("latest").or(B.literal("earliest")).or(B.literal("pending")),
        to = B.object({
            number: ue.nullable(),
            hash: xt.nullable(),
            parentHash: xt,
            nonce: zh(8).nullable(),
            sha3Uncles: xt,
            logsBloom: Qd.nullable(),
            transactionsRoot: xt,
            stateRoot: xt,
            receiptsRoot: xt,
            miner: lt.nullable(),
            mixHash: xt.optional(),
            difficulty: ue,
            totalDifficulty: ue.nullable(),
            extraData: Nt,
            size: ue,
            gasLimit: ue,
            gasUsed: ue,
            timestamp: ue,
            transactions: B.array(zi).or(B.array(xt)),
            uncles: B.array(xt),
            baseFeePerGas: ue.optional()
        }),
        rI = B.string().refine(r => {
            try {
                return Th.default.decode(r).byteLength === 32
            } catch (e) {
                return !1
            }
        }, {
            message: "String must be a valid solana public key of 32 bytes"
        }),
        nI = B.string().refine(r => {
            try {
                return Th.default.decode(r).byteLength === 64
            } catch (e) {
                return !1
            }
        }, {
            message: "String must be a valid solana address of 64 bytes"
        }),
        ys = B.object({
            url: B.string().url().transform(r => new URL(r)),
            title: B.string(),
            icon: B.string().nullable(),
            tabId: B.number().optional()
        }),
        yw = B.array(B.any()),
        Fh = B.object({}).passthrough(),
        Ch = B.union([B.null(), B.string(), B.number(), B.boolean(), yw, Fh]),
        gf = B.literal("2.0"),
        la = B.union([B.string(), B.number(), B.null()]),
        Oh = B.object({
            jsonrpc: B.literal("2.0"),
            id: la,
            method: B.string(),
            params: Ch.optional()
        }),
        ip = B.array(Oh),
        bf = B.object({
            jsonrpc: B.literal("2.0"),
            method: B.string(),
            params: Ch
        }),
        Dh = (L => (L[L.ParseError = -32700] = "ParseError", L[L.InternalError = -32603] = "InternalError", L[L.InvalidParams = -32602] = "InvalidParams", L[L.MethodNotFound = -32601] = "MethodNotFound", L[L.InvalidRequest = -32600] = "InvalidRequest", L[L.TransactionRejected = -32003] = "TransactionRejected", L[L.ResourceUnavailable = -32002] = "ResourceUnavailable", L[L.InvalidInput = -32e3] = "InvalidInput", L[L.UserRejectedRequest = 4001] = "UserRejectedRequest", L[L.Unauthorized = 4100] = "Unauthorized", L[L.Disconnected = 4900] = "Disconnected", L[L.ChainDisconnected = 4901] = "ChainDisconnected", L[L.ExecutionReverted = 3] = "ExecutionReverted", L))(Dh || {}),
        le = B.object({
            code: B.nativeEnum(Dh),
            message: B.string()
        }),
        mw = B.object({
            error: le
        }).or(B.object({
            result: Ch
        })),
        Kh = B.object({
            jsonrpc: B.literal("2.0"),
            id: la
        }).and(mw),
        op = B.array(Kh);

    function de(r, e) {
        return B.object({
            jsonrpc: gf,
            id: la,
            method: r,
            params: e
        })
    }

    function pe(r, e) {
        return B.object({
            jsonrpc: gf,
            id: la
        }).and(B.object({
            result: r
        }).or(B.object({
            error: e
        })))
    }

    function xf(r, e) {
        return B.object({
            jsonrpc: gf,
            method: r,
            params: e
        })
    }
    var sp = B.literal("dapp_icon"),
        ap = B.string().nullable(),
        gw = xf(sp, ap);
    var Eu = {};
    ct(Eu, {
        eth_accounts: () => _f,
        eth_blockNumber: () => Ef,
        eth_call: () => Sf,
        eth_cancelPrivateTransaction: () => Mf,
        eth_chainId: () => Af,
        eth_estimateGas: () => If,
        eth_feeHistory: () => Bf,
        eth_gasPrice: () => Rf,
        eth_getBalance: () => kf,
        eth_getBlockByHash: () => Pf,
        eth_getBlockByNumber: () => Tf,
        eth_getBlockReceipts: () => Lf,
        eth_getBlockTransactionCountByHash: () => zf,
        eth_getBlockTransactionCountByNumber: () => Uf,
        eth_getCode: () => Nf,
        eth_getFilterChanges: () => qf,
        eth_getFilterLogs: () => Ff,
        eth_getLogs: () => Cf,
        eth_getProof: () => Of,
        eth_getStorageAt: () => Df,
        eth_getTransactionByBlockHashAndIndex: () => Kf,
        eth_getTransactionByBlockNumberAndIndex: () => $f,
        eth_getTransactionByHash: () => jf,
        eth_getTransactionCount: () => Wf,
        eth_getTransactionReceipt: () => Hf,
        eth_getUncleByBlockHashAndIndex: () => Vf,
        eth_getUncleByBlockNumberAndIndex: () => Gf,
        eth_getUncleCountByBlockHash: () => Zf,
        eth_getUncleCountByBlockNumber: () => Yf,
        eth_maxPriorityFeePerGas: () => Jf,
        eth_newBlockFilter: () => Xf,
        eth_newFilter: () => Qf,
        eth_newPendingTransactionFilter: () => eu,
        eth_protocolVersion: () => ru,
        eth_requestAccounts: () => nu,
        eth_sendPrivateTransaction: () => iu,
        eth_sendRawTransaction: () => ou,
        eth_sendTransaction: () => su,
        eth_sign: () => au,
        eth_signTransaction: () => fu,
        eth_signTypedData: () => uu,
        eth_signTypedData_v3: () => cu,
        eth_signTypedData_v4: () => hu,
        eth_subscribe: () => lu,
        eth_uninstallFilter: () => du,
        eth_unsubscribe: () => pu,
        net_listening: () => yu,
        net_version: () => mu,
        personal_sign: () => tu,
        wallet_addEthereumChain: () => gu,
        wallet_phantom_isTrusted: () => _u,
        wallet_switchEthereumChain: () => bu,
        wallet_watchAsset: () => xu,
        web3_clientVersion: () => vu,
        web3_sha3: () => wu
    });
    var _f = {};
    ct(_f, {
        error: () => hp,
        method: () => fp,
        params: () => up,
        request: () => bw,
        response: () => xw,
        result: () => cp
    });
    var fp = B.literal("eth_accounts"),
        up = B.tuple([]),
        cp = B.array(lt),
        hp = le,
        bw = de(fp, up),
        xw = pe(cp, hp);
    var Ef = {};
    ct(Ef, {
        error: () => yp,
        method: () => lp,
        params: () => dp,
        request: () => vw,
        response: () => ww,
        result: () => pp
    });
    var lp = B.literal("eth_blockNumber"),
        dp = B.tuple([]),
        pp = ue,
        yp = le,
        vw = de(lp, dp),
        ww = pe(pp, yp);
    var Sf = {};
    ct(Sf, {
        error: () => xp,
        method: () => mp,
        params: () => gp,
        request: () => _w,
        response: () => Ew,
        result: () => bp
    });
    var mp = B.literal("eth_call"),
        gp = B.tuple([mf, ue.or(fr)]),
        bp = Nt,
        xp = le,
        _w = de(mp, gp),
        Ew = pe(bp, xp);
    var Mf = {};
    ct(Mf, {
        error: () => Ep,
        method: () => vp,
        params: () => wp,
        request: () => Sw,
        response: () => Mw,
        result: () => _p
    });
    var vp = B.literal("eth_cancelPrivateTransaction"),
        wp = B.tuple([B.object({
            txHash: xt
        })]),
        _p = B.boolean(),
        Ep = le,
        Sw = de(vp, wp),
        Mw = pe(_p, Ep);
    var Af = {};
    ct(Af, {
        error: () => Ip,
        method: () => Sp,
        params: () => Mp,
        request: () => Aw,
        response: () => Iw,
        result: () => Ap
    });
    var Sp = B.literal("eth_chainId"),
        Mp = B.tuple([]),
        Ap = Ht,
        Ip = le,
        Aw = de(Sp, Mp),
        Iw = pe(Ap, Ip);
    var If = {};
    ct(If, {
        error: () => Pp,
        method: () => Bp,
        params: () => Rp,
        request: () => Bw,
        response: () => Rw,
        result: () => kp
    });
    var Bp = B.literal("eth_estimateGas"),
        Rp = B.tuple([mf]),
        kp = ue,
        Pp = le,
        Bw = de(Bp, Rp),
        Rw = pe(kp, Pp);
    var Bf = {};
    ct(Bf, {
        error: () => Up,
        method: () => Tp,
        params: () => Lp,
        request: () => kw,
        response: () => Pw,
        result: () => zp
    });
    var Tp = B.literal("eth_feeHistory"),
        Lp = B.tuple([B.number(), ue.or(fr), B.array(B.number()).optional()]),
        zp = B.object({
            oldestBlock: B.number(),
            reward: B.array(B.tuple([ue, ue])).optional(),
            baseFeePerGas: B.array(ue),
            gasUsedRatio: B.array(B.number())
        }),
        Up = le,
        kw = de(Tp, Lp),
        Pw = pe(zp, Up);
    var Rf = {};
    ct(Rf, {
        error: () => Cp,
        method: () => Np,
        params: () => qp,
        request: () => Tw,
        response: () => Lw,
        result: () => Fp
    });
    var Np = B.literal("eth_gasPrice"),
        qp = B.tuple([]),
        Fp = ue,
        Cp = le,
        Tw = de(Np, qp),
        Lw = pe(Fp, Cp);
    var kf = {};
    ct(kf, {
        error: () => $p,
        method: () => Op,
        params: () => Dp,
        request: () => zw,
        response: () => Uw,
        result: () => Kp
    });
    var Op = B.literal("eth_getBalance"),
        Dp = B.tuple([lt, ue.or(fr)]),
        Kp = ue,
        $p = le,
        zw = de(Op, Dp),
        Uw = pe(Kp, $p);
    var Pf = {};
    ct(Pf, {
        error: () => Vp,
        method: () => jp,
        params: () => Wp,
        request: () => Nw,
        response: () => qw,
        result: () => Hp
    });
    var jp = B.literal("eth_getBlockByHash"),
        Wp = B.tuple([xt, B.boolean()]),
        Hp = to,
        Vp = le,
        Nw = de(jp, Wp),
        qw = pe(Hp, Vp);
    var Tf = {};
    ct(Tf, {
        error: () => Jp,
        method: () => Gp,
        params: () => Zp,
        request: () => Fw,
        response: () => Cw,
        result: () => Yp
    });
    var Gp = B.literal("eth_getBlockByNumber"),
        Zp = B.tuple([ue.or(fr), B.boolean()]),
        Yp = to,
        Jp = le,
        Fw = de(Gp, Zp),
        Cw = pe(Yp, Jp);
    var Lf = {};
    ct(Lf, {
        error: () => t1,
        method: () => Xp,
        params: () => Qp,
        request: () => Ow,
        response: () => Dw,
        result: () => e1
    });
    var Xp = B.literal("eth_getBlockReceipts"),
        Qp = B.tuple([xt.or(ue).or(fr)]),
        e1 = B.array(yf),
        t1 = le,
        Ow = de(Xp, Qp),
        Dw = pe(e1, t1);
    var zf = {};
    ct(zf, {
        error: () => o1,
        method: () => r1,
        params: () => n1,
        request: () => Kw,
        response: () => $w,
        result: () => i1
    });
    var r1 = B.literal("eth_getBlockTransactionCountByHash"),
        n1 = B.tuple([xt]),
        i1 = ue,
        o1 = le,
        Kw = de(r1, n1),
        $w = pe(i1, o1);
    var Uf = {};
    ct(Uf, {
        error: () => u1,
        method: () => s1,
        params: () => a1,
        request: () => jw,
        response: () => Ww,
        result: () => f1
    });
    var s1 = B.literal("eth_getBlockTransactionCountByNumber"),
        a1 = B.tuple([ue]),
        f1 = ue,
        u1 = le,
        jw = de(s1, a1),
        Ww = pe(f1, u1);
    var Nf = {};
    ct(Nf, {
        error: () => d1,
        method: () => c1,
        params: () => h1,
        request: () => Hw,
        response: () => Vw,
        result: () => l1
    });
    var c1 = B.literal("eth_getCode"),
        h1 = B.tuple([lt, B.union([ue, fr])]),
        l1 = Nt,
        d1 = le,
        Hw = de(c1, h1),
        Vw = pe(l1, d1);
    var qf = {};
    ct(qf, {
        error: () => g1,
        method: () => p1,
        params: () => y1,
        request: () => Gw,
        response: () => Zw,
        result: () => m1
    });
    var p1 = B.literal("eth_getFilterChanges"),
        y1 = B.tuple([ue]),
        m1 = B.array(Li),
        g1 = le,
        Gw = de(p1, y1),
        Zw = pe(m1, g1);
    var Ff = {};
    ct(Ff, {
        error: () => w1,
        method: () => b1,
        params: () => x1,
        request: () => Yw,
        response: () => Jw,
        result: () => v1
    });
    var b1 = B.literal("eth_getFilterLogs"),
        x1 = B.tuple([ue]),
        v1 = B.array(Li),
        w1 = le,
        Yw = de(b1, x1),
        Jw = pe(v1, w1);
    var Cf = {};
    ct(Cf, {
        error: () => M1,
        method: () => _1,
        params: () => E1,
        request: () => Xw,
        response: () => Qw,
        result: () => S1
    });
    var _1 = B.literal("eth_getLogs"),
        E1 = B.tuple([B.object({
            fromBlock: ue.or(fr).optional(),
            toBlock: B.string().optional(),
            address: lt.optional(),
            topics: B.array(xt).optional(),
            blockHash: xt.optional()
        })]),
        S1 = B.array(Li),
        M1 = le,
        Xw = de(_1, E1),
        Qw = pe(S1, M1);
    var Of = {};
    ct(Of, {
        error: () => R1,
        method: () => A1,
        params: () => I1,
        request: () => e8,
        response: () => t8,
        result: () => B1
    });
    var A1 = B.literal("eth_getProof"),
        I1 = B.tuple([lt, B.array(xt), ue.or(fr)]),
        B1 = np,
        R1 = le,
        e8 = de(A1, I1),
        t8 = pe(B1, R1);
    var Df = {};
    ct(Df, {
        error: () => L1,
        method: () => k1,
        params: () => P1,
        request: () => r8,
        response: () => n8,
        result: () => T1
    });
    var k1 = B.literal("eth_getStorageAt"),
        P1 = B.tuple([lt, ue, ue.or(fr)]),
        T1 = Nt,
        L1 = le,
        r8 = de(k1, P1),
        n8 = pe(T1, L1);
    var Kf = {};
    ct(Kf, {
        error: () => q1,
        method: () => z1,
        params: () => U1,
        request: () => i8,
        response: () => o8,
        result: () => N1
    });
    var z1 = B.literal("eth_getTransactionByBlockHashAndIndex"),
        U1 = B.tuple([xt, ue]),
        N1 = zi.nullable(),
        q1 = le,
        i8 = de(z1, U1),
        o8 = pe(N1, q1);
    var $f = {};
    ct($f, {
        error: () => D1,
        method: () => F1,
        params: () => C1,
        request: () => s8,
        response: () => a8,
        result: () => O1
    });
    var F1 = B.literal("eth_getTransactionByBlockNumberAndIndex"),
        C1 = B.tuple([B.string(), ue]),
        O1 = zi,
        D1 = le,
        s8 = de(F1, C1),
        a8 = pe(O1, D1);
    var jf = {};
    ct(jf, {
        error: () => W1,
        method: () => K1,
        params: () => $1,
        request: () => f8,
        response: () => u8,
        result: () => j1
    });
    var K1 = B.literal("eth_getTransactionByHash"),
        $1 = B.tuple([xt]),
        j1 = zi.nullable(),
        W1 = le,
        f8 = de(K1, $1),
        u8 = pe(j1, W1);
    var Wf = {};
    ct(Wf, {
        error: () => Z1,
        method: () => H1,
        params: () => V1,
        request: () => c8,
        response: () => h8,
        result: () => G1
    });
    var H1 = B.literal("eth_getTransactionCount"),
        V1 = B.tuple([lt, ue.or(fr)]),
        G1 = ue,
        Z1 = le,
        c8 = de(H1, V1),
        h8 = pe(G1, Z1);
    var Hf = {};
    ct(Hf, {
        error: () => Q1,
        method: () => Y1,
        params: () => J1,
        request: () => l8,
        response: () => d8,
        result: () => X1
    });
    var Y1 = B.literal("eth_getTransactionReceipt"),
        J1 = B.tuple([xt]),
        X1 = yf.nullable(),
        Q1 = le,
        l8 = de(Y1, J1),
        d8 = pe(X1, Q1);
    var Vf = {};
    ct(Vf, {
        error: () => ny,
        method: () => ey,
        params: () => ty,
        request: () => p8,
        response: () => y8,
        result: () => ry
    });
    var ey = B.literal("eth_getUncleByBlockHashAndIndex"),
        ty = B.tuple([ue.or(fr), ue]),
        ry = to,
        ny = le,
        p8 = de(ey, ty),
        y8 = pe(ry, ny);
    var Gf = {};
    ct(Gf, {
        error: () => ay,
        method: () => iy,
        params: () => oy,
        request: () => m8,
        response: () => g8,
        result: () => sy
    });
    var iy = B.literal("eth_getUncleByBlockNumberAndIndex"),
        oy = B.tuple([ue.or(fr), ue]),
        sy = to,
        ay = le,
        m8 = de(iy, oy),
        g8 = pe(sy, ay);
    var Zf = {};
    ct(Zf, {
        error: () => hy,
        method: () => fy,
        params: () => uy,
        request: () => b8,
        response: () => x8,
        result: () => cy
    });
    var fy = B.literal("eth_getUncleCountByBlockHash"),
        uy = B.tuple([xt]),
        cy = ue,
        hy = le,
        b8 = de(fy, uy),
        x8 = pe(cy, hy);
    var Yf = {};
    ct(Yf, {
        error: () => yy,
        method: () => ly,
        params: () => dy,
        request: () => v8,
        response: () => w8,
        result: () => py
    });
    var ly = B.literal("eth_getUncleCountByBlockNumber"),
        dy = B.tuple([ue.or(fr)]),
        py = ue,
        yy = le,
        v8 = de(ly, dy),
        w8 = pe(py, yy);
    var Jf = {};
    ct(Jf, {
        error: () => xy,
        method: () => my,
        params: () => gy,
        request: () => _8,
        response: () => E8,
        result: () => by
    });
    var my = B.literal("eth_maxPriorityFeePerGas"),
        gy = B.tuple([]),
        by = ue,
        xy = le,
        _8 = de(my, gy),
        E8 = pe(by, xy);
    var Xf = {};
    ct(Xf, {
        error: () => Ey,
        method: () => vy,
        params: () => wy,
        request: () => S8,
        response: () => M8,
        result: () => _y
    });
    var vy = B.literal("eth_newBlockFilter"),
        wy = B.tuple([]),
        _y = ue,
        Ey = le,
        S8 = de(vy, wy),
        M8 = pe(_y, Ey);
    var Qf = {};
    ct(Qf, {
        error: () => Iy,
        method: () => Sy,
        params: () => My,
        request: () => A8,
        response: () => I8,
        result: () => Ay
    });
    var Sy = B.literal("eth_newFilter"),
        My = B.tuple([B.object({
            fromBlock: ue.optional(),
            toBlock: ue.optional(),
            address: lt.or(B.array(lt)).optional(),
            topics: B.array(Nt.nullable().or(B.array(Nt.nullable()))).optional()
        })]),
        Ay = ue,
        Iy = le,
        A8 = de(Sy, My),
        I8 = pe(Ay, Iy);
    var eu = {};
    ct(eu, {
        error: () => Py,
        method: () => By,
        params: () => Ry,
        request: () => B8,
        response: () => R8,
        result: () => ky
    });
    var By = B.literal("eth_newPendingTransactionFilter"),
        Ry = B.tuple([]),
        ky = ue,
        Py = le,
        B8 = de(By, Ry),
        R8 = pe(ky, Py);
    var tu = {};
    ct(tu, {
        error: () => Uy,
        method: () => Ty,
        params: () => Ly,
        request: () => k8,
        response: () => P8,
        result: () => zy
    });
    var Ty = B.literal("personal_sign"),
        Ly = B.union([B.tuple([Lh, lt]), B.tuple([Lh, lt, B.string()])]),
        zy = Nt,
        Uy = le,
        k8 = de(Ty, Ly),
        P8 = pe(zy, Uy);
    var ru = {};
    ct(ru, {
        error: () => Cy,
        method: () => Ny,
        params: () => qy,
        request: () => T8,
        response: () => L8,
        result: () => Fy
    });
    var Ny = B.literal("eth_protocolVersion"),
        qy = B.tuple([]),
        Fy = B.string(),
        Cy = le,
        T8 = de(Ny, qy),
        L8 = pe(Fy, Cy);
    var nu = {};
    ct(nu, {
        error: () => $y,
        method: () => Oy,
        params: () => Dy,
        request: () => z8,
        response: () => U8,
        result: () => Ky
    });
    var Oy = B.literal("eth_requestAccounts"),
        Dy = B.tuple([]),
        Ky = B.array(lt),
        $y = le,
        z8 = de(Oy, Dy),
        U8 = pe(Ky, $y);
    var iu = {};
    ct(iu, {
        error: () => Vy,
        method: () => jy,
        params: () => Wy,
        request: () => N8,
        response: () => q8,
        result: () => Hy
    });
    var jy = B.literal("eth_sendPrivateTransaction"),
        Wy = B.tuple([B.object({
            tx: xt,
            maxBlockNumber: ue.optional(),
            preferences: B.object({
                fast: B.boolean()
            }).optional()
        })]),
        Hy = xt,
        Vy = le,
        N8 = de(jy, Wy),
        q8 = pe(Hy, Vy);
    var ou = {};
    ct(ou, {
        error: () => Jy,
        method: () => Gy,
        params: () => Zy,
        request: () => F8,
        response: () => C8,
        result: () => Yy
    });
    var Gy = B.literal("eth_sendRawTransaction"),
        Zy = B.tuple([Nt]),
        Yy = xt,
        Jy = le,
        F8 = de(Gy, Zy),
        C8 = pe(Yy, Jy);
    var su = {};
    ct(su, {
        error: () => tm,
        method: () => Xy,
        params: () => Qy,
        request: () => O8,
        response: () => D8,
        result: () => em
    });
    var Xy = B.literal("eth_sendTransaction"),
        Qy = B.union([B.tuple([Lo]), B.tuple([Lo, Ht])]),
        em = xt,
        tm = le,
        O8 = de(Xy, Qy),
        D8 = pe(em, tm);
    var au = {};
    ct(au, {
        error: () => om,
        method: () => rm,
        params: () => nm,
        request: () => K8,
        response: () => $8,
        result: () => im
    });
    var rm = B.literal("eth_sign"),
        nm = B.tuple([lt, Nt]),
        im = Nt,
        om = le,
        K8 = de(rm, nm),
        $8 = pe(im, om);
    var fu = {};
    ct(fu, {
        error: () => um,
        method: () => sm,
        params: () => am,
        request: () => j8,
        response: () => W8,
        result: () => fm
    });
    var sm = B.literal("eth_signTransaction"),
        am = B.tuple([Lo]),
        fm = Nt,
        um = le,
        j8 = de(sm, am),
        W8 = pe(fm, um);
    var uu = {};
    ct(uu, {
        error: () => dm,
        method: () => cm,
        params: () => hm,
        request: () => H8,
        response: () => V8,
        result: () => lm
    });
    var cm = B.literal("eth_signTypedData"),
        hm = B.tuple([ep, lt]),
        lm = Nt,
        dm = le,
        H8 = de(cm, hm),
        V8 = pe(lm, dm);
    var cu = {};
    ct(cu, {
        error: () => gm,
        method: () => pm,
        params: () => ym,
        request: () => G8,
        response: () => Z8,
        result: () => mm
    });
    var pm = B.literal("eth_signTypedData_v3"),
        ym = B.tuple([lt, B.string().transform((r, e) => {
            try {
                let t = JSON.parse(r);
                return Nh.parse(t)
            } catch (t) {
                return e.addIssue({
                    code: B.ZodIssueCode.custom,
                    message: "Invalid typed data:" + t.message,
                    fatal: !0
                }), B.NEVER
            }
        }).or(Nh)]),
        mm = Nt,
        gm = le,
        G8 = de(pm, ym),
        Z8 = pe(mm, gm);
    var hu = {};
    ct(hu, {
        error: () => wm,
        method: () => bm,
        params: () => xm,
        request: () => Y8,
        response: () => J8,
        result: () => vm
    });
    var bm = B.literal("eth_signTypedData_v4"),
        xm = B.tuple([lt, B.string().transform((r, e) => {
            try {
                let t = JSON.parse(r);
                return qh.parse(t)
            } catch (t) {
                return e.addIssue({
                    code: B.ZodIssueCode.custom,
                    message: "Invalid typed data:" + t.message,
                    fatal: !0
                }), B.NEVER
            }
        }).or(qh)]),
        vm = Nt,
        wm = le,
        Y8 = de(bm, xm),
        J8 = pe(vm, wm);
    var lu = {};
    ct(lu, {
        error: () => Mm,
        method: () => _m,
        params: () => Em,
        request: () => X8,
        response: () => Q8,
        result: () => Sm
    });
    var _m = B.literal("eth_subscribe"),
        Em = B.union([B.tuple([B.union([B.literal("alchemy_pendingTransactions"), B.literal("newPendingTransactions"), B.literal("newHeads"), B.literal("logs")])]), B.tuple([B.union([B.literal("alchemy_pendingTransactions"), B.literal("newPendingTransactions"), B.literal("newHeads"), B.literal("logs")]), B.union([B.object({
            fromAddress: B.union([lt, B.array(lt)]).optional(),
            toAddress: B.union([lt, B.array(lt)]).optional(),
            hashesOnly: B.boolean().optional()
        }), B.object({
            address: B.union([lt, B.array(lt)]).optional(),
            topics: B.array(B.union([B.null(), lt, B.array(lt)]))
        })])])]),
        Sm = B.union([Ht, B.object({
            result: zi,
            subscription: Ht
        }), B.object({
            result: xt,
            subscription: Ht
        }), B.object({
            result: B.object({
                difficulty: Ht,
                extraData: Ht,
                gasLimit: Ht,
                gasUsed: Ht,
                logsBloom: Ht,
                miner: lt,
                nonce: Ht,
                number: Ht,
                parentHash: xt,
                receiptRoot: xt,
                sha3Uncles: xt,
                stateRoot: xt,
                timestamp: Ht,
                transactionsRoot: xt
            }),
            subscription: Ht
        }), B.object({
            result: Li,
            subscription: Ht
        })]),
        Mm = le,
        X8 = de(_m, Em),
        Q8 = pe(Sm, Mm);
    var du = {};
    ct(du, {
        error: () => Rm,
        method: () => Am,
        params: () => Im,
        request: () => e4,
        response: () => t4,
        result: () => Bm
    });
    var Am = B.literal("eth_uninstallFilter"),
        Im = B.tuple([ue]),
        Bm = B.boolean(),
        Rm = le,
        e4 = de(Am, Im),
        t4 = pe(Bm, Rm);
    var pu = {};
    ct(pu, {
        error: () => Lm,
        method: () => km,
        params: () => Pm,
        request: () => r4,
        response: () => n4,
        result: () => Tm
    });
    var km = B.literal("eth_unsubscribe"),
        Pm = B.tuple([ue]),
        Tm = B.boolean(),
        Lm = le,
        r4 = de(km, Pm),
        n4 = pe(Tm, Lm);
    var yu = {};
    ct(yu, {
        error: () => qm,
        method: () => zm,
        params: () => Um,
        request: () => i4,
        response: () => o4,
        result: () => Nm
    });
    var zm = B.literal("net_listening"),
        Um = B.tuple([]),
        Nm = B.boolean(),
        qm = le,
        i4 = de(zm, Um),
        o4 = pe(Nm, qm);
    var mu = {};
    ct(mu, {
        error: () => Dm,
        method: () => Fm,
        params: () => Cm,
        request: () => s4,
        response: () => a4,
        result: () => Om
    });
    var Fm = B.literal("net_version"),
        Cm = B.tuple([]),
        Om = B.string(),
        Dm = le,
        s4 = de(Fm, Cm),
        a4 = pe(Om, Dm);
    var gu = {};
    ct(gu, {
        error: () => Wm,
        method: () => Km,
        params: () => $m,
        request: () => f4,
        response: () => u4,
        result: () => jm
    });
    var Km = B.literal("wallet_addEthereumChain"),
        $m = B.tuple([B.object({
            chainId: Ht,
            chainName: B.string(),
            nativeCurrency: B.object({
                name: B.string(),
                symbol: B.string().refine(r => {
                    let {
                        length: e
                    } = r;
                    return e >= 2 && e <= 6
                }, {
                    message: "Value is not a valid symbol."
                }),
                decimals: B.number()
            }),
            rpcUrls: B.array(B.string()),
            blockExplorerUrls: B.union([B.tuple([B.string()]), B.null()]).optional(),
            iconUrls: B.array(B.string()).optional()
        })]),
        jm = B.null(),
        Wm = le,
        f4 = de(Km, $m),
        u4 = pe(jm, Wm);
    var bu = {};
    ct(bu, {
        error: () => Zm,
        method: () => Hm,
        params: () => Vm,
        request: () => c4,
        response: () => h4,
        result: () => Gm
    });
    var Hm = B.literal("wallet_switchEthereumChain"),
        Vm = B.tuple([B.object({
            chainId: Ht
        })]),
        Gm = B.null(),
        Zm = le,
        c4 = de(Hm, Vm),
        h4 = pe(Gm, Zm);
    var xu = {};
    ct(xu, {
        error: () => Qm,
        method: () => Ym,
        params: () => Jm,
        request: () => l4,
        response: () => d4,
        result: () => Xm
    });
    var Ym = B.literal("wallet_watchAsset"),
        Jm = B.object({
            type: B.literal("ERC20"),
            options: B.object({
                address: lt,
                symbol: B.string(),
                decimals: B.number(),
                image: B.string()
            })
        }),
        Xm = B.boolean(),
        Qm = le,
        l4 = de(Ym, Jm),
        d4 = pe(Xm, Qm);
    var vu = {};
    ct(vu, {
        error: () => ng,
        method: () => eg,
        params: () => tg,
        request: () => p4,
        response: () => y4,
        result: () => rg
    });
    var eg = B.literal("web3_clientVersion"),
        tg = B.tuple([]),
        rg = B.string(),
        ng = le,
        p4 = de(eg, tg),
        y4 = pe(rg, ng);
    var wu = {};
    ct(wu, {
        error: () => ag,
        method: () => ig,
        params: () => og,
        request: () => m4,
        response: () => g4,
        result: () => sg
    });
    var ig = B.literal("web3_sha3"),
        og = B.tuple([Nt]),
        sg = Nt,
        ag = le,
        m4 = de(ig, og),
        g4 = pe(sg, ag);
    var _u = {};
    ct(_u, {
        error: () => hg,
        method: () => fg,
        params: () => ug,
        request: () => b4,
        response: () => x4,
        result: () => cg
    });
    var fg = B.literal("wallet_phantom_isTrusted"),
        ug = B.tuple([]),
        cg = B.boolean(),
        hg = le,
        b4 = de(fg, ug),
        x4 = pe(cg, hg);
    var Mu = {};
    ct(Mu, {
        phantom_accountChanged: () => Su
    });
    var Su = {};
    ct(Su, {
        method: () => lg,
        notification: () => v4,
        params: () => dg
    });
    var lg = B.literal("phantom_accountChanged"),
        dg = B.tuple([lt]),
        v4 = xf(lg, dg);
    var $h = {};
    ct($h, {
        error: () => gg,
        method: () => pg,
        params: () => yg,
        request: () => w4,
        response: () => _4,
        result: () => mg
    });
    var pg = B.literal("user_approveEthRequestAccounts"),
        yg = B.tuple([ys]),
        mg = B.null(),
        gg = le,
        w4 = de(pg, yg),
        _4 = pe(mg, gg);
    var jh = {};
    ct(jh, {
        error: () => _g,
        method: () => xg,
        params: () => vg,
        request: () => E4,
        response: () => S4,
        result: () => wg
    });
    var xg = B.literal("user_approveEthSendTransaction"),
        vg = B.tuple([ys, Lo]),
        bg = B.object({
            maxFeePerGas: ue.optional(),
            maxPriorityFeePerGas: ue.optional()
        }),
        wg = B.discriminatedUnion("approvalType", [B.object({
            approvalType: B.literal("user"),
            gas: bg
        }), B.object({
            approvalType: B.literal("hardware"),
            signature: Ht,
            gas: bg
        })]),
        _g = le,
        E4 = de(xg, vg),
        S4 = pe(wg, _g);
    var Wh = {};
    ct(Wh, {
        error: () => Ag,
        method: () => Eg,
        params: () => Sg,
        request: () => M4,
        response: () => A4,
        result: () => Mg
    });
    var Eg = B.literal("user_approveEthSignMessage"),
        Sg = B.tuple([ys, B.object({
            signer: lt,
            message: Nt
        })]),
        Mg = B.discriminatedUnion("approvalType", [B.object({
            approvalType: B.literal("user")
        }), B.object({
            approvalType: B.literal("hardware"),
            signature: Ht
        })]),
        Ag = le,
        M4 = de(Eg, Sg),
        A4 = pe(Mg, Ag);
    var kg = jt(pa());
    var ro = class extends Error {
        constructor({
            code: t,
            message: n
        }, i) {
            super(n);
            this.code = t, this.message = n, typeof i != "undefined" && (this.data = i)
        }
        toString() {
            return this.message
        }
    };
    var Dn, Kn, Bg = class {
        constructor({
            port: e
        }) {
            Fn(this, Dn, void 0);
            Fn(this, Kn, !1);
            Mn(this, Dn, e), Mn(this, Kn, !1)
        }
        get status() {
            return sr(this, Kn) ? "started" : "stopped"
        }
        start() {
            return xr(this, null, function*() {
                if (sr(this, Kn)) return;
                let e = sr(this, Dn).onClose(() => {
                    Mn(this, Kn, !1), e()
                });
                yield sr(this, Dn).start(), Mn(this, Kn, !0)
            })
        }
        close() {
            return xr(this, null, function*() {
                !sr(this, Kn) || (yield sr(this, Dn).close(), Mn(this, Kn, !1))
            })
        }
        send(e) {
            return xr(this, null, function*() {
                if (!sr(this, Kn)) throw new Error("Cannot read stream: RpcTransport has not been started");
                if (Array.isArray(e)) {
                    let A = ip.parse(e),
                        I = new Set(A.map(L => L.id)),
                        q = JSON.stringify(A);
                    sr(this, Dn).postMessage(q);
                    try {
                        for (var t = uh(this.recv()), n, i, o; n = !(i = yield t.next()).done; n = !1) {
                            let L = i.value;
                            if (Array.isArray(L) && L.every(O => I.has(O.id))) return L
                        }
                    } catch (i) {
                        o = [i]
                    } finally {
                        try {
                            n && (i = t.return) && (yield i.call(t))
                        } finally {
                            if (o) throw o[0]
                        }
                    }
                    throw new Error("Failed to get response: request ids=" + I)
                } else {
                    let A = Oh.parse(e),
                        {
                            id: I
                        } = A,
                        q = JSON.stringify(A);
                    sr(this, Dn).postMessage(q);
                    try {
                        for (var a = uh(this.recv()), y, g, E; y = !(g = yield a.next()).done; y = !1) {
                            let L = g.value;
                            if ("id" in L && L.id === I && !("method" in L)) return L
                        }
                    } catch (g) {
                        E = [g]
                    } finally {
                        try {
                            y && (g = a.return) && (yield g.call(a))
                        } finally {
                            if (E) throw E[0]
                        }
                    }
                    throw new Error("Failed to get response: request id=" + I)
                }
            })
        }
        addListener(e) {
            let t = i => xr(this, null, function*() {
                    let o = this.recv()[Symbol.asyncIterator](),
                        a = () => {},
                        y = () => new Promise(E => a = () => E(null));

                    function g() {
                        var E;
                        (E = o.return) == null || E.call(o), a(), i.signal.removeEventListener("abort", g)
                    }
                    try {
                        for (i.signal.addEventListener("abort", g);;) {
                            let E = yield Promise.race([o.next(), y()]);
                            if (!E) break;
                            try {
                                e(E.value)
                            } catch (A) {
                                console.error(A)
                            }
                        }
                        g()
                    } catch (E) {
                        throw g(), E
                    }
                }),
                n = new AbortController;
            return t(n), () => n.abort()
        }
        recv() {
            let e = [],
                t = () => {},
                n = () => new Promise(A => t = A),
                i = !1,
                o = sr(this, Dn).onClose(() => {
                    i = !0, t(), o()
                }),
                a = sr(this, Dn).onMessage(A => {
                    try {
                        let I = JSON.parse(A);
                        if ("method" in I && "id" in I) {
                            t();
                            return
                        }
                        if (Array.isArray(I)) {
                            let q = op.parse(I);
                            e.push(q), t()
                        } else {
                            let q = Fh.parse(I);
                            if ("id" in q) {
                                let L = Kh.parse(I);
                                e.push(L), t()
                            } else {
                                let L = bf.parse(I);
                                e.push(L), t()
                            }
                        }
                    } catch (I) {
                        console.error(I)
                    }
                }),
                y = () => {
                    o(), a()
                },
                g = {
                    next() {
                        return xr(this, null, function*() {
                            for (; !i;) {
                                let A = e.shift();
                                if (A) return {
                                    done: !1,
                                    value: A
                                };
                                yield n()
                            }
                            return y(), {
                                done: !0,
                                value: void 0
                            }
                        })
                    },
                    throw () {
                        return xr(this, null, function*() {
                            return y(), {
                                done: !0,
                                value: void 0
                            }
                        })
                    },
                    return () {
                        return xr(this, null, function*() {
                            return y(), {
                                done: !0,
                                value: void 0
                            }
                        })
                    }
                };
            return {
                [Symbol.asyncIterator]() {
                    return g
                }
            }
        }
    };
    Dn = new WeakMap, Kn = new WeakMap;
    var ms, Iu, Pg, Bu, Tg, Rg = class extends kg.EventEmitter {
        constructor(t) {
            super();
            Fn(this, Iu);
            Fn(this, Bu);
            this.isPhantom = !0;
            this.isMetaMask = !0;
            Fn(this, ms, void 0);
            this._metamask = {
                isUnlocked: () => !!this.selectedAddress
            };
            Mn(this, ms, t), sr(this, ms).start(), this.selectedAddress = null, this.chainId = "0x1", this.networkVersion = "1";
            let n = this.handleNotification.bind(this);
            t.addListener(i => {
                let o = bf.safeParse(i);
                !o.success || n(o.data)
            }), this.addListener("accountsChanged", fh(this, Iu, Pg).bind(this))
        }
        isConnected() {
            return this.selectedAddress !== null
        }
        request(t) {
            return xr(this, null, function*() {
                var i;
                let n;
                try {
                    let {
                        method: o
                    } = t, a = Eu[o];
                    if (!a) throw new Error("MethodNotFound");
                    let y = a.request.parse({
                        jsonrpc: "2.0",
                        id: crypto.randomUUID(),
                        method: o,
                        params: (i = t.params) != null ? i : []
                    });
                    if (n = a.response.parse(yield sr(this, ms).send(y)), "error" in n) throw new ro(n.error);
                    try {
                        if (o === "eth_requestAccounts") {
                            let [g] = n.result;
                            this.isConnected() || this.emit("connect", {
                                chainId: this.chainId
                            }), g !== this.selectedAddress && (this.selectedAddress = g, this.emit("accountsChanged", [g]))
                        }
                        if (o === "eth_chainId") {
                            let g = n.result;
                            g !== this.chainId && (this.chainId = g, this.networkVersion = parseInt(g.substring(2), 16).toString(), this.emit("chainChanged", this.chainId))
                        }
                        if (o === "wallet_addEthereumChain") {
                            let g = y.params[0].chainId;
                            g !== this.chainId && (this.chainId = g, this.networkVersion = parseInt(g.substring(2), 16).toString(), this.emit("chainChanged", this.chainId))
                        }
                        if (o === "wallet_switchEthereumChain") {
                            let g = y.params[0].chainId;
                            g !== this.chainId && (this.chainId = g, this.networkVersion = parseInt(g.substring(2), 16).toString(), this.emit("chainChanged", this.chainId))
                        }
                    } catch (g) {
                        console.error("event emitter error", g)
                    }
                    return n.result
                } catch (o) {
                    throw o instanceof ro ? o : o instanceof vn ? new ro({
                        code: -32e3,
                        message: "Missing or invalid parameters."
                    }, {
                        method: t.method
                    }) : o instanceof Error && o.message === "MethodNotFound" ? new ro({
                        code: -32601,
                        message: "The method does not exist / is not available."
                    }, {
                        method: t.method
                    }) : new ro({
                        code: -32603,
                        message: "Internal JSON-RPC error."
                    }, {
                        method: t.method
                    })
                }
            })
        }
        enable() {
            return this.request({
                method: "eth_requestAccounts",
                params: []
            })
        }
        sendAsync(t, n) {
            let i = "id" in t && typeof t.id != "undefined" ? t.id : null;
            this.request(t).then(o => n(null, {
                jsonrpc: "2.0",
                id: i,
                result: o
            })).catch(o => n(o, null))
        }
        send(t, n) {
            return typeof t != "string" ? this.sendAsync(t, n) : this.request({
                method: t,
                params: n
            })
        }
        handleNotification(t) {
            let n = Mu.phantom_accountChanged.notification.safeParse(t);
            if (!n.success) return;
            let i = n.data.params[0].toLowerCase();
            if (i !== this.selectedAddress) {
                let o = this.isConnected();
                this.selectedAddress = i, this.emit("accountsChanged", [i]), o || this.emit("connect", {
                    chainId: this.chainId
                })
            }
        }
    };
    ms = new WeakMap, Iu = new WeakSet, Pg = function() {
        return xr(this, null, function*() {
            if (!this.isConnected()) return;
            (yield this.request({
                method: "wallet_phantom_isTrusted",
                params: []
            })) || fh(this, Bu, Tg).call(this)
        })
    }, Bu = new WeakSet, Tg = function() {
        this.selectedAddress = null, this.emit("accountsChanged", [])
    };

    function Lg() {
        document.addEventListener("readystatechange", function r(e) {
            var t;
            if (((t = e.target) == null ? void 0 : t.readyState) === "interactive") {
                document.removeEventListener("readystatechange", r);
                let {
                    postMessage: n
                } = window.ReactNativeWebView || document.ReactNativeWebView, i = document.querySelectorAll("head link[rel^=apple-touch-icon]"), o = wf.dapp_icon.notification.parse({
                    jsonrpc: "2.0",
                    method: "dapp_icon",
                    params: i[0] ? i[0].href : null
                });
                n(JSON.stringify(o))
            }
        })
    }
    var EP = new Error("Unsupported path.");
    var Ng = jt(zg()),
        qg = jt(Ug());
    Ng.default.extend(qg.default);
    var Jn = jt(Xh()),
        Et = jt(a0()),
        Oc = jt(u0()),
        Sn = jt(Ti()),
        Zs = jt(sb()),
        $ = jt(Rs());
    var A0 = class extends TypeError {
        constructor(e, t) {
            let n, {
                    message: i,
                    ...o
                } = e,
                {
                    path: a
                } = e,
                y = a.length === 0 ? i : "At path: " + a.join(".") + " -- " + i;
            super(y), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => {
                var g;
                return (g = n) != null ? g : n = [e, ...t()]
            }
        }
    };

    function j5(r) {
        return ao(r) && typeof r[Symbol.iterator] == "function"
    }

    function ao(r) {
        return typeof r == "object" && r != null
    }

    function $n(r) {
        return typeof r == "string" ? JSON.stringify(r) : "" + r
    }

    function W5(r) {
        let {
            done: e,
            value: t
        } = r.next();
        return e ? void 0 : t
    }

    function H5(r, e, t, n) {
        if (r === !0) return;
        r === !1 ? r = {} : typeof r == "string" && (r = {
            message: r
        });
        let {
            path: i,
            branch: o
        } = e, {
            type: a
        } = t, {
            refinement: y,
            message: g = "Expected a value of type `" + a + "`" + (y ? " with refinement `" + y + "`" : "") + ", but received: `" + $n(n) + "`"
        } = r;
        return {
            value: n,
            type: a,
            refinement: y,
            key: i[i.length - 1],
            path: i,
            branch: o,
            ...r,
            message: g
        }
    }

    function* Sb(r, e, t, n) {
        j5(r) || (r = [r]);
        for (let i of r) {
            let o = H5(i, e, t, n);
            o && (yield o)
        }
    }

    function* I0(r, e, t = {}) {
        let {
            path: n = [],
            branch: i = [r],
            coerce: o = !1,
            mask: a = !1
        } = t, y = {
            path: n,
            branch: i
        };
        if (o && (r = e.coercer(r, y), a && e.type !== "type" && ao(e.schema) && ao(r) && !Array.isArray(r)))
            for (let E in r) e.schema[E] === void 0 && delete r[E];
        let g = !0;
        for (let E of e.validator(r, y)) g = !1, yield [E, void 0];
        for (let [E, A, I] of e.entries(r, y)) {
            let q = I0(A, I, {
                path: E === void 0 ? n : [...n, E],
                branch: E === void 0 ? i : [...i, A],
                coerce: o,
                mask: a
            });
            for (let L of q) L[0] ? (g = !1, yield [L[0], void 0]) : o && (A = L[1], E === void 0 ? r = A : r instanceof Map ? r.set(E, A) : r instanceof Set ? r.add(A) : ao(r) && (r[E] = A))
        }
        if (g)
            for (let E of e.refiner(r, y)) g = !1, yield [E, void 0];
        g && (yield [void 0, r])
    }
    var Tn = class {
        constructor(e) {
            let {
                type: t,
                schema: n,
                validator: i,
                refiner: o,
                coercer: a = g => g,
                entries: y = function*() {}
            } = e;
            this.type = t, this.schema = n, this.entries = y, this.coercer = a, i ? this.validator = (g, E) => {
                let A = i(g, E);
                return Sb(A, E, this, g)
            } : this.validator = () => [], o ? this.refiner = (g, E) => {
                let A = o(g, E);
                return Sb(A, E, this, g)
            } : this.refiner = () => []
        }
        assert(e) {
            return Mb(e, this)
        }
        create(e) {
            return ks(e, this)
        }
        is(e) {
            return Ab(e, this)
        }
        mask(e) {
            return V5(e, this)
        }
        validate(e, t = {}) {
            return _a(e, this, t)
        }
    };

    function Mb(r, e) {
        let t = _a(r, e);
        if (t[0]) throw t[0]
    }

    function ks(r, e) {
        let t = _a(r, e, {
            coerce: !0
        });
        if (t[0]) throw t[0];
        return t[1]
    }

    function V5(r, e) {
        let t = _a(r, e, {
            coerce: !0,
            mask: !0
        });
        if (t[0]) throw t[0];
        return t[1]
    }

    function Ab(r, e) {
        return !_a(r, e)[0]
    }

    function _a(r, e, t = {}) {
        let n = I0(r, e, t),
            i = W5(n);
        if (i[0]) return [new A0(i[0], function*() {
            for (let a of n) a[0] && (yield a[0])
        }), void 0]; {
            let o = i[1];
            return [void 0, o]
        }
    }

    function Fo(r, e) {
        return new Tn({
            type: r,
            schema: null,
            validator: e
        })
    }

    function Ib() {
        return Fo("any", () => !0)
    }

    function _t(r) {
        return new Tn({
            type: "array",
            schema: r,
            * entries(e) {
                if (r && Array.isArray(e))
                    for (let [t, n] of e.entries()) yield [t, n, r]
            },
            coercer(e) {
                return Array.isArray(e) ? e.slice() : e
            },
            validator(e) {
                return Array.isArray(e) || "Expected an array value, but received: " + $n(e)
            }
        })
    }

    function ui() {
        return Fo("boolean", r => typeof r == "boolean")
    }

    function oc(r) {
        return Fo("instance", e => e instanceof r || "Expected a `" + r.name + "` instance, but received: " + $n(e))
    }

    function Sr(r) {
        let e = $n(r),
            t = typeof r;
        return new Tn({
            type: "literal",
            schema: t === "string" || t === "number" || t === "boolean" ? r : null,
            validator(n) {
                return n === r || "Expected the literal `" + e + "`, but received: " + $n(n)
            }
        })
    }

    function G5() {
        return Fo("never", () => !1)
    }

    function St(r) {
        return new Tn({
            ...r,
            validator: (e, t) => e === null || r.validator(e, t),
            refiner: (e, t) => e === null || r.refiner(e, t)
        })
    }

    function te() {
        return Fo("number", r => typeof r == "number" && !isNaN(r) || "Expected a number, but received: " + $n(r))
    }

    function tr(r) {
        return new Tn({
            ...r,
            validator: (e, t) => e === void 0 || r.validator(e, t),
            refiner: (e, t) => e === void 0 || r.refiner(e, t)
        })
    }

    function B0(r, e) {
        return new Tn({
            type: "record",
            schema: null,
            * entries(t) {
                if (ao(t))
                    for (let n in t) {
                        let i = t[n];
                        yield [n, n, r], yield [n, i, e]
                    }
            },
            validator(t) {
                return ao(t) || "Expected an object, but received: " + $n(t)
            }
        })
    }

    function nt() {
        return Fo("string", r => typeof r == "string" || "Expected a string, but received: " + $n(r))
    }

    function R0(r) {
        let e = G5();
        return new Tn({
            type: "tuple",
            schema: null,
            * entries(t) {
                if (Array.isArray(t)) {
                    let n = Math.max(r.length, t.length);
                    for (let i = 0; i < n; i++) yield [i, t[i], r[i] || e]
                }
            },
            validator(t) {
                return Array.isArray(t) || "Expected an array, but received: " + $n(t)
            }
        })
    }

    function _e(r) {
        let e = Object.keys(r);
        return new Tn({
            type: "type",
            schema: r,
            * entries(t) {
                if (ao(t))
                    for (let n of e) yield [n, t[n], r[n]]
            },
            validator(t) {
                return ao(t) || "Expected an object, but received: " + $n(t)
            }
        })
    }

    function _n(r) {
        let e = r.map(t => t.type).join(" | ");
        return new Tn({
            type: "union",
            schema: null,
            validator(t, n) {
                let i = [];
                for (let o of r) {
                    let [...a] = I0(t, o, n), [y] = a;
                    if (y[0])
                        for (let [g] of a) g && i.push(g);
                    else return []
                }
                return ["Expected the value to satisfy a union of `" + e + "`, but received: " + $n(t), ...i]
            }
        })
    }

    function Ps() {
        return Fo("unknown", () => !0)
    }

    function Ts(r, e, t) {
        return new Tn({
            ...r,
            coercer: (n, i) => Ab(n, e) ? r.coercer(t(n, i), i) : r.coercer(n, i)
        })
    }
    var nE = jt(Kb()),
        iE = jt(lx()),
        yv = jt(W2()),
        Al = jt(vh()),
        Xt = r => Et.Buffer.isBuffer(r) ? r : r instanceof Uint8Array ? Et.Buffer.from(r.buffer, r.byteOffset, r.byteLength) : Et.Buffer.from(r),
        oE = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

    function sE(r) {
        return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
    }
    var mv = {},
        qt = {},
        Za = gv;

    function gv(r, e) {
        if (!r) throw new Error(e || "Assertion failed")
    }
    gv.equal = function(e, t, n) {
        if (e != t) throw new Error(n || "Assertion failed: " + e + " != " + t)
    };
    var Il = {
        exports: {}
    };
    typeof Object.create == "function" ? Il.exports = function(e, t) {
        t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }))
    } : Il.exports = function(e, t) {
        if (t) {
            e.super_ = t;
            var n = function() {};
            n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
        }
    };
    var aE = Za,
        fE = Il.exports;
    qt.inherits = fE;

    function uE(r, e) {
        return (r.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= r.length ? !1 : (r.charCodeAt(e + 1) & 64512) === 56320
    }

    function cE(r, e) {
        if (Array.isArray(r)) return r.slice();
        if (!r) return [];
        var t = [];
        if (typeof r == "string")
            if (e) {
                if (e === "hex")
                    for (r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 !== 0 && (r = "0" + r), i = 0; i < r.length; i += 2) t.push(parseInt(r[i] + r[i + 1], 16))
            } else
                for (var n = 0, i = 0; i < r.length; i++) {
                    var o = r.charCodeAt(i);
                    o < 128 ? t[n++] = o : o < 2048 ? (t[n++] = o >> 6 | 192, t[n++] = o & 63 | 128) : uE(r, i) ? (o = 65536 + ((o & 1023) << 10) + (r.charCodeAt(++i) & 1023), t[n++] = o >> 18 | 240, t[n++] = o >> 12 & 63 | 128, t[n++] = o >> 6 & 63 | 128, t[n++] = o & 63 | 128) : (t[n++] = o >> 12 | 224, t[n++] = o >> 6 & 63 | 128, t[n++] = o & 63 | 128)
                } else
                    for (i = 0; i < r.length; i++) t[i] = r[i] | 0;
        return t
    }
    qt.toArray = cE;

    function hE(r) {
        for (var e = "", t = 0; t < r.length; t++) e += xv(r[t].toString(16));
        return e
    }
    qt.toHex = hE;

    function bv(r) {
        var e = r >>> 24 | r >>> 8 & 65280 | r << 8 & 16711680 | (r & 255) << 24;
        return e >>> 0
    }
    qt.htonl = bv;

    function lE(r, e) {
        for (var t = "", n = 0; n < r.length; n++) {
            var i = r[n];
            e === "little" && (i = bv(i)), t += vv(i.toString(16))
        }
        return t
    }
    qt.toHex32 = lE;

    function xv(r) {
        return r.length === 1 ? "0" + r : r
    }
    qt.zero2 = xv;

    function vv(r) {
        return r.length === 7 ? "0" + r : r.length === 6 ? "00" + r : r.length === 5 ? "000" + r : r.length === 4 ? "0000" + r : r.length === 3 ? "00000" + r : r.length === 2 ? "000000" + r : r.length === 1 ? "0000000" + r : r
    }
    qt.zero8 = vv;

    function dE(r, e, t, n) {
        var i = t - e;
        aE(i % 4 === 0);
        for (var o = new Array(i / 4), a = 0, y = e; a < o.length; a++, y += 4) {
            var g;
            n === "big" ? g = r[y] << 24 | r[y + 1] << 16 | r[y + 2] << 8 | r[y + 3] : g = r[y + 3] << 24 | r[y + 2] << 16 | r[y + 1] << 8 | r[y], o[a] = g >>> 0
        }
        return o
    }
    qt.join32 = dE;

    function pE(r, e) {
        for (var t = new Array(r.length * 4), n = 0, i = 0; n < r.length; n++, i += 4) {
            var o = r[n];
            e === "big" ? (t[i] = o >>> 24, t[i + 1] = o >>> 16 & 255, t[i + 2] = o >>> 8 & 255, t[i + 3] = o & 255) : (t[i + 3] = o >>> 24, t[i + 2] = o >>> 16 & 255, t[i + 1] = o >>> 8 & 255, t[i] = o & 255)
        }
        return t
    }
    qt.split32 = pE;

    function yE(r, e) {
        return r >>> e | r << 32 - e
    }
    qt.rotr32 = yE;

    function mE(r, e) {
        return r << e | r >>> 32 - e
    }
    qt.rotl32 = mE;

    function gE(r, e) {
        return r + e >>> 0
    }
    qt.sum32 = gE;

    function bE(r, e, t) {
        return r + e + t >>> 0
    }
    qt.sum32_3 = bE;

    function xE(r, e, t, n) {
        return r + e + t + n >>> 0
    }
    qt.sum32_4 = xE;

    function vE(r, e, t, n, i) {
        return r + e + t + n + i >>> 0
    }
    qt.sum32_5 = vE;

    function wE(r, e, t, n) {
        var i = r[e],
            o = r[e + 1],
            a = n + o >>> 0,
            y = (a < n ? 1 : 0) + t + i;
        r[e] = y >>> 0, r[e + 1] = a
    }
    qt.sum64 = wE;

    function _E(r, e, t, n) {
        var i = e + n >>> 0,
            o = (i < e ? 1 : 0) + r + t;
        return o >>> 0
    }
    qt.sum64_hi = _E;

    function EE(r, e, t, n) {
        var i = e + n;
        return i >>> 0
    }
    qt.sum64_lo = EE;

    function SE(r, e, t, n, i, o, a, y) {
        var g = 0,
            E = e;
        E = E + n >>> 0, g += E < e ? 1 : 0, E = E + o >>> 0, g += E < o ? 1 : 0, E = E + y >>> 0, g += E < y ? 1 : 0;
        var A = r + t + i + a + g;
        return A >>> 0
    }
    qt.sum64_4_hi = SE;

    function ME(r, e, t, n, i, o, a, y) {
        var g = e + n + o + y;
        return g >>> 0
    }
    qt.sum64_4_lo = ME;

    function AE(r, e, t, n, i, o, a, y, g, E) {
        var A = 0,
            I = e;
        I = I + n >>> 0, A += I < e ? 1 : 0, I = I + o >>> 0, A += I < o ? 1 : 0, I = I + y >>> 0, A += I < y ? 1 : 0, I = I + E >>> 0, A += I < E ? 1 : 0;
        var q = r + t + i + a + g + A;
        return q >>> 0
    }
    qt.sum64_5_hi = AE;

    function IE(r, e, t, n, i, o, a, y, g, E) {
        var A = e + n + o + y + E;
        return A >>> 0
    }
    qt.sum64_5_lo = IE;

    function BE(r, e, t) {
        var n = e << 32 - t | r >>> t;
        return n >>> 0
    }
    qt.rotr64_hi = BE;

    function RE(r, e, t) {
        var n = r << 32 - t | e >>> t;
        return n >>> 0
    }
    qt.rotr64_lo = RE;

    function kE(r, e, t) {
        return r >>> t
    }
    qt.shr64_hi = kE;

    function PE(r, e, t) {
        var n = r << 32 - t | e >>> t;
        return n >>> 0
    }
    qt.shr64_lo = PE;
    var Ys = {},
        H2 = qt,
        TE = Za;

    function Gc() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
    }
    Ys.BlockHash = Gc;
    Gc.prototype.update = function(e, t) {
        if (e = H2.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
            e = this.pending;
            var n = e.length % this._delta8;
            this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = H2.join32(e, 0, e.length - n, this.endian);
            for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
        }
        return this
    };
    Gc.prototype.digest = function(e) {
        return this.update(this._pad()), TE(this.pending === null), this._digest(e)
    };
    Gc.prototype._pad = function() {
        var e = this.pendingTotal,
            t = this._delta8,
            n = t - (e + this.padLength) % t,
            i = new Array(n + this.padLength);
        i[0] = 128;
        for (var o = 1; o < n; o++) i[o] = 0;
        if (e <<= 3, this.endian === "big") {
            for (var a = 8; a < this.padLength; a++) i[o++] = 0;
            i[o++] = 0, i[o++] = 0, i[o++] = 0, i[o++] = 0, i[o++] = e >>> 24 & 255, i[o++] = e >>> 16 & 255, i[o++] = e >>> 8 & 255, i[o++] = e & 255
        } else
            for (i[o++] = e & 255, i[o++] = e >>> 8 & 255, i[o++] = e >>> 16 & 255, i[o++] = e >>> 24 & 255, i[o++] = 0, i[o++] = 0, i[o++] = 0, i[o++] = 0, a = 8; a < this.padLength; a++) i[o++] = 0;
        return i
    };
    var Js = {},
        Mi = {},
        LE = qt,
        xi = LE.rotr32;

    function zE(r, e, t, n) {
        if (r === 0) return wv(e, t, n);
        if (r === 1 || r === 3) return Ev(e, t, n);
        if (r === 2) return _v(e, t, n)
    }
    Mi.ft_1 = zE;

    function wv(r, e, t) {
        return r & e ^ ~r & t
    }
    Mi.ch32 = wv;

    function _v(r, e, t) {
        return r & e ^ r & t ^ e & t
    }
    Mi.maj32 = _v;

    function Ev(r, e, t) {
        return r ^ e ^ t
    }
    Mi.p32 = Ev;

    function UE(r) {
        return xi(r, 2) ^ xi(r, 13) ^ xi(r, 22)
    }
    Mi.s0_256 = UE;

    function NE(r) {
        return xi(r, 6) ^ xi(r, 11) ^ xi(r, 25)
    }
    Mi.s1_256 = NE;

    function qE(r) {
        return xi(r, 7) ^ xi(r, 18) ^ r >>> 3
    }
    Mi.g0_256 = qE;

    function FE(r) {
        return xi(r, 17) ^ xi(r, 19) ^ r >>> 10
    }
    Mi.g1_256 = FE;
    var Ws = qt,
        CE = Ys,
        OE = Mi,
        yl = Ws.rotl32,
        Da = Ws.sum32,
        DE = Ws.sum32_5,
        KE = OE.ft_1,
        Sv = CE.BlockHash,
        $E = [1518500249, 1859775393, 2400959708, 3395469782];

    function _i() {
        if (!(this instanceof _i)) return new _i;
        Sv.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
    }
    Ws.inherits(_i, Sv);
    var jE = _i;
    _i.blockSize = 512;
    _i.outSize = 160;
    _i.hmacStrength = 80;
    _i.padLength = 64;
    _i.prototype._update = function(e, t) {
        for (var n = this.W, i = 0; i < 16; i++) n[i] = e[t + i];
        for (; i < n.length; i++) n[i] = yl(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
        var o = this.h[0],
            a = this.h[1],
            y = this.h[2],
            g = this.h[3],
            E = this.h[4];
        for (i = 0; i < n.length; i++) {
            var A = ~~(i / 20),
                I = DE(yl(o, 5), KE(A, a, y, g), E, n[i], $E[A]);
            E = g, g = y, y = yl(a, 30), a = o, o = I
        }
        this.h[0] = Da(this.h[0], o), this.h[1] = Da(this.h[1], a), this.h[2] = Da(this.h[2], y), this.h[3] = Da(this.h[3], g), this.h[4] = Da(this.h[4], E)
    };
    _i.prototype._digest = function(e) {
        return e === "hex" ? Ws.toHex32(this.h, "big") : Ws.split32(this.h, "big")
    };
    var Hs = qt,
        WE = Ys,
        Xs = Mi,
        HE = Za,
        Zn = Hs.sum32,
        VE = Hs.sum32_4,
        GE = Hs.sum32_5,
        ZE = Xs.ch32,
        YE = Xs.maj32,
        JE = Xs.s0_256,
        XE = Xs.s1_256,
        QE = Xs.g0_256,
        eS = Xs.g1_256,
        Mv = WE.BlockHash,
        tS = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

    function Ei() {
        if (!(this instanceof Ei)) return new Ei;
        Mv.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = tS, this.W = new Array(64)
    }
    Hs.inherits(Ei, Mv);
    var Av = Ei;
    Ei.blockSize = 512;
    Ei.outSize = 256;
    Ei.hmacStrength = 192;
    Ei.padLength = 64;
    Ei.prototype._update = function(e, t) {
        for (var n = this.W, i = 0; i < 16; i++) n[i] = e[t + i];
        for (; i < n.length; i++) n[i] = VE(eS(n[i - 2]), n[i - 7], QE(n[i - 15]), n[i - 16]);
        var o = this.h[0],
            a = this.h[1],
            y = this.h[2],
            g = this.h[3],
            E = this.h[4],
            A = this.h[5],
            I = this.h[6],
            q = this.h[7];
        for (HE(this.k.length === n.length), i = 0; i < n.length; i++) {
            var L = GE(q, XE(E), ZE(E, A, I), this.k[i], n[i]),
                O = Zn(JE(o), YE(o, a, y));
            q = I, I = A, A = E, E = Zn(g, L), g = y, y = a, a = o, o = Zn(L, O)
        }
        this.h[0] = Zn(this.h[0], o), this.h[1] = Zn(this.h[1], a), this.h[2] = Zn(this.h[2], y), this.h[3] = Zn(this.h[3], g), this.h[4] = Zn(this.h[4], E), this.h[5] = Zn(this.h[5], A), this.h[6] = Zn(this.h[6], I), this.h[7] = Zn(this.h[7], q)
    };
    Ei.prototype._digest = function(e) {
        return e === "hex" ? Hs.toHex32(this.h, "big") : Hs.split32(this.h, "big")
    };
    var Bl = qt,
        Iv = Av;

    function Vi() {
        if (!(this instanceof Vi)) return new Vi;
        Iv.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
    }
    Bl.inherits(Vi, Iv);
    var rS = Vi;
    Vi.blockSize = 512;
    Vi.outSize = 224;
    Vi.hmacStrength = 192;
    Vi.padLength = 64;
    Vi.prototype._digest = function(e) {
        return e === "hex" ? Bl.toHex32(this.h.slice(0, 7), "big") : Bl.split32(this.h.slice(0, 7), "big")
    };
    var bn = qt,
        nS = Ys,
        iS = Za,
        vi = bn.rotr64_hi,
        wi = bn.rotr64_lo,
        Bv = bn.shr64_hi,
        Rv = bn.shr64_lo,
        _o = bn.sum64,
        ml = bn.sum64_hi,
        gl = bn.sum64_lo,
        oS = bn.sum64_4_hi,
        sS = bn.sum64_4_lo,
        aS = bn.sum64_5_hi,
        fS = bn.sum64_5_lo,
        kv = nS.BlockHash,
        uS = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

    function Xn() {
        if (!(this instanceof Xn)) return new Xn;
        kv.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = uS, this.W = new Array(160)
    }
    bn.inherits(Xn, kv);
    var Pv = Xn;
    Xn.blockSize = 1024;
    Xn.outSize = 512;
    Xn.hmacStrength = 192;
    Xn.padLength = 128;
    Xn.prototype._prepareBlock = function(e, t) {
        for (var n = this.W, i = 0; i < 32; i++) n[i] = e[t + i];
        for (; i < n.length; i += 2) {
            var o = vS(n[i - 4], n[i - 3]),
                a = wS(n[i - 4], n[i - 3]),
                y = n[i - 14],
                g = n[i - 13],
                E = bS(n[i - 30], n[i - 29]),
                A = xS(n[i - 30], n[i - 29]),
                I = n[i - 32],
                q = n[i - 31];
            n[i] = oS(o, a, y, g, E, A, I, q), n[i + 1] = sS(o, a, y, g, E, A, I, q)
        }
    };
    Xn.prototype._update = function(e, t) {
        this._prepareBlock(e, t);
        var n = this.W,
            i = this.h[0],
            o = this.h[1],
            a = this.h[2],
            y = this.h[3],
            g = this.h[4],
            E = this.h[5],
            A = this.h[6],
            I = this.h[7],
            q = this.h[8],
            L = this.h[9],
            O = this.h[10],
            Z = this.h[11],
            ge = this.h[12],
            ce = this.h[13],
            Xe = this.h[14],
            xe = this.h[15];
        iS(this.k.length === n.length);
        for (var ie = 0; ie < n.length; ie += 2) {
            var ae = Xe,
                be = xe,
                we = mS(q, L),
                he = gS(q, L),
                gt = cS(q, L, O, Z, ge),
                T = hS(q, L, O, Z, ge, ce),
                m = this.k[ie],
                w = this.k[ie + 1],
                l = n[ie],
                s = n[ie + 1],
                f = aS(ae, be, we, he, gt, T, m, w, l, s),
                h = fS(ae, be, we, he, gt, T, m, w, l, s);
            ae = pS(i, o), be = yS(i, o), we = lS(i, o, a, y, g), he = dS(i, o, a, y, g, E);
            var p = ml(ae, be, we, he),
                d = gl(ae, be, we, he);
            Xe = ge, xe = ce, ge = O, ce = Z, O = q, Z = L, q = ml(A, I, f, h), L = gl(I, I, f, h), A = g, I = E, g = a, E = y, a = i, y = o, i = ml(f, h, p, d), o = gl(f, h, p, d)
        }
        _o(this.h, 0, i, o), _o(this.h, 2, a, y), _o(this.h, 4, g, E), _o(this.h, 6, A, I), _o(this.h, 8, q, L), _o(this.h, 10, O, Z), _o(this.h, 12, ge, ce), _o(this.h, 14, Xe, xe)
    };
    Xn.prototype._digest = function(e) {
        return e === "hex" ? bn.toHex32(this.h, "big") : bn.split32(this.h, "big")
    };

    function cS(r, e, t, n, i) {
        var o = r & t ^ ~r & i;
        return o < 0 && (o += 4294967296), o
    }

    function hS(r, e, t, n, i, o) {
        var a = e & n ^ ~e & o;
        return a < 0 && (a += 4294967296), a
    }

    function lS(r, e, t, n, i) {
        var o = r & t ^ r & i ^ t & i;
        return o < 0 && (o += 4294967296), o
    }

    function dS(r, e, t, n, i, o) {
        var a = e & n ^ e & o ^ n & o;
        return a < 0 && (a += 4294967296), a
    }

    function pS(r, e) {
        var t = vi(r, e, 28),
            n = vi(e, r, 2),
            i = vi(e, r, 7),
            o = t ^ n ^ i;
        return o < 0 && (o += 4294967296), o
    }

    function yS(r, e) {
        var t = wi(r, e, 28),
            n = wi(e, r, 2),
            i = wi(e, r, 7),
            o = t ^ n ^ i;
        return o < 0 && (o += 4294967296), o
    }

    function mS(r, e) {
        var t = vi(r, e, 14),
            n = vi(r, e, 18),
            i = vi(e, r, 9),
            o = t ^ n ^ i;
        return o < 0 && (o += 4294967296), o
    }

    function gS(r, e) {
        var t = wi(r, e, 14),
            n = wi(r, e, 18),
            i = wi(e, r, 9),
            o = t ^ n ^ i;
        return o < 0 && (o += 4294967296), o
    }

    function bS(r, e) {
        var t = vi(r, e, 1),
            n = vi(r, e, 8),
            i = Bv(r, e, 7),
            o = t ^ n ^ i;
        return o < 0 && (o += 4294967296), o
    }

    function xS(r, e) {
        var t = wi(r, e, 1),
            n = wi(r, e, 8),
            i = Rv(r, e, 7),
            o = t ^ n ^ i;
        return o < 0 && (o += 4294967296), o
    }

    function vS(r, e) {
        var t = vi(r, e, 19),
            n = vi(e, r, 29),
            i = Bv(r, e, 6),
            o = t ^ n ^ i;
        return o < 0 && (o += 4294967296), o
    }

    function wS(r, e) {
        var t = wi(r, e, 19),
            n = wi(e, r, 29),
            i = Rv(r, e, 6),
            o = t ^ n ^ i;
        return o < 0 && (o += 4294967296), o
    }
    var Rl = qt,
        Tv = Pv;

    function Gi() {
        if (!(this instanceof Gi)) return new Gi;
        Tv.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
    }
    Rl.inherits(Gi, Tv);
    var _S = Gi;
    Gi.blockSize = 1024;
    Gi.outSize = 384;
    Gi.hmacStrength = 192;
    Gi.padLength = 128;
    Gi.prototype._digest = function(e) {
        return e === "hex" ? Rl.toHex32(this.h.slice(0, 12), "big") : Rl.split32(this.h.slice(0, 12), "big")
    };
    Js.sha1 = jE;
    Js.sha224 = rS;
    Js.sha256 = Av;
    Js.sha384 = _S;
    Js.sha512 = Pv;
    var Lv = {},
        Yo = qt,
        ES = Ys,
        Fc = Yo.rotl32,
        V2 = Yo.sum32,
        Ka = Yo.sum32_3,
        G2 = Yo.sum32_4,
        zv = ES.BlockHash;

    function Si() {
        if (!(this instanceof Si)) return new Si;
        zv.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
    }
    Yo.inherits(Si, zv);
    Lv.ripemd160 = Si;
    Si.blockSize = 512;
    Si.outSize = 160;
    Si.hmacStrength = 192;
    Si.padLength = 64;
    Si.prototype._update = function(e, t) {
        for (var n = this.h[0], i = this.h[1], o = this.h[2], a = this.h[3], y = this.h[4], g = n, E = i, A = o, I = a, q = y, L = 0; L < 80; L++) {
            var O = V2(Fc(G2(n, Z2(L, i, o, a), e[AS[L] + t], SS(L)), BS[L]), y);
            n = y, y = a, a = Fc(o, 10), o = i, i = O, O = V2(Fc(G2(g, Z2(79 - L, E, A, I), e[IS[L] + t], MS(L)), RS[L]), q), g = q, q = I, I = Fc(A, 10), A = E, E = O
        }
        O = Ka(this.h[1], o, I), this.h[1] = Ka(this.h[2], a, q), this.h[2] = Ka(this.h[3], y, g), this.h[3] = Ka(this.h[4], n, E), this.h[4] = Ka(this.h[0], i, A), this.h[0] = O
    };
    Si.prototype._digest = function(e) {
        return e === "hex" ? Yo.toHex32(this.h, "little") : Yo.split32(this.h, "little")
    };

    function Z2(r, e, t, n) {
        return r <= 15 ? e ^ t ^ n : r <= 31 ? e & t | ~e & n : r <= 47 ? (e | ~t) ^ n : r <= 63 ? e & n | t & ~n : e ^ (t | ~n)
    }

    function SS(r) {
        return r <= 15 ? 0 : r <= 31 ? 1518500249 : r <= 47 ? 1859775393 : r <= 63 ? 2400959708 : 2840853838
    }

    function MS(r) {
        return r <= 15 ? 1352829926 : r <= 31 ? 1548603684 : r <= 47 ? 1836072691 : r <= 63 ? 2053994217 : 0
    }
    var AS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
        IS = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
        BS = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
        RS = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
        kS = qt,
        PS = Za;

    function Vs(r, e, t) {
        if (!(this instanceof Vs)) return new Vs(r, e, t);
        this.Hash = r, this.blockSize = r.blockSize / 8, this.outSize = r.outSize / 8, this.inner = null, this.outer = null, this._init(kS.toArray(e, t))
    }
    var TS = Vs;
    Vs.prototype._init = function(e) {
        e.length > this.blockSize && (e = new this.Hash().update(e).digest()), PS(e.length <= this.blockSize);
        for (var t = e.length; t < this.blockSize; t++) e.push(0);
        for (t = 0; t < e.length; t++) e[t] ^= 54;
        for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++) e[t] ^= 106;
        this.outer = new this.Hash().update(e)
    };
    Vs.prototype.update = function(e, t) {
        return this.inner.update(e, t), this
    };
    Vs.prototype.digest = function(e) {
        return this.outer.update(this.inner.digest()), this.outer.digest(e)
    };
    (function(r) {
        var e = r;
        e.utils = qt, e.common = Ys, e.sha = Js, e.ripemd = Lv, e.hmac = TS, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160
    })(mv);
    var LS = mv,
        zS = "logger/5.6.0",
        Y2 = !1,
        J2 = !1,
        Dc = {
            debug: 1,
            default: 2,
            info: 2,
            warning: 3,
            error: 4,
            off: 5
        },
        X2 = Dc.default,
        bl = null;

    function US() {
        try {
            let r = [];
            if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                    try {
                        if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                    } catch {
                        r.push(e)
                    }
                }), r.length) throw new Error("missing " + r.join(", "));
            if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
        } catch (r) {
            return r.message
        }
        return null
    }
    var Q2 = US(),
        kl;
    (function(r) {
        r.DEBUG = "DEBUG", r.INFO = "INFO", r.WARNING = "WARNING", r.ERROR = "ERROR", r.OFF = "OFF"
    })(kl || (kl = {}));
    var Yn;
    (function(r) {
        r.UNKNOWN_ERROR = "UNKNOWN_ERROR", r.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", r.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", r.NETWORK_ERROR = "NETWORK_ERROR", r.SERVER_ERROR = "SERVER_ERROR", r.TIMEOUT = "TIMEOUT", r.BUFFER_OVERRUN = "BUFFER_OVERRUN", r.NUMERIC_FAULT = "NUMERIC_FAULT", r.MISSING_NEW = "MISSING_NEW", r.INVALID_ARGUMENT = "INVALID_ARGUMENT", r.MISSING_ARGUMENT = "MISSING_ARGUMENT", r.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", r.CALL_EXCEPTION = "CALL_EXCEPTION", r.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", r.NONCE_EXPIRED = "NONCE_EXPIRED", r.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", r.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", r.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"
    })(Yn || (Yn = {}));
    var ev = "0123456789abcdef",
        hr = class {
            constructor(e) {
                Object.defineProperty(this, "version", {
                    enumerable: !0,
                    value: e,
                    writable: !1
                })
            }
            _log(e, t) {
                let n = e.toLowerCase();
                Dc[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(X2 > Dc[n]) && console.log.apply(console, t)
            }
            debug(...e) {
                this._log(hr.levels.DEBUG, e)
            }
            info(...e) {
                this._log(hr.levels.INFO, e)
            }
            warn(...e) {
                this._log(hr.levels.WARNING, e)
            }
            makeError(e, t, n) {
                if (J2) return this.makeError("censored error", t, {});
                t || (t = hr.errors.UNKNOWN_ERROR), n || (n = {});
                let i = [];
                Object.keys(n).forEach(g => {
                    let E = n[g];
                    try {
                        if (E instanceof Uint8Array) {
                            let A = "";
                            for (let I = 0; I < E.length; I++) A += ev[E[I] >> 4], A += ev[E[I] & 15];
                            i.push(g + "=Uint8Array(0x" + A + ")")
                        } else i.push(g + "=" + JSON.stringify(E))
                    } catch {
                        i.push(g + "=" + JSON.stringify(n[g].toString()))
                    }
                }), i.push(`code=${t}`), i.push(`version=${this.version}`);
                let o = e,
                    a = "";
                switch (t) {
                    case Yn.NUMERIC_FAULT: {
                        a = "NUMERIC_FAULT";
                        let g = e;
                        switch (g) {
                            case "overflow":
                            case "underflow":
                            case "division-by-zero":
                                a += "-" + g;
                                break;
                            case "negative-power":
                            case "negative-width":
                                a += "-unsupported";
                                break;
                            case "unbound-bitwise-result":
                                a += "-unbound-result";
                                break
                        }
                        break
                    }
                    case Yn.CALL_EXCEPTION:
                    case Yn.INSUFFICIENT_FUNDS:
                    case Yn.MISSING_NEW:
                    case Yn.NONCE_EXPIRED:
                    case Yn.REPLACEMENT_UNDERPRICED:
                    case Yn.TRANSACTION_REPLACED:
                    case Yn.UNPREDICTABLE_GAS_LIMIT:
                        a = t;
                        break
                }
                a && (e += " [ See: https://links.ethers.org/v5-errors-" + a + " ]"), i.length && (e += " (" + i.join(", ") + ")");
                let y = new Error(e);
                return y.reason = o, y.code = t, Object.keys(n).forEach(function(g) {
                    y[g] = n[g]
                }), y
            }
            throwError(e, t, n) {
                throw this.makeError(e, t, n)
            }
            throwArgumentError(e, t, n) {
                return this.throwError(e, hr.errors.INVALID_ARGUMENT, {
                    argument: t,
                    value: n
                })
            }
            assert(e, t, n, i) {
                e || this.throwError(t, n, i)
            }
            assertArgument(e, t, n, i) {
                e || this.throwArgumentError(t, n, i)
            }
            checkNormalize(e) {
                Q2 && this.throwError("platform missing String.prototype.normalize", hr.errors.UNSUPPORTED_OPERATION, {
                    operation: "String.prototype.normalize",
                    form: Q2
                })
            }
            checkSafeUint53(e, t) {
                typeof e == "number" && (t == null && (t = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(t, hr.errors.NUMERIC_FAULT, {
                    operation: "checkSafeInteger",
                    fault: "out-of-safe-range",
                    value: e
                }), e % 1 && this.throwError(t, hr.errors.NUMERIC_FAULT, {
                    operation: "checkSafeInteger",
                    fault: "non-integer",
                    value: e
                }))
            }
            checkArgumentCount(e, t, n) {
                n ? n = ": " + n : n = "", e < t && this.throwError("missing argument" + n, hr.errors.MISSING_ARGUMENT, {
                    count: e,
                    expectedCount: t
                }), e > t && this.throwError("too many arguments" + n, hr.errors.UNEXPECTED_ARGUMENT, {
                    count: e,
                    expectedCount: t
                })
            }
            checkNew(e, t) {
                (e === Object || e == null) && this.throwError("missing new", hr.errors.MISSING_NEW, {
                    name: t.name
                })
            }
            checkAbstract(e, t) {
                e === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", hr.errors.UNSUPPORTED_OPERATION, {
                    name: e.name,
                    operation: "new"
                }) : (e === Object || e == null) && this.throwError("missing new", hr.errors.MISSING_NEW, {
                    name: t.name
                })
            }
            static globalLogger() {
                return bl || (bl = new hr(zS)), bl
            }
            static setCensorship(e, t) {
                if (!e && t && this.globalLogger().throwError("cannot permanently disable censorship", hr.errors.UNSUPPORTED_OPERATION, {
                        operation: "setCensorship"
                    }), Y2) {
                    if (!e) return;
                    this.globalLogger().throwError("error censorship permanent", hr.errors.UNSUPPORTED_OPERATION, {
                        operation: "setCensorship"
                    })
                }
                J2 = !!e, Y2 = !!t
            }
            static setLogLevel(e) {
                let t = Dc[e.toLowerCase()];
                if (t == null) {
                    hr.globalLogger().warn("invalid log level - " + e);
                    return
                }
                X2 = t
            }
            static from(e) {
                return new hr(e)
            }
        };
    hr.errors = Yn;
    hr.levels = kl;
    var NS = "bytes/5.6.0",
        xl = new hr(NS);

    function qS(r) {
        return !!r.toHexString
    }

    function Kc(r) {
        return r.slice || (r.slice = function() {
            let e = Array.prototype.slice.call(arguments);
            return Kc(new Uint8Array(Array.prototype.slice.apply(r, e)))
        }), r
    }

    function tv(r) {
        return typeof r == "number" && r == r && r % 1 === 0
    }

    function FS(r) {
        if (r == null) return !1;
        if (r.constructor === Uint8Array) return !0;
        if (typeof r == "string" || !tv(r.length) || r.length < 0) return !1;
        for (let e = 0; e < r.length; e++) {
            let t = r[e];
            if (!tv(t) || t < 0 || t >= 256) return !1
        }
        return !0
    }

    function CS(r, e) {
        if (e || (e = {}), typeof r == "number") {
            xl.checkSafeUint53(r, "invalid arrayify value");
            let t = [];
            for (; r;) t.unshift(r & 255), r = parseInt(String(r / 256));
            return t.length === 0 && t.push(0), Kc(new Uint8Array(t))
        }
        if (e.allowMissingPrefix && typeof r == "string" && r.substring(0, 2) !== "0x" && (r = "0x" + r), qS(r) && (r = r.toHexString()), OS(r)) {
            let t = r.substring(2);
            t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : xl.throwArgumentError("hex data is odd-length", "value", r));
            let n = [];
            for (let i = 0; i < t.length; i += 2) n.push(parseInt(t.substring(i, i + 2), 16));
            return Kc(new Uint8Array(n))
        }
        return FS(r) ? Kc(new Uint8Array(r)) : xl.throwArgumentError("invalid arrayify value", "value", r)
    }

    function OS(r, e) {
        return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || e && r.length !== 2 + 2 * e)
    }
    var DS = "sha2/5.6.0";
    new hr(DS);

    function rv(r) {
        return "0x" + LS.sha256().update(CS(r)).digest("hex")
    }
    var Pl = class {
        constructor(e) {
            Object.assign(this, e)
        }
        encode() {
            return Et.Buffer.from((0, Zs.serialize)($c, this))
        }
        static decode(e) {
            return (0, Zs.deserialize)($c, this, e)
        }
        static decodeUnchecked(e) {
            return (0, Zs.deserializeUnchecked)($c, this, e)
        }
    };
    var $c = new Map,
        KS = 32;

    function $S(r) {
        return r._bn !== void 0
    }
    var Mt = class extends Pl {
        constructor(e) {
            if (super({}), this._bn = void 0, $S(e)) this._bn = e._bn;
            else {
                if (typeof e == "string") {
                    let t = Sn.default.decode(e);
                    if (t.length != 32) throw new Error("Invalid public key input");
                    this._bn = new Oc.default(t)
                } else this._bn = new Oc.default(e);
                if (this._bn.byteLength() > 32) throw new Error("Invalid public key input")
            }
        }
        equals(e) {
            return this._bn.eq(e._bn)
        }
        toBase58() {
            return Sn.default.encode(this.toBytes())
        }
        toJSON() {
            return this.toBase58()
        }
        toBytes() {
            return this.toBuffer()
        }
        toBuffer() {
            let e = this._bn.toArrayLike(Et.Buffer);
            if (e.length === 32) return e;
            let t = Et.Buffer.alloc(32);
            return e.copy(t, 32 - e.length), t
        }
        toString() {
            return this.toBase58()
        }
        static async createWithSeed(e, t, n) {
            let i = Et.Buffer.concat([e.toBuffer(), Et.Buffer.from(t), n.toBuffer()]),
                o = rv(new Uint8Array(i)).slice(2);
            return new Mt(Et.Buffer.from(o, "hex"))
        }
        static createProgramAddressSync(e, t) {
            let n = Et.Buffer.alloc(0);
            e.forEach(function(a) {
                if (a.length > KS) throw new TypeError("Max seed length exceeded");
                n = Et.Buffer.concat([n, Xt(a)])
            }), n = Et.Buffer.concat([n, t.toBuffer(), Et.Buffer.from("ProgramDerivedAddress")]);
            let i = rv(new Uint8Array(n)).slice(2),
                o = new Oc.default(i, 16).toArray(void 0, 32);
            if (nv(o)) throw new Error("Invalid seeds, address must fall off the curve");
            return new Mt(o)
        }
        static async createProgramAddress(e, t) {
            return this.createProgramAddressSync(e, t)
        }
        static findProgramAddressSync(e, t) {
            let n = 255,
                i;
            for (; n != 0;) {
                try {
                    let o = e.concat(Et.Buffer.from([n]));
                    i = this.createProgramAddressSync(o, t)
                } catch (o) {
                    if (o instanceof TypeError) throw o;
                    n--;
                    continue
                }
                return [i, n]
            }
            throw new Error("Unable to find a viable program address nonce")
        }
        static async findProgramAddress(e, t) {
            return this.findProgramAddressSync(e, t)
        }
        static isOnCurve(e) {
            let t = new Mt(e);
            return nv(t.toBytes()) == 1
        }
    };
    Mt.default = new Mt("11111111111111111111111111111111");
    $c.set(Mt, {
        kind: "struct",
        fields: [
            ["_bn", "u256"]
        ]
    });
    var zt = Jn.default.lowlevel;

    function nv(r) {
        var e = [zt.gf(), zt.gf(), zt.gf(), zt.gf()],
            t = zt.gf(),
            n = zt.gf(),
            i = zt.gf(),
            o = zt.gf(),
            a = zt.gf(),
            y = zt.gf(),
            g = zt.gf();
        return zt.set25519(e[2], jS), zt.unpack25519(e[1], r), zt.S(i, e[1]), zt.M(o, i, zt.D), zt.Z(i, i, e[2]), zt.A(o, e[2], o), zt.S(a, o), zt.S(y, a), zt.M(g, y, a), zt.M(t, g, i), zt.M(t, t, o), zt.pow2523(t, t), zt.M(t, t, i), zt.M(t, t, o), zt.M(t, t, o), zt.M(e[0], t, o), zt.S(n, e[0]), zt.M(n, n, o), iv(n, i) && zt.M(e[0], e[0], WS), zt.S(n, e[0]), zt.M(n, n, o), iv(n, i) ? 0 : 1
    }
    var jS = zt.gf([1]),
        WS = zt.gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

    function iv(r, e) {
        var t = new Uint8Array(32),
            n = new Uint8Array(32);
        return zt.pack25519(t, r), zt.pack25519(n, e), zt.crypto_verify_32(t, 0, n, 0)
    }
    var wz = new Mt("BPFLoader1111111111111111111111111111111111"),
        rr = (r = "publicKey") => $.blob(32, r),
        $a = (r = "string") => {
            let e = $.struct([$.u32("length"), $.u32("lengthPadding"), $.blob($.offset($.u32(), -8), "chars")], r),
                t = e.decode.bind(e),
                n = e.encode.bind(e),
                i = e;
            return i.decode = (o, a) => t(o, a).chars.toString(), i.encode = (o, a, y) => {
                let g = {
                    chars: Et.Buffer.from(o, "utf8")
                };
                return n(g, a, y)
            }, i.alloc = o => $.u32().span + $.u32().span + Et.Buffer.from(o, "utf8").length, i
        },
        HS = (r = "authorized") => $.struct([rr("staker"), rr("withdrawer")], r),
        VS = (r = "lockup") => $.struct([$.ns64("unixTimestamp"), $.ns64("epoch"), rr("custodian")], r),
        GS = (r = "voteInit") => $.struct([rr("nodePubkey"), rr("authorizedVoter"), rr("authorizedWithdrawer"), $.u8("commission")], r);

    function ZS(r, e) {
        let t = 0;
        return r.layout.fields.forEach(n => {
            n.span >= 0 ? t += n.span : typeof n.alloc == "function" && (t += n.alloc(e[n.property]))
        }), t
    }

    function ja(r) {
        let e = 0,
            t = 0;
        for (;;) {
            let n = r.shift();
            if (e |= (n & 127) << t * 7, t += 1, (n & 128) === 0) break
        }
        return e
    }

    function Wa(r, e) {
        let t = e;
        for (;;) {
            let n = t & 127;
            if (t >>= 7, t == 0) {
                r.push(n);
                break
            } else n |= 128, r.push(n)
        }
    }
    var Cc = 32,
        Mo = class {
            constructor(e) {
                this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = e.header, this.accountKeys = e.accountKeys.map(t => new Mt(t)), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach(t => this.indexToProgramIds.set(t.programIdIndex, this.accountKeys[t.programIdIndex]))
            }
            isAccountSigner(e) {
                return e < this.header.numRequiredSignatures
            }
            isAccountWritable(e) {
                return e < this.header.numRequiredSignatures - this.header.numReadonlySignedAccounts || e >= this.header.numRequiredSignatures && e < this.accountKeys.length - this.header.numReadonlyUnsignedAccounts
            }
            isProgramId(e) {
                return this.indexToProgramIds.has(e)
            }
            programIds() {
                return [...this.indexToProgramIds.values()]
            }
            nonProgramIds() {
                return this.accountKeys.filter((e, t) => !this.isProgramId(t))
            }
            serialize() {
                let e = this.accountKeys.length,
                    t = [];
                Wa(t, e);
                let n = this.instructions.map(I => {
                        let {
                            accounts: q,
                            programIdIndex: L
                        } = I, O = Array.from(Sn.default.decode(I.data)), Z = [];
                        Wa(Z, q.length);
                        let ge = [];
                        return Wa(ge, O.length), {
                            programIdIndex: L,
                            keyIndicesCount: Et.Buffer.from(Z),
                            keyIndices: q,
                            dataLength: Et.Buffer.from(ge),
                            data: O
                        }
                    }),
                    i = [];
                Wa(i, n.length);
                let o = Et.Buffer.alloc(jc);
                Et.Buffer.from(i).copy(o);
                let a = i.length;
                n.forEach(I => {
                    a += $.struct([$.u8("programIdIndex"), $.blob(I.keyIndicesCount.length, "keyIndicesCount"), $.seq($.u8("keyIndex"), I.keyIndices.length, "keyIndices"), $.blob(I.dataLength.length, "dataLength"), $.seq($.u8("userdatum"), I.data.length, "data")]).encode(I, o, a)
                }), o = o.slice(0, a);
                let y = $.struct([$.blob(1, "numRequiredSignatures"), $.blob(1, "numReadonlySignedAccounts"), $.blob(1, "numReadonlyUnsignedAccounts"), $.blob(t.length, "keyCount"), $.seq(rr("key"), e, "keys"), rr("recentBlockhash")]),
                    g = {
                        numRequiredSignatures: Et.Buffer.from([this.header.numRequiredSignatures]),
                        numReadonlySignedAccounts: Et.Buffer.from([this.header.numReadonlySignedAccounts]),
                        numReadonlyUnsignedAccounts: Et.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
                        keyCount: Et.Buffer.from(t),
                        keys: this.accountKeys.map(I => Xt(I.toBytes())),
                        recentBlockhash: Sn.default.decode(this.recentBlockhash)
                    },
                    E = Et.Buffer.alloc(2048),
                    A = y.encode(g, E);
                return o.copy(E, A), E.slice(0, A + o.length)
            }
            static from(e) {
                let t = [...e],
                    n = t.shift(),
                    i = t.shift(),
                    o = t.shift(),
                    a = ja(t),
                    y = [];
                for (let q = 0; q < a; q++) {
                    let L = t.slice(0, Cc);
                    t = t.slice(Cc), y.push(Sn.default.encode(Et.Buffer.from(L)))
                }
                let g = t.slice(0, Cc);
                t = t.slice(Cc);
                let E = ja(t),
                    A = [];
                for (let q = 0; q < E; q++) {
                    let L = t.shift(),
                        O = ja(t),
                        Z = t.slice(0, O);
                    t = t.slice(O);
                    let ge = ja(t),
                        ce = t.slice(0, ge),
                        Xe = Sn.default.encode(Et.Buffer.from(ce));
                    t = t.slice(ge), A.push({
                        programIdIndex: L,
                        accounts: Z,
                        data: Xe
                    })
                }
                let I = {
                    header: {
                        numRequiredSignatures: n,
                        numReadonlySignedAccounts: i,
                        numReadonlyUnsignedAccounts: o
                    },
                    recentBlockhash: Sn.default.encode(Et.Buffer.from(g)),
                    accountKeys: y,
                    instructions: A
                };
                return new Mo(I)
            }
        };

    function un(r, e) {
        if (!r) throw new Error(e || "Assertion failed")
    }
    var YS = Et.Buffer.alloc(64).fill(0),
        jc = 1280 - 40 - 8,
        ov = 64,
        wr = class {
            constructor(e) {
                this.keys = void 0, this.programId = void 0, this.data = Et.Buffer.alloc(0), this.programId = e.programId, this.keys = e.keys, e.data && (this.data = e.data)
            }
            toJSON() {
                return {
                    keys: this.keys.map(({
                        pubkey: e,
                        isSigner: t,
                        isWritable: n
                    }) => ({
                        pubkey: e.toJSON(),
                        isSigner: t,
                        isWritable: n
                    })),
                    programId: this.programId.toJSON(),
                    data: [...this.data]
                }
            }
        },
        cr = class {
            get signature() {
                return this.signatures.length > 0 ? this.signatures[0].signature : null
            }
            constructor(e) {
                this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.nonceInfo = void 0, this._message = void 0, this._json = void 0, e && Object.assign(this, e)
            }
            toJSON() {
                return {
                    recentBlockhash: this.recentBlockhash || null,
                    feePayer: this.feePayer ? this.feePayer.toJSON() : null,
                    nonceInfo: this.nonceInfo ? {
                        nonce: this.nonceInfo.nonce,
                        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
                    } : null,
                    instructions: this.instructions.map(e => e.toJSON()),
                    signers: this.signatures.map(({
                        publicKey: e
                    }) => e.toJSON())
                }
            }
            add(...e) {
                if (e.length === 0) throw new Error("No instructions");
                return e.forEach(t => {
                    "instructions" in t ? this.instructions = this.instructions.concat(t.instructions) : "data" in t && "programId" in t && "keys" in t ? this.instructions.push(t) : this.instructions.push(new wr(t))
                }), this
            }
            compileMessage() {
                if (this._message) {
                    if (JSON.stringify(this.toJSON()) !== JSON.stringify(this._json)) throw new Error("Transaction message mutated after being populated from Message");
                    return this._message
                }
                let {
                    nonceInfo: e
                } = this;
                e && this.instructions[0] != e.nonceInstruction && (this.recentBlockhash = e.nonce, this.instructions.unshift(e.nonceInstruction));
                let {
                    recentBlockhash: t
                } = this;
                if (!t) throw new Error("Transaction recentBlockhash required");
                this.instructions.length < 1 && console.warn("No instructions provided");
                let n;
                if (this.feePayer) n = this.feePayer;
                else if (this.signatures.length > 0 && this.signatures[0].publicKey) n = this.signatures[0].publicKey;
                else throw new Error("Transaction fee payer required");
                for (let Z = 0; Z < this.instructions.length; Z++)
                    if (this.instructions[Z].programId === void 0) throw new Error(`Transaction instruction index ${Z} has undefined program id`);
                let i = [],
                    o = [];
                this.instructions.forEach(Z => {
                    Z.keys.forEach(ce => {
                        o.push({
                            ...ce
                        })
                    });
                    let ge = Z.programId.toString();
                    i.includes(ge) || i.push(ge)
                }), i.forEach(Z => {
                    o.push({
                        pubkey: new Mt(Z),
                        isSigner: !1,
                        isWritable: !1
                    })
                }), o.sort(function(Z, ge) {
                    let ce = Z.pubkey.toBase58().localeCompare(ge.pubkey.toBase58()),
                        Xe = Z.isSigner === ge.isSigner ? 0 : Z.isSigner ? -1 : 1,
                        xe = Z.isWritable === ge.isWritable ? ce : Z.isWritable ? -1 : 1;
                    return Xe || xe
                });
                let a = [];
                o.forEach(Z => {
                    let ge = Z.pubkey.toString(),
                        ce = a.findIndex(Xe => Xe.pubkey.toString() === ge);
                    ce > -1 ? a[ce].isWritable = a[ce].isWritable || Z.isWritable : a.push(Z)
                });
                let y = a.findIndex(Z => Z.pubkey.equals(n));
                if (y > -1) {
                    let [Z] = a.splice(y, 1);
                    Z.isSigner = !0, Z.isWritable = !0, a.unshift(Z)
                } else a.unshift({
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !0
                });
                for (let Z of this.signatures) {
                    let ge = a.findIndex(ce => ce.pubkey.equals(Z.publicKey));
                    if (ge > -1) a[ge].isSigner || (a[ge].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
                    else throw new Error(`unknown signer: ${Z.publicKey.toString()}`)
                }
                let g = 0,
                    E = 0,
                    A = 0,
                    I = [],
                    q = [];
                a.forEach(({
                    pubkey: Z,
                    isSigner: ge,
                    isWritable: ce
                }) => {
                    ge ? (I.push(Z.toString()), g += 1, ce || (E += 1)) : (q.push(Z.toString()), ce || (A += 1))
                });
                let L = I.concat(q),
                    O = this.instructions.map(Z => {
                        let {
                            data: ge,
                            programId: ce
                        } = Z;
                        return {
                            programIdIndex: L.indexOf(ce.toString()),
                            accounts: Z.keys.map(Xe => L.indexOf(Xe.pubkey.toString())),
                            data: Sn.default.encode(ge)
                        }
                    });
                return O.forEach(Z => {
                    un(Z.programIdIndex >= 0), Z.accounts.forEach(ge => un(ge >= 0))
                }), new Mo({
                    header: {
                        numRequiredSignatures: g,
                        numReadonlySignedAccounts: E,
                        numReadonlyUnsignedAccounts: A
                    },
                    accountKeys: L,
                    recentBlockhash: t,
                    instructions: O
                })
            }
            _compile() {
                let e = this.compileMessage(),
                    t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
                return this.signatures.length === t.length && this.signatures.every((i, o) => t[o].equals(i.publicKey)) || (this.signatures = t.map(n => ({
                    signature: null,
                    publicKey: n
                }))), e
            }
            serializeMessage() {
                return this._compile().serialize()
            }
            async getEstimatedFee(e) {
                return (await e.getFeeForMessage(this.compileMessage())).value
            }
            setSigners(...e) {
                if (e.length === 0) throw new Error("No signers");
                let t = new Set;
                this.signatures = e.filter(n => {
                    let i = n.toString();
                    return t.has(i) ? !1 : (t.add(i), !0)
                }).map(n => ({
                    signature: null,
                    publicKey: n
                }))
            }
            sign(...e) {
                if (e.length === 0) throw new Error("No signers");
                let t = new Set,
                    n = [];
                for (let o of e) {
                    let a = o.publicKey.toString();
                    t.has(a) || (t.add(a), n.push(o))
                }
                this.signatures = n.map(o => ({
                    signature: null,
                    publicKey: o.publicKey
                }));
                let i = this._compile();
                this._partialSign(i, ...n), this._verifySignatures(i.serialize(), !0)
            }
            partialSign(...e) {
                if (e.length === 0) throw new Error("No signers");
                let t = new Set,
                    n = [];
                for (let o of e) {
                    let a = o.publicKey.toString();
                    t.has(a) || (t.add(a), n.push(o))
                }
                let i = this._compile();
                this._partialSign(i, ...n)
            }
            _partialSign(e, ...t) {
                let n = e.serialize();
                t.forEach(i => {
                    let o = Jn.default.sign.detached(n, i.secretKey);
                    this._addSignature(i.publicKey, Xt(o))
                })
            }
            addSignature(e, t) {
                this._compile(), this._addSignature(e, t)
            }
            _addSignature(e, t) {
                un(t.length === 64);
                let n = this.signatures.findIndex(i => e.equals(i.publicKey));
                if (n < 0) throw new Error(`unknown signer: ${e.toString()}`);
                this.signatures[n].signature = Et.Buffer.from(t)
            }
            verifySignatures() {
                return this._verifySignatures(this.serializeMessage(), !0)
            }
            _verifySignatures(e, t) {
                for (let {
                        signature: n,
                        publicKey: i
                    }
                    of this.signatures)
                    if (n === null) {
                        if (t) return !1
                    } else if (!Jn.default.sign.detached.verify(e, n, i.toBuffer())) return !1;
                return !0
            }
            serialize(e) {
                let {
                    requireAllSignatures: t,
                    verifySignatures: n
                } = Object.assign({
                    requireAllSignatures: !0,
                    verifySignatures: !0
                }, e), i = this.serializeMessage();
                if (n && !this._verifySignatures(i, t)) throw new Error("Signature verification failed");
                return this._serialize(i)
            }
            _serialize(e) {
                let {
                    signatures: t
                } = this, n = [];
                Wa(n, t.length);
                let i = n.length + t.length * 64 + e.length,
                    o = Et.Buffer.alloc(i);
                return un(t.length < 256), Et.Buffer.from(n).copy(o, 0), t.forEach(({
                    signature: a
                }, y) => {
                    a !== null && (un(a.length === 64, "signature has invalid length"), Et.Buffer.from(a).copy(o, n.length + y * 64))
                }), e.copy(o, n.length + t.length * 64), un(o.length <= jc, `Transaction too large: ${o.length} > ${jc}`), o
            }
            get keys() {
                return un(this.instructions.length === 1), this.instructions[0].keys.map(e => e.pubkey)
            }
            get programId() {
                return un(this.instructions.length === 1), this.instructions[0].programId
            }
            get data() {
                return un(this.instructions.length === 1), this.instructions[0].data
            }
            static from(e) {
                let t = [...e],
                    n = ja(t),
                    i = [];
                for (let o = 0; o < n; o++) {
                    let a = t.slice(0, ov);
                    t = t.slice(ov), i.push(Sn.default.encode(Et.Buffer.from(a)))
                }
                return cr.populate(Mo.from(t), i)
            }
            static populate(e, t = []) {
                let n = new cr;
                return n.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures > 0 && (n.feePayer = e.accountKeys[0]), t.forEach((i, o) => {
                    let a = {
                        signature: i == Sn.default.encode(YS) ? null : Sn.default.decode(i),
                        publicKey: e.accountKeys[o]
                    };
                    n.signatures.push(a)
                }), e.instructions.forEach(i => {
                    let o = i.accounts.map(a => {
                        let y = e.accountKeys[a];
                        return {
                            pubkey: y,
                            isSigner: n.signatures.some(g => g.publicKey.toString() === y.toString()) || e.isAccountSigner(a),
                            isWritable: e.isAccountWritable(a)
                        }
                    });
                    n.instructions.push(new wr({
                        keys: o,
                        programId: e.accountKeys[i.programIdIndex],
                        data: Sn.default.decode(i.data)
                    }))
                }), n._message = e, n._json = n.toJSON(), n
            }
        },
        So = new Mt("SysvarC1ock11111111111111111111111111111111"),
        _z = new Mt("SysvarEpochSchedu1e111111111111111111111111"),
        Ez = new Mt("Sysvar1nstructions1111111111111111111111111"),
        vl = new Mt("SysvarRecentB1ockHashes11111111111111111111"),
        Ha = new Mt("SysvarRent111111111111111111111111111111111"),
        Sz = new Mt("SysvarRewards111111111111111111111111111111"),
        Mz = new Mt("SysvarS1otHashes111111111111111111111111111"),
        Az = new Mt("SysvarS1otHistory11111111111111111111111111"),
        wl = new Mt("SysvarStakeHistory1111111111111111111111111");
    async function _l(r, e, t, n) {
        let i = n && {
                skipPreflight: n.skipPreflight,
                preflightCommitment: n.preflightCommitment || n.commitment,
                maxRetries: n.maxRetries
            },
            o = await r.sendTransaction(e, t, i),
            a = (await r.confirmTransaction(o, n && n.commitment)).value;
        if (a.err) throw new Error(`Transaction ${o} failed (${JSON.stringify(a)})`);
        return o
    }

    function JS(r) {
        return new Promise(e => setTimeout(e, r))
    }

    function lr(r, e) {
        let t = r.layout.span >= 0 ? r.layout.span : ZS(r, e),
            n = Et.Buffer.alloc(t),
            i = Object.assign({
                instruction: r.index
            }, e);
        return r.layout.encode(i, n), n
    }
    var XS = $.nu64("lamportsPerSignature"),
        QS = $.struct([$.u32("version"), $.u32("state"), rr("authorizedPubkey"), rr("nonce"), $.struct([XS], "feeCalculator")]),
        sv = QS.span;
    var qn = Object.freeze({
            Create: {
                index: 0,
                layout: $.struct([$.u32("instruction"), $.ns64("lamports"), $.ns64("space"), rr("programId")])
            },
            Assign: {
                index: 1,
                layout: $.struct([$.u32("instruction"), rr("programId")])
            },
            Transfer: {
                index: 2,
                layout: $.struct([$.u32("instruction"), $.ns64("lamports")])
            },
            CreateWithSeed: {
                index: 3,
                layout: $.struct([$.u32("instruction"), rr("base"), $a("seed"), $.ns64("lamports"), $.ns64("space"), rr("programId")])
            },
            AdvanceNonceAccount: {
                index: 4,
                layout: $.struct([$.u32("instruction")])
            },
            WithdrawNonceAccount: {
                index: 5,
                layout: $.struct([$.u32("instruction"), $.ns64("lamports")])
            },
            InitializeNonceAccount: {
                index: 6,
                layout: $.struct([$.u32("instruction"), rr("authorized")])
            },
            AuthorizeNonceAccount: {
                index: 7,
                layout: $.struct([$.u32("instruction"), rr("authorized")])
            },
            Allocate: {
                index: 8,
                layout: $.struct([$.u32("instruction"), $.ns64("space")])
            },
            AllocateWithSeed: {
                index: 9,
                layout: $.struct([$.u32("instruction"), rr("base"), $a("seed"), $.ns64("space"), rr("programId")])
            },
            AssignWithSeed: {
                index: 10,
                layout: $.struct([$.u32("instruction"), rr("base"), $a("seed"), rr("programId")])
            },
            TransferWithSeed: {
                index: 11,
                layout: $.struct([$.u32("instruction"), $.ns64("lamports"), $a("seed"), rr("programId")])
            }
        }),
        cn = class {
            constructor() {}
            static createAccount(e) {
                let t = qn.Create,
                    n = lr(t, {
                        lamports: e.lamports,
                        space: e.space,
                        programId: Xt(e.programId.toBuffer())
                    });
                return new wr({
                    keys: [{
                        pubkey: e.fromPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: e.newAccountPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }],
                    programId: this.programId,
                    data: n
                })
            }
            static transfer(e) {
                let t, n;
                if ("basePubkey" in e) {
                    let i = qn.TransferWithSeed;
                    t = lr(i, {
                        lamports: e.lamports,
                        seed: e.seed,
                        programId: Xt(e.programId.toBuffer())
                    }), n = [{
                        pubkey: e.fromPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: e.basePubkey,
                        isSigner: !0,
                        isWritable: !1
                    }, {
                        pubkey: e.toPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }]
                } else {
                    let i = qn.Transfer;
                    t = lr(i, {
                        lamports: e.lamports
                    }), n = [{
                        pubkey: e.fromPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: e.toPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }]
                }
                return new wr({
                    keys: n,
                    programId: this.programId,
                    data: t
                })
            }
            static assign(e) {
                let t, n;
                if ("basePubkey" in e) {
                    let i = qn.AssignWithSeed;
                    t = lr(i, {
                        base: Xt(e.basePubkey.toBuffer()),
                        seed: e.seed,
                        programId: Xt(e.programId.toBuffer())
                    }), n = [{
                        pubkey: e.accountPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: e.basePubkey,
                        isSigner: !0,
                        isWritable: !1
                    }]
                } else {
                    let i = qn.Assign;
                    t = lr(i, {
                        programId: Xt(e.programId.toBuffer())
                    }), n = [{
                        pubkey: e.accountPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }]
                }
                return new wr({
                    keys: n,
                    programId: this.programId,
                    data: t
                })
            }
            static createAccountWithSeed(e) {
                let t = qn.CreateWithSeed,
                    n = lr(t, {
                        base: Xt(e.basePubkey.toBuffer()),
                        seed: e.seed,
                        lamports: e.lamports,
                        space: e.space,
                        programId: Xt(e.programId.toBuffer())
                    }),
                    i = [{
                        pubkey: e.fromPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: e.newAccountPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }];
                return e.basePubkey != e.fromPubkey && i.push({
                    pubkey: e.basePubkey,
                    isSigner: !0,
                    isWritable: !1
                }), new wr({
                    keys: i,
                    programId: this.programId,
                    data: n
                })
            }
            static createNonceAccount(e) {
                let t = new cr;
                "basePubkey" in e && "seed" in e ? t.add(cn.createAccountWithSeed({
                    fromPubkey: e.fromPubkey,
                    newAccountPubkey: e.noncePubkey,
                    basePubkey: e.basePubkey,
                    seed: e.seed,
                    lamports: e.lamports,
                    space: sv,
                    programId: this.programId
                })) : t.add(cn.createAccount({
                    fromPubkey: e.fromPubkey,
                    newAccountPubkey: e.noncePubkey,
                    lamports: e.lamports,
                    space: sv,
                    programId: this.programId
                }));
                let n = {
                    noncePubkey: e.noncePubkey,
                    authorizedPubkey: e.authorizedPubkey
                };
                return t.add(this.nonceInitialize(n)), t
            }
            static nonceInitialize(e) {
                let t = qn.InitializeNonceAccount,
                    n = lr(t, {
                        authorized: Xt(e.authorizedPubkey.toBuffer())
                    }),
                    i = {
                        keys: [{
                            pubkey: e.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: vl,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: Ha,
                            isSigner: !1,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: n
                    };
                return new wr(i)
            }
            static nonceAdvance(e) {
                let t = qn.AdvanceNonceAccount,
                    n = lr(t),
                    i = {
                        keys: [{
                            pubkey: e.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: vl,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: e.authorizedPubkey,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: n
                    };
                return new wr(i)
            }
            static nonceWithdraw(e) {
                let t = qn.WithdrawNonceAccount,
                    n = lr(t, {
                        lamports: e.lamports
                    });
                return new wr({
                    keys: [{
                        pubkey: e.noncePubkey,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: e.toPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: vl,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: Ha,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: e.authorizedPubkey,
                        isSigner: !0,
                        isWritable: !1
                    }],
                    programId: this.programId,
                    data: n
                })
            }
            static nonceAuthorize(e) {
                let t = qn.AuthorizeNonceAccount,
                    n = lr(t, {
                        authorized: Xt(e.newAuthorizedPubkey.toBuffer())
                    });
                return new wr({
                    keys: [{
                        pubkey: e.noncePubkey,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: e.authorizedPubkey,
                        isSigner: !0,
                        isWritable: !1
                    }],
                    programId: this.programId,
                    data: n
                })
            }
            static allocate(e) {
                let t, n;
                if ("basePubkey" in e) {
                    let i = qn.AllocateWithSeed;
                    t = lr(i, {
                        base: Xt(e.basePubkey.toBuffer()),
                        seed: e.seed,
                        space: e.space,
                        programId: Xt(e.programId.toBuffer())
                    }), n = [{
                        pubkey: e.accountPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: e.basePubkey,
                        isSigner: !0,
                        isWritable: !1
                    }]
                } else {
                    let i = qn.Allocate;
                    t = lr(i, {
                        space: e.space
                    }), n = [{
                        pubkey: e.accountPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }]
                }
                return new wr({
                    keys: n,
                    programId: this.programId,
                    data: t
                })
            }
        };
    cn.programId = new Mt("11111111111111111111111111111111");
    var eM = jc - 300,
        Gs = class {
            constructor() {}
            static getMinNumSignatures(e) {
                return 2 * (Math.ceil(e / Gs.chunkSize) + 1 + 1)
            }
            static async load(e, t, n, i, o) {
                {
                    let I = await e.getMinimumBalanceForRentExemption(o.length),
                        q = await e.getAccountInfo(n.publicKey, "confirmed"),
                        L = null;
                    if (q !== null) {
                        if (q.executable) return console.error("Program load failed, account is already executable"), !1;
                        q.data.length !== o.length && (L = L || new cr, L.add(cn.allocate({
                            accountPubkey: n.publicKey,
                            space: o.length
                        }))), q.owner.equals(i) || (L = L || new cr, L.add(cn.assign({
                            accountPubkey: n.publicKey,
                            programId: i
                        }))), q.lamports < I && (L = L || new cr, L.add(cn.transfer({
                            fromPubkey: t.publicKey,
                            toPubkey: n.publicKey,
                            lamports: I - q.lamports
                        })))
                    } else L = new cr().add(cn.createAccount({
                        fromPubkey: t.publicKey,
                        newAccountPubkey: n.publicKey,
                        lamports: I > 0 ? I : 1,
                        space: o.length,
                        programId: i
                    }));
                    L !== null && await _l(e, L, [t, n], {
                        commitment: "confirmed"
                    })
                }
                let a = $.struct([$.u32("instruction"), $.u32("offset"), $.u32("bytesLength"), $.u32("bytesLengthPadding"), $.seq($.u8("byte"), $.offset($.u32(), -8), "bytes")]),
                    y = Gs.chunkSize,
                    g = 0,
                    E = o,
                    A = [];
                for (; E.length > 0;) {
                    let I = E.slice(0, y),
                        q = Et.Buffer.alloc(y + 16);
                    a.encode({
                        instruction: 0,
                        offset: g,
                        bytes: I,
                        bytesLength: 0,
                        bytesLengthPadding: 0
                    }, q);
                    let L = new cr().add({
                        keys: [{
                            pubkey: n.publicKey,
                            isSigner: !0,
                            isWritable: !0
                        }],
                        programId: i,
                        data: q
                    });
                    A.push(_l(e, L, [t, n], {
                        commitment: "confirmed"
                    })), e._rpcEndpoint.includes("solana.com") && await JS(1e3 / 4), g += y, E = E.slice(y)
                }
                await Promise.all(A); {
                    let I = $.struct([$.u32("instruction")]),
                        q = Et.Buffer.alloc(I.span);
                    I.encode({
                        instruction: 1
                    }, q);
                    let L = new cr().add({
                        keys: [{
                            pubkey: n.publicKey,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: Ha,
                            isSigner: !1,
                            isWritable: !1
                        }],
                        programId: i,
                        data: q
                    });
                    await _l(e, L, [t, n], {
                        commitment: "confirmed"
                    })
                }
                return !0
            }
        };
    Gs.chunkSize = eM;
    var Iz = new Mt("BPFLoader2111111111111111111111111111111111");
    var av = Object.freeze({
            RequestUnits: {
                index: 0,
                layout: $.struct([$.u8("instruction"), $.u32("units"), $.u32("additionalFee")])
            },
            RequestHeapFrame: {
                index: 1,
                layout: $.struct([$.u8("instruction"), $.u32("bytes")])
            }
        }),
        Tl = class {
            constructor() {}
            static requestUnits(e) {
                let t = av.RequestUnits,
                    n = lr(t, e);
                return new wr({
                    keys: [],
                    programId: this.programId,
                    data: n
                })
            }
            static requestHeapFrame(e) {
                let t = av.RequestHeapFrame,
                    n = lr(t, e);
                return new wr({
                    keys: [],
                    programId: this.programId,
                    data: n
                })
            }
        };
    Tl.programId = new Mt("ComputeBudget111111111111111111111111111111");
    var Ll = {
        exports: {}
    };
    (function(r, e) {
        var t = typeof self < "u" ? self : oE,
            n = function() {
                function o() {
                    this.fetch = !1, this.DOMException = t.DOMException
                }
                return o.prototype = t, new o
            }();
        (function(o) {
            (function(a) {
                var y = {
                    searchParams: "URLSearchParams" in o,
                    iterable: "Symbol" in o && "iterator" in Symbol,
                    blob: "FileReader" in o && "Blob" in o && function() {
                        try {
                            return new Blob, !0
                        } catch {
                            return !1
                        }
                    }(),
                    formData: "FormData" in o,
                    arrayBuffer: "ArrayBuffer" in o
                };

                function g(s) {
                    return s && DataView.prototype.isPrototypeOf(s)
                }
                if (y.arrayBuffer) var E = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                    A = ArrayBuffer.isView || function(s) {
                        return s && E.indexOf(Object.prototype.toString.call(s)) > -1
                    };

                function I(s) {
                    if (typeof s != "string" && (s = String(s)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(s)) throw new TypeError("Invalid character in header field name");
                    return s.toLowerCase()
                }

                function q(s) {
                    return typeof s != "string" && (s = String(s)), s
                }

                function L(s) {
                    var f = {
                        next: function() {
                            var h = s.shift();
                            return {
                                done: h === void 0,
                                value: h
                            }
                        }
                    };
                    return y.iterable && (f[Symbol.iterator] = function() {
                        return f
                    }), f
                }

                function O(s) {
                    this.map = {}, s instanceof O ? s.forEach(function(f, h) {
                        this.append(h, f)
                    }, this) : Array.isArray(s) ? s.forEach(function(f) {
                        this.append(f[0], f[1])
                    }, this) : s && Object.getOwnPropertyNames(s).forEach(function(f) {
                        this.append(f, s[f])
                    }, this)
                }
                O.prototype.append = function(s, f) {
                    s = I(s), f = q(f);
                    var h = this.map[s];
                    this.map[s] = h ? h + ", " + f : f
                }, O.prototype.delete = function(s) {
                    delete this.map[I(s)]
                }, O.prototype.get = function(s) {
                    return s = I(s), this.has(s) ? this.map[s] : null
                }, O.prototype.has = function(s) {
                    return this.map.hasOwnProperty(I(s))
                }, O.prototype.set = function(s, f) {
                    this.map[I(s)] = q(f)
                }, O.prototype.forEach = function(s, f) {
                    for (var h in this.map) this.map.hasOwnProperty(h) && s.call(f, this.map[h], h, this)
                }, O.prototype.keys = function() {
                    var s = [];
                    return this.forEach(function(f, h) {
                        s.push(h)
                    }), L(s)
                }, O.prototype.values = function() {
                    var s = [];
                    return this.forEach(function(f) {
                        s.push(f)
                    }), L(s)
                }, O.prototype.entries = function() {
                    var s = [];
                    return this.forEach(function(f, h) {
                        s.push([h, f])
                    }), L(s)
                }, y.iterable && (O.prototype[Symbol.iterator] = O.prototype.entries);

                function Z(s) {
                    if (s.bodyUsed) return Promise.reject(new TypeError("Already read"));
                    s.bodyUsed = !0
                }

                function ge(s) {
                    return new Promise(function(f, h) {
                        s.onload = function() {
                            f(s.result)
                        }, s.onerror = function() {
                            h(s.error)
                        }
                    })
                }

                function ce(s) {
                    var f = new FileReader,
                        h = ge(f);
                    return f.readAsArrayBuffer(s), h
                }

                function Xe(s) {
                    var f = new FileReader,
                        h = ge(f);
                    return f.readAsText(s), h
                }

                function xe(s) {
                    for (var f = new Uint8Array(s), h = new Array(f.length), p = 0; p < f.length; p++) h[p] = String.fromCharCode(f[p]);
                    return h.join("")
                }

                function ie(s) {
                    if (s.slice) return s.slice(0);
                    var f = new Uint8Array(s.byteLength);
                    return f.set(new Uint8Array(s)), f.buffer
                }

                function ae() {
                    return this.bodyUsed = !1, this._initBody = function(s) {
                        this._bodyInit = s, s ? typeof s == "string" ? this._bodyText = s : y.blob && Blob.prototype.isPrototypeOf(s) ? this._bodyBlob = s : y.formData && FormData.prototype.isPrototypeOf(s) ? this._bodyFormData = s : y.searchParams && URLSearchParams.prototype.isPrototypeOf(s) ? this._bodyText = s.toString() : y.arrayBuffer && y.blob && g(s) ? (this._bodyArrayBuffer = ie(s.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : y.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(s) || A(s)) ? this._bodyArrayBuffer = ie(s) : this._bodyText = s = Object.prototype.toString.call(s) : this._bodyText = "", this.headers.get("content-type") || (typeof s == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : y.searchParams && URLSearchParams.prototype.isPrototypeOf(s) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }, y.blob && (this.blob = function() {
                        var s = Z(this);
                        if (s) return s;
                        if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                        return Promise.resolve(new Blob([this._bodyText]))
                    }, this.arrayBuffer = function() {
                        return this._bodyArrayBuffer ? Z(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(ce)
                    }), this.text = function() {
                        var s = Z(this);
                        if (s) return s;
                        if (this._bodyBlob) return Xe(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(xe(this._bodyArrayBuffer));
                        if (this._bodyFormData) throw new Error("could not read FormData body as text");
                        return Promise.resolve(this._bodyText)
                    }, y.formData && (this.formData = function() {
                        return this.text().then(gt)
                    }), this.json = function() {
                        return this.text().then(JSON.parse)
                    }, this
                }
                var be = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

                function we(s) {
                    var f = s.toUpperCase();
                    return be.indexOf(f) > -1 ? f : s
                }

                function he(s, f) {
                    f = f || {};
                    var h = f.body;
                    if (s instanceof he) {
                        if (s.bodyUsed) throw new TypeError("Already read");
                        this.url = s.url, this.credentials = s.credentials, f.headers || (this.headers = new O(s.headers)), this.method = s.method, this.mode = s.mode, this.signal = s.signal, !h && s._bodyInit != null && (h = s._bodyInit, s.bodyUsed = !0)
                    } else this.url = String(s);
                    if (this.credentials = f.credentials || this.credentials || "same-origin", (f.headers || !this.headers) && (this.headers = new O(f.headers)), this.method = we(f.method || this.method || "GET"), this.mode = f.mode || this.mode || null, this.signal = f.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && h) throw new TypeError("Body not allowed for GET or HEAD requests");
                    this._initBody(h)
                }
                he.prototype.clone = function() {
                    return new he(this, {
                        body: this._bodyInit
                    })
                };

                function gt(s) {
                    var f = new FormData;
                    return s.trim().split("&").forEach(function(h) {
                        if (h) {
                            var p = h.split("="),
                                d = p.shift().replace(/\+/g, " "),
                                c = p.join("=").replace(/\+/g, " ");
                            f.append(decodeURIComponent(d), decodeURIComponent(c))
                        }
                    }), f
                }

                function T(s) {
                    var f = new O,
                        h = s.replace(/\r?\n[\t ]+/g, " ");
                    return h.split(/\r?\n/).forEach(function(p) {
                        var d = p.split(":"),
                            c = d.shift().trim();
                        if (c) {
                            var x = d.join(":").trim();
                            f.append(c, x)
                        }
                    }), f
                }
                ae.call(he.prototype);

                function m(s, f) {
                    f || (f = {}), this.type = "default", this.status = f.status === void 0 ? 200 : f.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in f ? f.statusText : "OK", this.headers = new O(f.headers), this.url = f.url || "", this._initBody(s)
                }
                ae.call(m.prototype), m.prototype.clone = function() {
                    return new m(this._bodyInit, {
                        status: this.status,
                        statusText: this.statusText,
                        headers: new O(this.headers),
                        url: this.url
                    })
                }, m.error = function() {
                    var s = new m(null, {
                        status: 0,
                        statusText: ""
                    });
                    return s.type = "error", s
                };
                var w = [301, 302, 303, 307, 308];
                m.redirect = function(s, f) {
                    if (w.indexOf(f) === -1) throw new RangeError("Invalid status code");
                    return new m(null, {
                        status: f,
                        headers: {
                            location: s
                        }
                    })
                }, a.DOMException = o.DOMException;
                try {
                    new a.DOMException
                } catch {
                    a.DOMException = function(f, h) {
                        this.message = f, this.name = h;
                        var p = Error(f);
                        this.stack = p.stack
                    }, a.DOMException.prototype = Object.create(Error.prototype), a.DOMException.prototype.constructor = a.DOMException
                }

                function l(s, f) {
                    return new Promise(function(h, p) {
                        var d = new he(s, f);
                        if (d.signal && d.signal.aborted) return p(new a.DOMException("Aborted", "AbortError"));
                        var c = new XMLHttpRequest;

                        function x() {
                            c.abort()
                        }
                        c.onload = function() {
                            var v = {
                                status: c.status,
                                statusText: c.statusText,
                                headers: T(c.getAllResponseHeaders() || "")
                            };
                            v.url = "responseURL" in c ? c.responseURL : v.headers.get("X-Request-URL");
                            var u = "response" in c ? c.response : c.responseText;
                            h(new m(u, v))
                        }, c.onerror = function() {
                            p(new TypeError("Network request failed"))
                        }, c.ontimeout = function() {
                            p(new TypeError("Network request failed"))
                        }, c.onabort = function() {
                            p(new a.DOMException("Aborted", "AbortError"))
                        }, c.open(d.method, d.url, !0), d.credentials === "include" ? c.withCredentials = !0 : d.credentials === "omit" && (c.withCredentials = !1), "responseType" in c && y.blob && (c.responseType = "blob"), d.headers.forEach(function(v, u) {
                            c.setRequestHeader(u, v)
                        }), d.signal && (d.signal.addEventListener("abort", x), c.onreadystatechange = function() {
                            c.readyState === 4 && d.signal.removeEventListener("abort", x)
                        }), c.send(typeof d._bodyInit > "u" ? null : d._bodyInit)
                    })
                }
                return l.polyfill = !0, o.fetch || (o.fetch = l, o.Headers = O, o.Request = he, o.Response = m), a.Headers = O, a.Request = he, a.Response = m, a.fetch = l, Object.defineProperty(a, "__esModule", {
                    value: !0
                }), a
            })({})
        })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
        var i = n;
        e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, r.exports = e
    })(Ll, Ll.exports);
    var Bz = sE(Ll.exports);
    var tM = 160,
        rM = 64,
        nM = tM / rM,
        Rz = 1e3 / nM;
    var rn = Ts(oc(Mt), nt(), r => new Mt(r)),
        Uv = R0([nt(), Sr("base64")]),
        Ul = Ts(oc(Et.Buffer), Uv, r => Et.Buffer.from(r[0], "base64")),
        kz = 30 * 1e3;

    function Nv(r) {
        return _n([_e({
            jsonrpc: Sr("2.0"),
            id: nt(),
            result: r
        }), _e({
            jsonrpc: Sr("2.0"),
            id: nt(),
            error: _e({
                code: Ps(),
                message: nt(),
                data: tr(Ib())
            })
        })])
    }
    var iM = Nv(Ps());

    function Mr(r) {
        return Ts(Nv(r), iM, e => "error" in e ? e : {
            ...e,
            result: ks(e.result, r)
        })
    }

    function Qn(r) {
        return Mr(_e({
            context: _e({
                slot: te()
            }),
            value: r
        }))
    }

    function Zc(r) {
        return _e({
            context: _e({
                slot: te()
            }),
            value: r
        })
    }
    var oM = _e({
            foundation: te(),
            foundationTerm: te(),
            initial: te(),
            taper: te(),
            terminal: te()
        }),
        Pz = Mr(_t(St(_e({
            epoch: te(),
            effectiveSlot: te(),
            amount: te(),
            postBalance: te()
        })))),
        sM = _e({
            epoch: te(),
            slotIndex: te(),
            slotsInEpoch: te(),
            absoluteSlot: te(),
            blockHeight: tr(te()),
            transactionCount: tr(te())
        }),
        aM = _e({
            slotsPerEpoch: te(),
            leaderScheduleSlotOffset: te(),
            warmup: ui(),
            firstNormalEpoch: te(),
            firstNormalSlot: te()
        }),
        fM = B0(nt(), _t(te())),
        Jo = St(_n([_e({}), nt()])),
        uM = _e({
            err: Jo
        }),
        cM = Sr("receivedSignature"),
        Tz = _e({
            "solana-core": nt(),
            "feature-set": tr(te())
        }),
        Lz = Qn(_e({
            err: St(_n([_e({}), nt()])),
            logs: St(_t(nt())),
            accounts: tr(St(_t(St(_e({
                executable: ui(),
                owner: nt(),
                lamports: te(),
                data: _t(nt()),
                rentEpoch: tr(te())
            }))))),
            unitsConsumed: tr(te())
        })),
        zz = Qn(_e({
            byIdentity: B0(nt(), _t(te())),
            range: _e({
                firstSlot: te(),
                lastSlot: te()
            })
        }));
    var Uz = Mr(oM),
        Nz = Mr(sM),
        qz = Mr(aM),
        Fz = Mr(fM),
        Cz = Mr(te()),
        Oz = Qn(_e({
            total: te(),
            circulating: te(),
            nonCirculating: te(),
            nonCirculatingAccounts: _t(rn)
        })),
        hM = _e({
            amount: nt(),
            uiAmount: St(te()),
            decimals: te(),
            uiAmountString: tr(nt())
        }),
        Dz = Qn(_t(_e({
            address: rn,
            amount: nt(),
            uiAmount: St(te()),
            decimals: te(),
            uiAmountString: tr(nt())
        }))),
        Kz = Qn(_t(_e({
            pubkey: rn,
            account: _e({
                executable: ui(),
                owner: rn,
                lamports: te(),
                data: Ul,
                rentEpoch: te()
            })
        }))),
        zl = _e({
            program: nt(),
            parsed: Ps(),
            space: te()
        }),
        $z = Qn(_t(_e({
            pubkey: rn,
            account: _e({
                executable: ui(),
                owner: rn,
                lamports: te(),
                data: zl,
                rentEpoch: te()
            })
        }))),
        jz = Qn(_t(_e({
            lamports: te(),
            address: rn
        }))),
        Nl = _e({
            executable: ui(),
            owner: rn,
            lamports: te(),
            data: Ul,
            rentEpoch: te()
        }),
        Wz = _e({
            pubkey: rn,
            account: Nl
        }),
        lM = Ts(_n([oc(Et.Buffer), zl]), _n([Uv, zl]), r => Array.isArray(r) ? ks(r, Ul) : r),
        dM = _e({
            executable: ui(),
            owner: rn,
            lamports: te(),
            data: lM,
            rentEpoch: te()
        }),
        Hz = _e({
            pubkey: rn,
            account: dM
        }),
        Vz = _e({
            state: _n([Sr("active"), Sr("inactive"), Sr("activating"), Sr("deactivating")]),
            active: te(),
            inactive: te()
        }),
        Gz = Mr(_t(_e({
            signature: nt(),
            slot: te(),
            err: Jo,
            memo: St(nt()),
            blockTime: tr(St(te()))
        }))),
        Zz = Mr(_t(_e({
            signature: nt(),
            slot: te(),
            err: Jo,
            memo: St(nt()),
            blockTime: tr(St(te()))
        }))),
        Yz = _e({
            subscription: te(),
            result: Zc(Nl)
        }),
        pM = _e({
            pubkey: rn,
            account: Nl
        }),
        Jz = _e({
            subscription: te(),
            result: Zc(pM)
        }),
        yM = _e({
            parent: te(),
            slot: te(),
            root: te()
        }),
        Xz = _e({
            subscription: te(),
            result: yM
        }),
        mM = _n([_e({
            type: _n([Sr("firstShredReceived"), Sr("completed"), Sr("optimisticConfirmation"), Sr("root")]),
            slot: te(),
            timestamp: te()
        }), _e({
            type: Sr("createdBank"),
            parent: te(),
            slot: te(),
            timestamp: te()
        }), _e({
            type: Sr("frozen"),
            slot: te(),
            timestamp: te(),
            stats: _e({
                numTransactionEntries: te(),
                numSuccessfulTransactions: te(),
                numFailedTransactions: te(),
                maxTransactionsPerEntry: te()
            })
        }), _e({
            type: Sr("dead"),
            slot: te(),
            timestamp: te(),
            err: nt()
        })]),
        Qz = _e({
            subscription: te(),
            result: mM
        }),
        eU = _e({
            subscription: te(),
            result: Zc(_n([uM, cM]))
        }),
        tU = _e({
            subscription: te(),
            result: te()
        }),
        rU = _e({
            pubkey: nt(),
            gossip: St(nt()),
            tpu: St(nt()),
            rpc: St(nt()),
            version: St(nt())
        }),
        fv = _e({
            votePubkey: nt(),
            nodePubkey: nt(),
            activatedStake: te(),
            epochVoteAccount: ui(),
            epochCredits: _t(R0([te(), te(), te()])),
            commission: te(),
            lastVote: te(),
            rootSlot: St(te())
        }),
        nU = Mr(_e({
            current: _t(fv),
            delinquent: _t(fv)
        })),
        gM = _n([Sr("processed"), Sr("confirmed"), Sr("finalized")]),
        bM = _e({
            slot: te(),
            confirmations: St(te()),
            err: Jo,
            confirmationStatus: tr(gM)
        }),
        iU = Qn(_t(St(bM))),
        oU = Mr(te()),
        ql = _e({
            signatures: _t(nt()),
            message: _e({
                accountKeys: _t(nt()),
                header: _e({
                    numRequiredSignatures: te(),
                    numReadonlySignedAccounts: te(),
                    numReadonlyUnsignedAccounts: te()
                }),
                instructions: _t(_e({
                    accounts: _t(te()),
                    data: nt(),
                    programIdIndex: te()
                })),
                recentBlockhash: nt()
            })
        }),
        qv = _e({
            parsed: Ps(),
            program: nt(),
            programId: rn
        }),
        Fv = _e({
            accounts: _t(rn),
            data: nt(),
            programId: rn
        }),
        xM = _n([Fv, qv]),
        vM = _n([_e({
            parsed: Ps(),
            program: nt(),
            programId: nt()
        }), _e({
            accounts: _t(nt()),
            data: nt(),
            programId: nt()
        })]),
        Cv = Ts(xM, vM, r => "accounts" in r ? ks(r, Fv) : ks(r, qv)),
        wM = _e({
            signatures: _t(nt()),
            message: _e({
                accountKeys: _t(_e({
                    pubkey: rn,
                    signer: ui(),
                    writable: ui()
                })),
                instructions: _t(Cv),
                recentBlockhash: nt()
            })
        }),
        Wc = _e({
            accountIndex: te(),
            mint: nt(),
            owner: tr(nt()),
            uiTokenAmount: hM
        }),
        Fl = _e({
            err: Jo,
            fee: te(),
            innerInstructions: tr(St(_t(_e({
                index: te(),
                instructions: _t(_e({
                    accounts: _t(te()),
                    data: nt(),
                    programIdIndex: te()
                }))
            })))),
            preBalances: _t(te()),
            postBalances: _t(te()),
            logMessages: tr(St(_t(nt()))),
            preTokenBalances: tr(St(_t(Wc))),
            postTokenBalances: tr(St(_t(Wc)))
        }),
        _M = _e({
            err: Jo,
            fee: te(),
            innerInstructions: tr(St(_t(_e({
                index: te(),
                instructions: _t(Cv)
            })))),
            preBalances: _t(te()),
            postBalances: _t(te()),
            logMessages: tr(St(_t(nt()))),
            preTokenBalances: tr(St(_t(Wc))),
            postTokenBalances: tr(St(_t(Wc)))
        }),
        sU = Mr(St(_e({
            blockhash: nt(),
            previousBlockhash: nt(),
            parentSlot: te(),
            transactions: _t(_e({
                transaction: ql,
                meta: St(Fl)
            })),
            rewards: tr(_t(_e({
                pubkey: nt(),
                lamports: te(),
                postBalance: St(te()),
                rewardType: St(nt())
            }))),
            blockTime: St(te()),
            blockHeight: St(te())
        }))),
        aU = Mr(St(_e({
            blockhash: nt(),
            previousBlockhash: nt(),
            parentSlot: te(),
            transactions: _t(_e({
                transaction: ql,
                meta: St(Fl)
            })),
            rewards: tr(_t(_e({
                pubkey: nt(),
                lamports: te(),
                postBalance: St(te()),
                rewardType: St(nt())
            }))),
            blockTime: St(te())
        }))),
        fU = Mr(St(_e({
            blockhash: nt(),
            previousBlockhash: nt(),
            parentSlot: te(),
            signatures: _t(nt()),
            blockTime: St(te())
        }))),
        uU = Mr(St(_e({
            slot: te(),
            meta: Fl,
            blockTime: tr(St(te())),
            transaction: ql
        }))),
        cU = Mr(St(_e({
            slot: te(),
            transaction: wM,
            meta: St(_M),
            blockTime: tr(St(te()))
        }))),
        hU = Qn(_e({
            blockhash: nt(),
            feeCalculator: _e({
                lamportsPerSignature: te()
            })
        })),
        lU = Qn(_e({
            blockhash: nt(),
            lastValidBlockHeight: te()
        })),
        EM = _e({
            slot: te(),
            numTransactions: te(),
            numSlots: te(),
            samplePeriodSecs: te()
        }),
        dU = Mr(_t(EM)),
        pU = Qn(St(_e({
            feeCalculator: _e({
                lamportsPerSignature: te()
            })
        }))),
        yU = Mr(nt()),
        mU = Mr(nt()),
        SM = _e({
            err: Jo,
            logs: _t(nt()),
            signature: nt()
        }),
        gU = _e({
            result: Zc(SM),
            subscription: te()
        });
    var Go = class {
            constructor(e) {
                this._keypair = void 0, e ? this._keypair = e : this._keypair = Jn.default.sign.keyPair()
            }
            static generate() {
                return new Go(Jn.default.sign.keyPair())
            }
            static fromSecretKey(e, t) {
                let n = Jn.default.sign.keyPair.fromSecretKey(e);
                if (!t || !t.skipValidation) {
                    let o = new TextEncoder().encode("@solana/web3.js-validation-v1"),
                        a = Jn.default.sign.detached(o, n.secretKey);
                    if (!Jn.default.sign.detached.verify(o, a, n.publicKey)) throw new Error("provided secretKey is invalid")
                }
                return new Go(n)
            }
            static fromSeed(e) {
                return new Go(Jn.default.sign.keyPair.fromSeed(e))
            }
            get publicKey() {
                return new Mt(this._keypair.publicKey)
            }
            get secretKey() {
                return this._keypair.secretKey
            }
        },
        uv = 64,
        cv = 32,
        hv = 64,
        lv = $.struct([$.u8("numSignatures"), $.u8("padding"), $.u16("signatureOffset"), $.u16("signatureInstructionIndex"), $.u16("publicKeyOffset"), $.u16("publicKeyInstructionIndex"), $.u16("messageDataOffset"), $.u16("messageDataSize"), $.u16("messageInstructionIndex")]),
        Va = class {
            constructor() {}
            static createInstructionWithPublicKey(e) {
                let {
                    publicKey: t,
                    message: n,
                    signature: i,
                    instructionIndex: o
                } = e;
                un(t.length === cv, `Public Key must be ${cv} bytes but received ${t.length} bytes`), un(i.length === hv, `Signature must be ${hv} bytes but received ${i.length} bytes`);
                let a = lv.span,
                    y = a + t.length,
                    g = y + i.length,
                    E = 1,
                    A = Et.Buffer.alloc(g + n.length),
                    I = o ?? 65535;
                return lv.encode({
                    numSignatures: E,
                    padding: 0,
                    signatureOffset: y,
                    signatureInstructionIndex: I,
                    publicKeyOffset: a,
                    publicKeyInstructionIndex: I,
                    messageDataOffset: g,
                    messageDataSize: n.length,
                    messageInstructionIndex: I
                }, A), A.fill(t, a), A.fill(i, y), A.fill(n, g), new wr({
                    keys: [],
                    programId: Va.programId,
                    data: A
                })
            }
            static createInstructionWithPrivateKey(e) {
                let {
                    privateKey: t,
                    message: n,
                    instructionIndex: i
                } = e;
                un(t.length === uv, `Private key must be ${uv} bytes but received ${t.length} bytes`);
                try {
                    let o = Go.fromSecretKey(t),
                        a = o.publicKey.toBytes(),
                        y = Jn.default.sign.detached(n, o.secretKey);
                    return this.createInstructionWithPublicKey({
                        publicKey: a,
                        message: n,
                        signature: y,
                        instructionIndex: i
                    })
                } catch (o) {
                    throw new Error(`Error creating instruction; ${o}`)
                }
            }
        };
    Va.programId = new Mt("Ed25519SigVerify111111111111111111111111111");
    var MM = new Mt("StakeConfig11111111111111111111111111111111");
    var Ga = class {
        constructor(e, t, n) {
            this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = t, this.custodian = n
        }
    };
    Ga.default = new Ga(0, 0, Mt.default);
    var Eo = Object.freeze({
            Initialize: {
                index: 0,
                layout: $.struct([$.u32("instruction"), HS(), VS()])
            },
            Authorize: {
                index: 1,
                layout: $.struct([$.u32("instruction"), rr("newAuthorized"), $.u32("stakeAuthorizationType")])
            },
            Delegate: {
                index: 2,
                layout: $.struct([$.u32("instruction")])
            },
            Split: {
                index: 3,
                layout: $.struct([$.u32("instruction"), $.ns64("lamports")])
            },
            Withdraw: {
                index: 4,
                layout: $.struct([$.u32("instruction"), $.ns64("lamports")])
            },
            Deactivate: {
                index: 5,
                layout: $.struct([$.u32("instruction")])
            },
            Merge: {
                index: 7,
                layout: $.struct([$.u32("instruction")])
            },
            AuthorizeWithSeed: {
                index: 8,
                layout: $.struct([$.u32("instruction"), rr("newAuthorized"), $.u32("stakeAuthorizationType"), $a("authoritySeed"), rr("authorityOwner")])
            }
        }),
        bU = Object.freeze({
            Staker: {
                index: 0
            },
            Withdrawer: {
                index: 1
            }
        }),
        Hc = class {
            constructor() {}
            static initialize(e) {
                let {
                    stakePubkey: t,
                    authorized: n,
                    lockup: i
                } = e, o = i || Ga.default, a = Eo.Initialize, y = lr(a, {
                    authorized: {
                        staker: Xt(n.staker.toBuffer()),
                        withdrawer: Xt(n.withdrawer.toBuffer())
                    },
                    lockup: {
                        unixTimestamp: o.unixTimestamp,
                        epoch: o.epoch,
                        custodian: Xt(o.custodian.toBuffer())
                    }
                }), g = {
                    keys: [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: Ha,
                        isSigner: !1,
                        isWritable: !1
                    }],
                    programId: this.programId,
                    data: y
                };
                return new wr(g)
            }
            static createAccountWithSeed(e) {
                let t = new cr;
                t.add(cn.createAccountWithSeed({
                    fromPubkey: e.fromPubkey,
                    newAccountPubkey: e.stakePubkey,
                    basePubkey: e.basePubkey,
                    seed: e.seed,
                    lamports: e.lamports,
                    space: this.space,
                    programId: this.programId
                }));
                let {
                    stakePubkey: n,
                    authorized: i,
                    lockup: o
                } = e;
                return t.add(this.initialize({
                    stakePubkey: n,
                    authorized: i,
                    lockup: o
                }))
            }
            static createAccount(e) {
                let t = new cr;
                t.add(cn.createAccount({
                    fromPubkey: e.fromPubkey,
                    newAccountPubkey: e.stakePubkey,
                    lamports: e.lamports,
                    space: this.space,
                    programId: this.programId
                }));
                let {
                    stakePubkey: n,
                    authorized: i,
                    lockup: o
                } = e;
                return t.add(this.initialize({
                    stakePubkey: n,
                    authorized: i,
                    lockup: o
                }))
            }
            static delegate(e) {
                let {
                    stakePubkey: t,
                    authorizedPubkey: n,
                    votePubkey: i
                } = e, o = Eo.Delegate, a = lr(o);
                return new cr().add({
                    keys: [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: i,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: So,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: wl,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: MM,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }],
                    programId: this.programId,
                    data: a
                })
            }
            static authorize(e) {
                let {
                    stakePubkey: t,
                    authorizedPubkey: n,
                    newAuthorizedPubkey: i,
                    stakeAuthorizationType: o,
                    custodianPubkey: a
                } = e, y = Eo.Authorize, g = lr(y, {
                    newAuthorized: Xt(i.toBuffer()),
                    stakeAuthorizationType: o.index
                }), E = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: So,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }];
                return a && E.push({
                    pubkey: a,
                    isSigner: !1,
                    isWritable: !1
                }), new cr().add({
                    keys: E,
                    programId: this.programId,
                    data: g
                })
            }
            static authorizeWithSeed(e) {
                let {
                    stakePubkey: t,
                    authorityBase: n,
                    authoritySeed: i,
                    authorityOwner: o,
                    newAuthorizedPubkey: a,
                    stakeAuthorizationType: y,
                    custodianPubkey: g
                } = e, E = Eo.AuthorizeWithSeed, A = lr(E, {
                    newAuthorized: Xt(a.toBuffer()),
                    stakeAuthorizationType: y.index,
                    authoritySeed: i,
                    authorityOwner: Xt(o.toBuffer())
                }), I = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }, {
                    pubkey: So,
                    isSigner: !1,
                    isWritable: !1
                }];
                return g && I.push({
                    pubkey: g,
                    isSigner: !1,
                    isWritable: !1
                }), new cr().add({
                    keys: I,
                    programId: this.programId,
                    data: A
                })
            }
            static splitInstruction(e) {
                let {
                    stakePubkey: t,
                    authorizedPubkey: n,
                    splitStakePubkey: i,
                    lamports: o
                } = e, a = Eo.Split, y = lr(a, {
                    lamports: o
                });
                return new wr({
                    keys: [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: i,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }],
                    programId: this.programId,
                    data: y
                })
            }
            static split(e) {
                let t = new cr;
                return t.add(cn.createAccount({
                    fromPubkey: e.authorizedPubkey,
                    newAccountPubkey: e.splitStakePubkey,
                    lamports: 0,
                    space: this.space,
                    programId: this.programId
                })), t.add(this.splitInstruction(e))
            }
            static splitWithSeed(e) {
                let {
                    stakePubkey: t,
                    authorizedPubkey: n,
                    splitStakePubkey: i,
                    basePubkey: o,
                    seed: a,
                    lamports: y
                } = e, g = new cr;
                return g.add(cn.allocate({
                    accountPubkey: i,
                    basePubkey: o,
                    seed: a,
                    space: this.space,
                    programId: this.programId
                })), g.add(this.splitInstruction({
                    stakePubkey: t,
                    authorizedPubkey: n,
                    splitStakePubkey: i,
                    lamports: y
                }))
            }
            static merge(e) {
                let {
                    stakePubkey: t,
                    sourceStakePubKey: n,
                    authorizedPubkey: i
                } = e, o = Eo.Merge, a = lr(o);
                return new cr().add({
                    keys: [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: n,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: So,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: wl,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: i,
                        isSigner: !0,
                        isWritable: !1
                    }],
                    programId: this.programId,
                    data: a
                })
            }
            static withdraw(e) {
                let {
                    stakePubkey: t,
                    authorizedPubkey: n,
                    toPubkey: i,
                    lamports: o,
                    custodianPubkey: a
                } = e, y = Eo.Withdraw, g = lr(y, {
                    lamports: o
                }), E = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: i,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: So,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: wl,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }];
                return a && E.push({
                    pubkey: a,
                    isSigner: !1,
                    isWritable: !1
                }), new cr().add({
                    keys: E,
                    programId: this.programId,
                    data: g
                })
            }
            static deactivate(e) {
                let {
                    stakePubkey: t,
                    authorizedPubkey: n
                } = e, i = Eo.Deactivate, o = lr(i);
                return new cr().add({
                    keys: [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: So,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }],
                    programId: this.programId,
                    data: o
                })
            }
        };
    Hc.programId = new Mt("Stake11111111111111111111111111111111111111");
    Hc.space = 200;
    var {
        publicKeyCreate: AM,
        ecdsaSign: IM
    } = yv.default, dv = 32, El = 20, pv = 64, BM = 11, Sl = $.struct([$.u8("numSignatures"), $.u16("signatureOffset"), $.u8("signatureInstructionIndex"), $.u16("ethAddressOffset"), $.u8("ethAddressInstructionIndex"), $.u16("messageDataOffset"), $.u16("messageDataSize"), $.u8("messageInstructionIndex"), $.blob(20, "ethAddress"), $.blob(64, "signature"), $.u8("recoveryId")]), Zo = class {
        constructor() {}
        static publicKeyToEthAddress(e) {
            un(e.length === pv, `Public key must be ${pv} bytes but received ${e.length} bytes`);
            try {
                return Et.Buffer.from(Al.default.keccak_256.update(Xt(e)).digest()).slice(-El)
            } catch (t) {
                throw new Error(`Error constructing Ethereum address: ${t}`)
            }
        }
        static createInstructionWithPublicKey(e) {
            let {
                publicKey: t,
                message: n,
                signature: i,
                recoveryId: o,
                instructionIndex: a
            } = e;
            return Zo.createInstructionWithEthAddress({
                ethAddress: Zo.publicKeyToEthAddress(t),
                message: n,
                signature: i,
                recoveryId: o,
                instructionIndex: a
            })
        }
        static createInstructionWithEthAddress(e) {
            let {
                ethAddress: t,
                message: n,
                signature: i,
                recoveryId: o,
                instructionIndex: a = 0
            } = e, y;
            typeof t == "string" ? t.startsWith("0x") ? y = Et.Buffer.from(t.substr(2), "hex") : y = Et.Buffer.from(t, "hex") : y = t, un(y.length === El, `Address must be ${El} bytes but received ${y.length} bytes`);
            let g = 1 + BM,
                E = g,
                A = g + y.length,
                I = A + i.length + 1,
                q = 1,
                L = Et.Buffer.alloc(Sl.span + n.length);
            return Sl.encode({
                numSignatures: q,
                signatureOffset: A,
                signatureInstructionIndex: a,
                ethAddressOffset: E,
                ethAddressInstructionIndex: a,
                messageDataOffset: I,
                messageDataSize: n.length,
                messageInstructionIndex: a,
                signature: Xt(i),
                ethAddress: Xt(y),
                recoveryId: o
            }, L), L.fill(Xt(n), Sl.span), new wr({
                keys: [],
                programId: Zo.programId,
                data: L
            })
        }
        static createInstructionWithPrivateKey(e) {
            let {
                privateKey: t,
                message: n,
                instructionIndex: i
            } = e;
            un(t.length === dv, `Private key must be ${dv} bytes but received ${t.length} bytes`);
            try {
                let o = Xt(t),
                    a = AM(o, !1).slice(1),
                    y = Et.Buffer.from(Al.default.keccak_256.update(Xt(n)).digest()),
                    {
                        signature: g,
                        recid: E
                    } = IM(y, o);
                return this.createInstructionWithPublicKey({
                    publicKey: a,
                    message: n,
                    signature: g,
                    recoveryId: E,
                    instructionIndex: i
                })
            } catch (o) {
                throw new Error(`Error creating instruction; ${o}`)
            }
        }
    };
    Zo.programId = new Mt("KeccakSecp256k11111111111111111111111111111");
    var xU = new Mt("Va1idator1nfo111111111111111111111111111111"),
        vU = _e({
            name: nt(),
            website: tr(nt()),
            details: tr(nt()),
            keybaseUsername: tr(nt())
        });
    var wU = new Mt("Vote111111111111111111111111111111111111111"),
        _U = $.struct([rr("nodePubkey"), rr("authorizedWithdrawer"), $.u8("commission"), $.nu64(), $.seq($.struct([$.nu64("slot"), $.u32("confirmationCount")]), $.offset($.u32(), -8), "votes"), $.u8("rootSlotValid"), $.nu64("rootSlot"), $.nu64(), $.seq($.struct([$.nu64("epoch"), rr("authorizedVoter")]), $.offset($.u32(), -8), "authorizedVoters"), $.struct([$.seq($.struct([rr("authorizedPubkey"), $.nu64("epochOfLastAuthorizedSwitch"), $.nu64("targetEpoch")]), 32, "buf"), $.nu64("idx"), $.u8("isEmpty")], "priorVoters"), $.nu64(), $.seq($.struct([$.nu64("epoch"), $.nu64("credits"), $.nu64("prevCredits")]), $.offset($.u32(), -8), "epochCredits"), $.struct([$.nu64("slot"), $.nu64("timestamp")], "lastTimestamp")]);
    var Ml = Object.freeze({
            InitializeAccount: {
                index: 0,
                layout: $.struct([$.u32("instruction"), GS()])
            },
            Authorize: {
                index: 1,
                layout: $.struct([$.u32("instruction"), rr("newAuthorized"), $.u32("voteAuthorizationType")])
            },
            Withdraw: {
                index: 3,
                layout: $.struct([$.u32("instruction"), $.ns64("lamports")])
            }
        }),
        EU = Object.freeze({
            Voter: {
                index: 0
            },
            Withdrawer: {
                index: 1
            }
        }),
        Vc = class {
            constructor() {}
            static initializeAccount(e) {
                let {
                    votePubkey: t,
                    nodePubkey: n,
                    voteInit: i
                } = e, o = Ml.InitializeAccount, a = lr(o, {
                    voteInit: {
                        nodePubkey: Xt(i.nodePubkey.toBuffer()),
                        authorizedVoter: Xt(i.authorizedVoter.toBuffer()),
                        authorizedWithdrawer: Xt(i.authorizedWithdrawer.toBuffer()),
                        commission: i.commission
                    }
                }), y = {
                    keys: [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: Ha,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: So,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }],
                    programId: this.programId,
                    data: a
                };
                return new wr(y)
            }
            static createAccount(e) {
                let t = new cr;
                return t.add(cn.createAccount({
                    fromPubkey: e.fromPubkey,
                    newAccountPubkey: e.votePubkey,
                    lamports: e.lamports,
                    space: this.space,
                    programId: this.programId
                })), t.add(this.initializeAccount({
                    votePubkey: e.votePubkey,
                    nodePubkey: e.voteInit.nodePubkey,
                    voteInit: e.voteInit
                }))
            }
            static authorize(e) {
                let {
                    votePubkey: t,
                    authorizedPubkey: n,
                    newAuthorizedPubkey: i,
                    voteAuthorizationType: o
                } = e, a = Ml.Authorize, y = lr(a, {
                    newAuthorized: Xt(i.toBuffer()),
                    voteAuthorizationType: o.index
                }), g = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: So,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }];
                return new cr().add({
                    keys: g,
                    programId: this.programId,
                    data: y
                })
            }
            static withdraw(e) {
                let {
                    votePubkey: t,
                    authorizedWithdrawerPubkey: n,
                    lamports: i,
                    toPubkey: o
                } = e, a = Ml.Withdraw, y = lr(a, {
                    lamports: i
                }), g = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: o,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }];
                return new cr().add({
                    keys: g,
                    programId: this.programId,
                    data: y
                })
            }
        };
    Vc.programId = new Mt("Vote111111111111111111111111111111111111111");
    Vc.space = 3731;
    var Zv = jt(Ti()),
        Wl = jt(ps());
    var zM = jt(Ti()),
        UM = jt(ps()),
        Xc = jt(Rs());
    var RM = jt(a0()),
        Qs = jt(Rs());
    var kM = jt(ps());
    var Qc = jt(Rs());
    var NM = jt(Ti());
    var Kl = class extends Error {
        constructor(t) {
            super(`Signature ${t} has expired: block height exceeded.`);
            this.signature = t
        }
    };
    Object.defineProperty(Kl.prototype, "name", {
        value: "TransactionExpiredBlockheightExceededError"
    });
    var $l = class extends Error {
        constructor(t, n) {
            super(`Transaction was not confirmed in ${n.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`);
            this.signature = t
        }
    };
    Object.defineProperty($l.prototype, "name", {
        value: "TransactionExpiredTimeoutError"
    });
    var qM = jt(Ti()),
        Gv = jt(ps());
    var Wv = jt(Xh()),
        Hv = Wv.default.sign.detached;
    var lN = Gv.Buffer.alloc(64).fill(0);
    var jl = jt(Rs());
    var WN = Wl.Buffer.alloc(64).fill(0);
    var OM = r => r && "version" in r,
        DM = (r, e) => OM(r) ? Wl.Buffer.from(r.serialize()) : r.serialize(e ?? {
            requireAllSignatures: !1,
            verifySignatures: !1
        }),
        Hl = (r, e) => Zv.default.encode(DM(r, e));
    var ia = jt(Ti()),
        b3 = jt(l3()),
        x3 = jt(pa());
    var td = {
            [4001]: {
                message: "User rejected the request."
            },
            [-32603]: {
                message: "Something went wrong."
            },
            [-32601]: {
                message: "Method does not exist."
            },
            [-32e3]: {
                message: "Missing or invalid parameters."
            },
            [4100]: {
                message: "The requested method and/or account has not been authorized by the user."
            },
            [4900]: {
                message: "Error connecting to the blockchain."
            },
            [-32003]: {
                message: "Transaction creation failed."
            },
            [-32002]: {
                message: "Requested resource not available."
            }
        },
        rh = (r, e) => ({
            code: r,
            message: e != null ? e : td[r].message
        });
    var d3 = "beforeunload",
        nh = "message",
        ih = class {
            constructor() {
                this.addBeforeUnloadEventListener = e => {
                    window.addEventListener(d3, e)
                };
                this.addMessageEventListener = e => {
                    window.addEventListener(nh, e)
                };
                this.removeMessageEventListener = e => {
                    window.removeEventListener(nh, e)
                }
            }
        },
        oh = class {
            constructor() {
                this.addBeforeUnloadEventListener = e => {
                    document.addEventListener(d3, e)
                };
                this.addMessageEventListener = e => {
                    document.addEventListener(nh, e)
                };
                this.removeMessageEventListener = e => {
                    document.removeEventListener(nh, e)
                }
            }
        };
    var sh = r => {
            window.ReactNativeWebView.postMessage(JSON.stringify(r))
        },
        p3 = () => {
            var i;
            let r = document.querySelector("meta[property='og:title']"),
                e = (i = r == null ? void 0 : r.content) != null ? i : document.title,
                t = document.querySelectorAll("head link[rel^=apple-touch-icon]"),
                n = Array.from(t).map(o => {
                    var A;
                    let [a, y] = ((A = o.sizes.value) != null ? A : "0x0").split("x"), g = parseInt(a, 10) || 0, E = parseInt(y, 10) || 0;
                    return {
                        href: o.href,
                        size: {
                            width: g,
                            height: E
                        }
                    }
                });
            return {
                title: e,
                url: "",
                icons: n
            }
        };
    var y3 = r => {
            try {
                let e = JSON.parse(r);
                return !e || typeof e != "object" || e.jsonrpc !== "2.0" || typeof e.id != "number" || !("result" in e) && !("error" in e) ? null : e
            } catch (e) {}
            return null
        },
        m3 = (r, e = {}, t = Date.now()) => {
            switch (r) {
                case "connect": {
                    let {
                        onlyIfTrusted: n
                    } = e;
                    return typeof n != "undefined" && typeof n != "boolean" ? null : {
                        jsonrpc: "2.0",
                        id: t,
                        method: r,
                        params: {
                            onlyIfTrusted: n != null ? n : !1
                        }
                    }
                }
                case "disconnect":
                    return {
                        jsonrpc: "2.0", id: t, method: r
                    };
                case "signMessage": {
                    let {
                        message: n,
                        display: i
                    } = e;
                    return !n || typeof n != "string" || i !== "hex" && i !== "utf8" ? null : {
                        jsonrpc: "2.0",
                        id: t,
                        method: r,
                        params: {
                            message: n,
                            display: i
                        }
                    }
                }
                case "signTransaction": {
                    let {
                        transaction: n
                    } = e;
                    return typeof n != "string" ? null : {
                        jsonrpc: "2.0",
                        id: t,
                        method: r,
                        params: {
                            transaction: n
                        }
                    }
                }
                case "signAllTransactions": {
                    let {
                        transactions: n
                    } = e;
                    if (!Array.isArray(n)) return null;
                    for (let o of n)
                        if (typeof o != "string") return null;
                    return {
                        jsonrpc: "2.0",
                        id: t,
                        method: r,
                        params: {
                            transactions: n
                        }
                    }
                }
                case "signAndSendTransaction": {
                    let {
                        transaction: n
                    } = e;
                    if (typeof n != "string") return null;
                    let i;
                    if (typeof e.options == "object" && e.options !== null) {
                        let {
                            skipPreflight: a,
                            preflightCommitment: y
                        } = e.options;
                        if ("skipPreflight" in e.options && typeof e.options.skipPreflight != "boolean" || "preflightCommitment" in e.options && !(typeof e.options.preflightCommitment == "string" && /^(processed|confirmed|finalized|recent|single|singleGossip|root|max)/.test(e.options.preflightCommitment))) return null;
                        i = {
                            skipPreflight: a,
                            preflightCommitment: y
                        }
                    }
                    return {
                        jsonrpc: "2.0",
                        id: t,
                        method: r,
                        params: {
                            transaction: n,
                            options: i
                        }
                    }
                }
                default:
                    return null
            }
        };
    var g3 = () => {
        let r = window.navigator.userAgent.toLowerCase();
        return /iphone|ipod|ipad/.test(r)
    };
    var ei, sa, Ja, rd = class extends x3.EventEmitter {
            constructor(t) {
                super();
                Fn(this, ei, null);
                Fn(this, sa, void 0);
                this.connect = (...n) => xr(this, [...n], function*(t = {}) {
                    if (sr(this, ei)) return {
                        publicKey: sr(this, ei)
                    };
                    let i = yield this.request("connect", t);
                    return Mn(this, ei, new Mt(i.publicKey)), this.emit("connect", sr(this, ei)), {
                        publicKey: sr(this, ei)
                    }
                });
                this.disconnect = () => xr(this, null, function*() {
                    try {
                        if (yield this.request("disconnect", void 0), !this.isConnected) return;
                        Mn(this, ei, null), this.emit("disconnect")
                    } catch (t) {
                        sh(t.message)
                    }
                });
                this.signMessage = (t, n = "utf8") => xr(this, null, function*() {
                    let i = {
                            message: ia.default.encode(b3.Buffer.from(t)),
                            display: n
                        },
                        o = yield this.request("signMessage", i), a = ia.default.decode(o.signature), y = new Mt(o.publicKey);
                    return {
                        signature: a,
                        publicKey: y
                    }
                });
                this.signTransaction = t => xr(this, null, function*() {
                    let n = {
                            transaction: Hl(t, {
                                requireAllSignatures: !1,
                                verifySignatures: !1
                            })
                        },
                        i = yield this.request("signTransaction", n), o = ia.default.decode(i.signature), a = new Mt(i.publicKey);
                    return t.addSignature(a, o), t
                });
                this.signAllTransactions = t => xr(this, null, function*() {
                    let n = {
                            transactions: t.map(y => Hl(y, {
                                requireAllSignatures: !1,
                                verifySignatures: !1
                            }))
                        },
                        i = yield this.request("signAllTransactions", n), o = i.signatures.map(ia.default.decode), a = new Mt(i.publicKey);
                    return t.map((y, g) => (y.addSignature(a, o[g]), y))
                });
                this.signAndSendTransaction = (t, n) => xr(this, null, function*() {
                    let i = {
                            transaction: ia.default.encode(t.serialize({
                                requireAllSignatures: !1,
                                verifySignatures: !1
                            })),
                            options: n
                        },
                        o = yield this.request("signAndSendTransaction", i), a = o.signature, y = new Mt(o.publicKey);
                    return {
                        signature: a,
                        publicKey: y
                    }
                });
                Fn(this, Ja, new Map);
                this.request = (t, n) => {
                    if (!this.isConnected && t !== "connect") return Promise.reject(rh(4100));
                    let i = m3(t, n);
                    return i ? new Promise((o, a) => {
                        let y = g => {
                            if (typeof g.data != "string") {
                                let A = {
                                    code: -32603,
                                    message: td[-32603].message
                                };
                                a(A);
                                return
                            }
                            let E = y3(g.data);
                            if (E && E.id === i.id) {
                                if (sr(this, sa).removeMessageEventListener(y), sr(this, Ja).delete(i.id), !this.isConnected && t !== "connect" && t !== "disconnect") {
                                    a(rh(4100));
                                    return
                                }
                                "error" in E ? a(E.error) : o(E.result)
                            }
                        };
                        sr(this, Ja).set(i.id, y), sr(this, sa).addMessageEventListener(y), sh(i)
                    }) : Promise.reject(rh(-32e3))
                };
                this.notify = (t, n) => {
                    sh({
                        jsonrpc: "2.0",
                        method: t,
                        params: n
                    })
                };
                Mn(this, sa, t)
            }
            get publicKey() {
                return sr(this, ei)
            }
            get isConnected() {
                return sr(this, ei) !== null
            }
            get isPhantom() {
                return !0
            }
        },
        oa = rd;
    ei = new WeakMap, sa = new WeakMap, Ja = new WeakMap, oa.inject = () => {
        let t = g3() ? new ih : new oh,
            n = new rd(t);
        n.notify("dappMeta", p3()), Object.defineProperty(window, "solana", {
            value: n,
            writable: !1
        }), window.phantom || Object.defineProperty(window, "phantom", {
            value: {},
            writable: !1
        }), Object.defineProperty(window.phantom, "solana", {
            value: n,
            writable: !1
        })
    };
    try {
        oa.inject(), Lg()
    } catch {}
})();
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Support for translating between Uint8Array instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */